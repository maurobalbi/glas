2023-08-04T09:30:46.052816Z  INFO gleamalyzer: Max concurrent requests: 8
2023-08-04T09:30:46.053654Z DEBUG salsa::lru: green_zone = 0..12    
2023-08-04T09:30:46.053691Z DEBUG salsa::lru: yellow_zone = 12..37    
2023-08-04T09:30:46.053700Z DEBUG salsa::lru: red_zone = 37..128    
2023-08-04T09:30:46.053873Z DEBUG salsa::input: PackageGraphQuery(()) = PackageGraph { nodes: {} } (Durability(1))    
2023-08-04T09:30:46.053920Z DEBUG salsa::runtime: increment_revision()    
2023-08-04T09:30:46.053928Z DEBUG salsa::runtime: increment_revision: incremented to R2    
2023-08-04T09:30:46.056073Z  INFO gleamalyzer::server: Init params: InitializeParams { process_id: Some(7971), root_path: Some("/Users/maurobalbi/Documents/repos/try_gleam"), root_uri: Some(Url { scheme: "file", cannot_be_a_base: false, username: "", password: None, host: None, port: None, path: "/Users/maurobalbi/Documents/repos/try_gleam", query: None, fragment: None }), initialization_options: None, capabilities: ClientCapabilities { workspace: Some(WorkspaceClientCapabilities { apply_edit: Some(true), workspace_edit: Some(WorkspaceEditClientCapabilities { document_changes: Some(true), resource_operations: Some([Create, Rename, Delete]), failure_handling: Some(TextOnlyTransactional), normalizes_line_endings: Some(true), change_annotation_support: Some(ChangeAnnotationWorkspaceEditClientCapabilities { groups_on_label: Some(true) }) }), did_change_configuration: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), did_change_watched_files: Some(DidChangeWatchedFilesClientCapabilities { dynamic_registration: Some(true), relative_pattern_support: None }), symbol: Some(WorkspaceSymbolClientCapabilities { dynamic_registration: Some(true), symbol_kind: Some(SymbolKindCapability { value_set: Some([File, Module, Namespace, Package, Class, Method, Property, Field, Constructor, Enum, Interface, Function, Variable, Constant, String, Number, Boolean, Array, Object, Key, Null, EnumMember, Struct, Event, Operator, TypeParameter]) }), tag_support: Some(TagSupport { value_set: [Deprecated] }), resolve_support: None }), execute_command: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), workspace_folders: Some(true), configuration: Some(true), semantic_tokens: Some(SemanticTokensWorkspaceClientCapabilities { refresh_support: Some(true) }), code_lens: Some(CodeLensWorkspaceClientCapabilities { refresh_support: Some(true) }), file_operations: Some(WorkspaceFileOperationsClientCapabilities { dynamic_registration: Some(true), did_create: Some(true), will_create: Some(true), did_rename: Some(true), will_rename: Some(true), did_delete: Some(true), will_delete: Some(true) }), inline_value: None, inlay_hint: None }), text_document: Some(TextDocumentClientCapabilities { synchronization: Some(TextDocumentSyncClientCapabilities { dynamic_registration: Some(true), will_save: Some(true), will_save_wait_until: Some(true), did_save: Some(true) }), completion: Some(CompletionClientCapabilities { dynamic_registration: Some(true), completion_item: Some(CompletionItemCapability { snippet_support: Some(true), commit_characters_support: Some(true), documentation_format: Some([Markdown, PlainText]), deprecated_support: Some(true), preselect_support: Some(true), tag_support: Some(TagSupport { value_set: [Deprecated] }), insert_replace_support: Some(true), resolve_support: Some(CompletionItemCapabilityResolveSupport { properties: ["documentation", "detail", "additionalTextEdits"] }), insert_text_mode_support: Some(InsertTextModeSupport { value_set: [AsIs, AdjustIndentation] }), label_details_support: None }), completion_item_kind: Some(CompletionItemKindCapability { value_set: Some([Text, Method, Function, Constructor, Field, Variable, Class, Interface, Module, Property, Unit, Value, Enum, Keyword, Snippet, Color, File, Reference, Folder, EnumMember, Constant, Struct, Event, Operator, TypeParameter]) }), context_support: Some(true), insert_text_mode: None, completion_list: None }), hover: Some(HoverClientCapabilities { dynamic_registration: Some(true), content_format: Some([Markdown, PlainText]) }), signature_help: Some(SignatureHelpClientCapabilities { dynamic_registration: Some(true), signature_information: Some(SignatureInformationSettings { documentation_format: Some([Markdown, PlainText]), parameter_information: Some(ParameterInformationSettings { label_offset_support: Some(true) }), active_parameter_support: Some(true) }), context_support: Some(true) }), references: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), document_highlight: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), document_symbol: Some(DocumentSymbolClientCapabilities { dynamic_registration: Some(true), symbol_kind: Some(SymbolKindCapability { value_set: Some([File, Module, Namespace, Package, Class, Method, Property, Field, Constructor, Enum, Interface, Function, Variable, Constant, String, Number, Boolean, Array, Object, Key, Null, EnumMember, Struct, Event, Operator, TypeParameter]) }), hierarchical_document_symbol_support: Some(true), tag_support: Some(TagSupport { value_set: [Deprecated] }) }), formatting: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), range_formatting: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), on_type_formatting: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), declaration: Some(GotoCapability { dynamic_registration: Some(true), link_support: Some(true) }), definition: Some(GotoCapability { dynamic_registration: Some(true), link_support: Some(true) }), type_definition: Some(GotoCapability { dynamic_registration: Some(true), link_support: Some(true) }), implementation: Some(GotoCapability { dynamic_registration: Some(true), link_support: Some(true) }), code_action: Some(CodeActionClientCapabilities { dynamic_registration: Some(true), code_action_literal_support: Some(CodeActionLiteralSupport { code_action_kind: CodeActionKindLiteralSupport { value_set: ["", "quickfix", "refactor", "refactor.extract", "refactor.inline", "refactor.rewrite", "source", "source.organizeImports"] } }), is_preferred_support: Some(true), disabled_support: Some(true), data_support: Some(true), resolve_support: Some(CodeActionCapabilityResolveSupport { properties: ["edit"] }), honors_change_annotations: Some(false) }), code_lens: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), document_link: Some(DocumentLinkClientCapabilities { dynamic_registration: Some(true), tooltip_support: Some(true) }), color_provider: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), rename: Some(RenameClientCapabilities { dynamic_registration: Some(true), prepare_support: Some(true), prepare_support_default_behavior: Some(Identifier), honors_change_annotations: Some(true) }), publish_diagnostics: Some(PublishDiagnosticsClientCapabilities { related_information: Some(true), tag_support: Some(TagSupport { value_set: [Unnecessary, Deprecated] }), version_support: Some(false), code_description_support: Some(true), data_support: Some(true) }), folding_range: Some(FoldingRangeClientCapabilities { dynamic_registration: Some(true), range_limit: Some(5000), line_folding_only: Some(true), folding_range_kind: None, folding_range: None }), selection_range: Some(SelectionRangeClientCapabilities { dynamic_registration: Some(true) }), linked_editing_range: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), call_hierarchy: Some(DynamicRegistrationClientCapabilities { dynamic_registration: Some(true) }), semantic_tokens: Some(SemanticTokensClientCapabilities { dynamic_registration: Some(true), requests: SemanticTokensClientCapabilitiesRequests { range: Some(true), full: Some(Delta { delta: Some(true) }) }, token_types: [SemanticTokenType("namespace"), SemanticTokenType("type"), SemanticTokenType("class"), SemanticTokenType("enum"), SemanticTokenType("interface"), SemanticTokenType("struct"), SemanticTokenType("typeParameter"), SemanticTokenType("parameter"), SemanticTokenType("variable"), SemanticTokenType("property"), SemanticTokenType("enumMember"), SemanticTokenType("event"), SemanticTokenType("function"), SemanticTokenType("method"), SemanticTokenType("macro"), SemanticTokenType("keyword"), SemanticTokenType("modifier"), SemanticTokenType("comment"), SemanticTokenType("string"), SemanticTokenType("number"), SemanticTokenType("regexp"), SemanticTokenType("operator")], token_modifiers: [SemanticTokenModifier("declaration"), SemanticTokenModifier("definition"), SemanticTokenModifier("readonly"), SemanticTokenModifier("static"), SemanticTokenModifier("deprecated"), SemanticTokenModifier("abstract"), SemanticTokenModifier("async"), SemanticTokenModifier("modification"), SemanticTokenModifier("documentation"), SemanticTokenModifier("defaultLibrary")], formats: [TokenFormat("relative")], overlapping_token_support: Some(false), multiline_token_support: Some(false), server_cancel_support: None, augments_syntax_tokens: None }), moniker: None, type_hierarchy: None, inline_value: None, inlay_hint: None }), window: Some(WindowClientCapabilities { work_done_progress: Some(true), show_message: Some(ShowMessageRequestClientCapabilities { message_action_item: Some(MessageActionItemCapabilities { additional_properties_support: Some(true) }) }), show_document: Some(ShowDocumentClientCapabilities { support: true }) }), general: Some(GeneralClientCapabilities { regular_expressions: Some(RegularExpressionsClientCapabilities { engine: "ECMAScript", version: Some("ES2020") }), markdown: Some(MarkdownClientCapabilities { parser: "marked", version: Some("1.1.0"), allowed_tags: None }), stale_request_support: None, position_encodings: None }), experimental: None }, trace: Some(Off), workspace_folders: Some([WorkspaceFolder { uri: Url { scheme: "file", cannot_be_a_base: false, username: "", password: None, host: None, port: None, path: "/Users/maurobalbi/Documents/repos/try_gleam", query: None, fragment: None }, name: "try_gleam" }]), client_info: Some(ClientInfo { name: "Visual Studio Code", version: Some("1.80.2") }), locale: Some("en-gb") }
2023-08-04T09:30:46.056432Z  INFO request{method="initialize"}: gleamalyzer::meter: respond with ~199 bytes in 1.175209ms
2023-08-04T09:30:46.056520Z  WARN async_lsp::client_monitor: Unsupported platform to monitor exit of non-child processes, fallback to polling with kill(2)
2023-08-04T09:30:46.060150Z  INFO notification{method="initialized"}: gleamalyzer::meter: handled notification in 137.875µs
2023-08-04T09:30:46.060680Z DEBUG notification{method="textDocument/didOpen"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.060701Z DEBUG notification{method="textDocument/didOpen"}: salsa::runtime: increment_revision: incremented to R3    
2023-08-04T09:30:46.060717Z DEBUG notification{method="textDocument/didOpen"}: salsa::input: FileContentQuery(FileId(0)) = "import blabla2.{main, B, Bla}\nimport gliew.{worker_loop}\nfn main() {\n  \n}\nif erlang {\n  fn bla(b) {\n    let b = b\n\n    b\n  }\n}\n\n\nif javascript {\n  fn bla(aa) {\n    snake()\n    let b = aa\n    let bbb = InvalidBase\n    b\n  }\n}\n\nfn snake() {\n  rat(1)\n}\n\nfn rat(a) {\n  snake()\n}\n\nconst asdfasdfasdf = 1\n\n// type Bla {\n//   Bla(name: Int)\n// }\n\nfn bla2(bbb) {\n  let asdf = Bla(name: 1)\n  asdf.name\n  bbb\n  // use a <- bla\n  a\n  // bla()\n  // snake()\n  // dodo()\n  // main\n  // worker_loop\n  // b\n  // Bla(a, 2)\n  // bbb\n}\n\nfn dodo(a) {\n  case a {\n    #(a,b) -> {\n      b\n    }\n  }\n  b\n  a +. 1.1\n  bla()\n  let a = 1\n  a\n}\n" (Durability(0))    
2023-08-04T09:30:46.060739Z DEBUG notification{method="textDocument/didOpen"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.060748Z DEBUG notification{method="textDocument/didOpen"}: salsa::runtime: increment_revision: incremented to R4    
2023-08-04T09:30:46.060802Z  INFO notification{method="textDocument/didOpen"}: gleamalyzer::meter: handled notification in 320.292µs
2023-08-04T09:30:46.060855Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.060902Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R4    
2023-08-04T09:30:46.060976Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): read_upgrade(revision_now=R4)    
2023-08-04T09:30:46.061016Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.061038Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): executing query    
2023-08-04T09:30:46.061046Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.061956Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(0))): result.changed_at=R4, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 1, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.062004Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(0))): inputs=Tracked {
    inputs: [
        file_content(FileId(0)),
    ],
}    
2023-08-04T09:30:46.062036Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.062045Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.062052Z DEBUG salsa::lru: record_use: index=18446744073709551615    
2023-08-04T09:30:46.062060Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.062067Z DEBUG salsa::lru: inserted node ParseQuery(FileId(0)) at 0    
2023-08-04T09:30:46.062074Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.062084Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062098Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R4    
2023-08-04T09:30:46.062117Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): read_upgrade(revision_now=R4)    
2023-08-04T09:30:46.062125Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.062133Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): executing query    
2023-08-04T09:30:46.062139Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062147Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R4    
2023-08-04T09:30:46.062154Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R4, changed_at=R4    
2023-08-04T09:30:46.062161Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.062167Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.062174Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.062180Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.062195Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062218Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.062246Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): read_upgrade(revision_now=R4)    
2023-08-04T09:30:46.062254Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.062260Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): executing query    
2023-08-04T09:30:46.062267Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062278Z DEBUG salsa::derived::slot: read_upgrade(SourceRootPackageInfoQuery(SourceRootId(0))): result.changed_at=R2, result.durability=Durability(1), result.dependencies = Some({DatabaseKeyIndex { group_index: 1, query_index: 4, key_index: 0 }})    
2023-08-04T09:30:46.062288Z DEBUG salsa::derived::slot: read_upgrade(SourceRootPackageInfoQuery(SourceRootId(0))): inputs=Tracked {
    inputs: [
        package_graph(()),
    ],
}    
2023-08-04T09:30:46.062303Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.062452Z DEBUG gleamalyzer::server: Updating config: [Null]
2023-08-04T09:30:46.062636Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.062720Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062731Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.062739Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.062746Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.062753Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.062760Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.062776Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062784Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.062791Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.062798Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.062804Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.062811Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.062763Z DEBUG event{type_name="gleamalyzer::server::UpdateConfigEvent"}: gleamalyzer::server: Updated config, errors: [], config: Config { root_path: "/Users/maurobalbi/Documents/repos/try_gleam", diagnostics_excluded_files: [], diagnostics_ignored: {}, formatting_command: None, gleam_binary: "gleam" }
2023-08-04T09:30:46.062825Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062834Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.062840Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.062847Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.062853Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.062859Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.062877Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062885Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.062891Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.062898Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.062904Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.062910Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.062926Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.062934Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.062940Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.062947Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.062953Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.062959Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.062970Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.063080Z  INFO gleamalyzer::server: Registered file watching for gleam.toml
2023-08-04T09:30:46.063262Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.063309Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.063337Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.063360Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.063342Z DEBUG event{type_name="lsp_types::DidChangeWatchedFilesParams"}: gleamalyzer::server: Watched files changed: DidChangeWatchedFilesParams { changes: [FileEvent { uri: Url { scheme: "file", cannot_be_a_base: false, username: "", password: None, host: None, port: None, path: "/Users/maurobalbi/Documents/repos/try_gleam/gleam.toml", query: None, fragment: None }, typ: Created }] }
2023-08-04T09:30:46.063382Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.063425Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.063435Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.063443Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.063451Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.063459Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.063467Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.063478Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.063487Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.063494Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.063500Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.063506Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.063513Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.063527Z DEBUG salsa: unwind_if_cancelled: current_revision=R4, pending_revision=R4    
2023-08-04T09:30:46.063536Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R4    
2023-08-04T09:30:46.063542Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.063549Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R2    
2023-08-04T09:30:46.063557Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.063563Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.063580Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(0))): result.changed_at=R4, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }, DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }})    
2023-08-04T09:30:46.063595Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(0))): inputs=Tracked {
    inputs: [
        parse(FileId(0)),
        source_root_package_info(SourceRootId(0)),
    ],
}    
2023-08-04T09:30:46.063615Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.063621Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.063875Z DEBUG event{type_name="lsp_types::DidChangeWatchedFilesParams"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.063920Z DEBUG event{type_name="lsp_types::DidChangeWatchedFilesParams"}: salsa::runtime: increment_revision: incremented to R5    
2023-08-04T09:30:46.063932Z DEBUG event{type_name="lsp_types::DidChangeWatchedFilesParams"}: salsa::input: FileContentQuery(FileId(1)) = "name = \"try_gleam\"\nversion = \"1.0.0\"\ntarget = \"erlang\"\n\n[dependencies]\ngleam_stdlib = \"~> 0.28\"\ngleeunit = \"~> 0.10\"\ngliew = \"~> 0.1.0\"" (Durability(0))    
2023-08-04T09:30:46.063945Z DEBUG event{type_name="lsp_types::DidChangeWatchedFilesParams"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.063954Z DEBUG event{type_name="lsp_types::DidChangeWatchedFilesParams"}: salsa::runtime: increment_revision: incremented to R6    
2023-08-04T09:30:46.064011Z DEBUG gleamalyzer::server: Publish 0 diagnostics for file:///Users/maurobalbi/Documents/repos/try_gleam/src/test.gleam
2023-08-04T09:30:46.166475Z  INFO gleamalyzer::server: Loading gleam workspace
2023-08-04T09:30:46.167629Z  INFO gleamalyzer::server: Downloading deps and loading package info
2023-08-04T09:30:46.262951Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: gleamalyzer::server: Set package info: Some(
    (
        PackageInfo {
            root_manifest: FileId(
                1,
            ),
            target: Erlang,
            display_name: "try_gleam",
            dependencies: [],
        },
        [
            "/Users/maurobalbi/Documents/repos/try_gleam",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_bitwise",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_crypto",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_http",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleeunit",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gliew",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist",
            "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai",
        ],
    ),
)
2023-08-04T09:30:46.263968Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.263986Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R7    
2023-08-04T09:30:46.264000Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: PackageGraphQuery(()) = PackageGraph { nodes: {SourceRootId(0): PackageInfo { root_manifest: FileId(1), target: Erlang, display_name: "try_gleam", dependencies: [] }} } (Durability(1))    
2023-08-04T09:30:46.264013Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264022Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R8    
2023-08-04T09:30:46.264060Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(1)) = SourceRootId(0) (Durability(2))    
2023-08-04T09:30:46.264070Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264078Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R9    
2023-08-04T09:30:46.264095Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(5)) = SourceRootId(0) (Durability(2))    
2023-08-04T09:30:46.264104Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264135Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R10    
2023-08-04T09:30:46.264145Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(3)) = SourceRootId(0) (Durability(2))    
2023-08-04T09:30:46.264153Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264161Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R11    
2023-08-04T09:30:46.264170Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(2)) = SourceRootId(0) (Durability(2))    
2023-08-04T09:30:46.264179Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264187Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R12    
2023-08-04T09:30:46.264198Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(4)) = SourceRootId(0) (Durability(2))    
2023-08-04T09:30:46.264207Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264215Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R13    
2023-08-04T09:30:46.264224Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(0)) = SourceRootId(0) (Durability(2))    
2023-08-04T09:30:46.264232Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264240Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R14    
2023-08-04T09:30:46.264250Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(0)) = SourceRoot { file_set: {FileId(1): Path("/Users/maurobalbi/Documents/repos/try_gleam/gleam.toml"), FileId(5): Path("/Users/maurobalbi/Documents/repos/try_gleam/src/blabla2.gleam"), FileId(3): Path("/Users/maurobalbi/Documents/repos/try_gleam/src/try_gleam.gleam"), FileId(2): Path("/Users/maurobalbi/Documents/repos/try_gleam/test/try_gleam_test.gleam"), FileId(4): Path("/Users/maurobalbi/Documents/repos/try_gleam/src/t.gleam"), FileId(0): Path("/Users/maurobalbi/Documents/repos/try_gleam/src/test.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam", is_library: false } (Durability(2))    
2023-08-04T09:30:46.264265Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264273Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R15    
2023-08-04T09:30:46.264287Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(7)) = SourceRootId(1) (Durability(2))    
2023-08-04T09:30:46.264295Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264303Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R16    
2023-08-04T09:30:46.264312Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(1)) = SourceRoot { file_set: {FileId(7): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_crypto/src/gleam/crypto.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_crypto", is_library: true } (Durability(2))    
2023-08-04T09:30:46.264323Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264346Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R17    
2023-08-04T09:30:46.264356Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(48)) = SourceRootId(2) (Durability(2))    
2023-08-04T09:30:46.264365Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264372Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R18    
2023-08-04T09:30:46.264383Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(49)) = SourceRootId(2) (Durability(2))    
2023-08-04T09:30:46.264392Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264400Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R19    
2023-08-04T09:30:46.264408Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(2)) = SourceRoot { file_set: {FileId(48): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleeunit/src/gleeunit/should.gleam"), FileId(49): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleeunit/src/gleeunit.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleeunit", is_library: true } (Durability(2))    
2023-08-04T09:30:46.264420Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264428Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R20    
2023-08-04T09:30:46.264437Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(63)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264445Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264453Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R21    
2023-08-04T09:30:46.264461Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(65)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264469Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264477Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R22    
2023-08-04T09:30:46.264485Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(60)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264493Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264501Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R23    
2023-08-04T09:30:46.264509Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(62)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264517Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264525Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R24    
2023-08-04T09:30:46.264533Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(64)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264541Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264558Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R25    
2023-08-04T09:30:46.264566Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(61)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264575Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264582Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R26    
2023-08-04T09:30:46.264594Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(66)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264603Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264610Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R27    
2023-08-04T09:30:46.264619Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(67)) = SourceRootId(3) (Durability(2))    
2023-08-04T09:30:46.264627Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264639Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R28    
2023-08-04T09:30:46.264649Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(3)) = SourceRoot { file_set: {FileId(63): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist/internal/file.gleam"), FileId(65): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist/internal/websocket.gleam"), FileId(60): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist.gleam"), FileId(62): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist/internal/http.gleam"), FileId(64): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist/internal/handler.gleam"), FileId(61): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist/websocket.gleam"), FileId(66): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist/internal/logger.gleam"), FileId(67): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist/src/mist/internal/encoder.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/mist", is_library: true } (Durability(2))    
2023-08-04T09:30:46.264666Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264675Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R29    
2023-08-04T09:30:46.264686Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(23)) = SourceRootId(4) (Durability(2))    
2023-08-04T09:30:46.264696Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264704Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R30    
2023-08-04T09:30:46.264713Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(19)) = SourceRootId(4) (Durability(2))    
2023-08-04T09:30:46.264722Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264730Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R31    
2023-08-04T09:30:46.264738Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(22)) = SourceRootId(4) (Durability(2))    
2023-08-04T09:30:46.264758Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264766Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R32    
2023-08-04T09:30:46.264775Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(21)) = SourceRootId(4) (Durability(2))    
2023-08-04T09:30:46.264783Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264791Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R33    
2023-08-04T09:30:46.264800Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(24)) = SourceRootId(4) (Durability(2))    
2023-08-04T09:30:46.264808Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264816Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R34    
2023-08-04T09:30:46.264825Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(25)) = SourceRootId(4) (Durability(2))    
2023-08-04T09:30:46.264833Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264841Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R35    
2023-08-04T09:30:46.264850Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(20)) = SourceRootId(4) (Durability(2))    
2023-08-04T09:30:46.264858Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264866Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R36    
2023-08-04T09:30:46.264875Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(4)) = SourceRoot { file_set: {FileId(23): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp/src/gleam/otp/node.gleam"), FileId(19): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp/src/gleam/otp/system.gleam"), FileId(22): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp/src/gleam/otp/actor.gleam"), FileId(21): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp/src/gleam/otp/task.gleam"), FileId(24): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp/src/gleam/otp/supervisor.gleam"), FileId(25): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp/src/gleam/otp/port.gleam"), FileId(20): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp/src/gleam/otp/intensity_tracker.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_otp", is_library: true } (Durability(2))    
2023-08-04T09:30:46.264892Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264900Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R37    
2023-08-04T09:30:46.264909Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(14)) = SourceRootId(5) (Durability(2))    
2023-08-04T09:30:46.264917Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264925Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R38    
2023-08-04T09:30:46.264943Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(17)) = SourceRootId(5) (Durability(2))    
2023-08-04T09:30:46.264952Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264960Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R39    
2023-08-04T09:30:46.264969Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(15)) = SourceRootId(5) (Durability(2))    
2023-08-04T09:30:46.264977Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.264985Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R40    
2023-08-04T09:30:46.264994Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(16)) = SourceRootId(5) (Durability(2))    
2023-08-04T09:30:46.265002Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265011Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R41    
2023-08-04T09:30:46.265020Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(18)) = SourceRootId(5) (Durability(2))    
2023-08-04T09:30:46.265028Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265036Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R42    
2023-08-04T09:30:46.265050Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(5)) = SourceRoot { file_set: {FileId(14): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_http/src/gleam/http.gleam"), FileId(17): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_http/src/gleam/http/cookie.gleam"), FileId(15): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_http/src/gleam/http/response.gleam"), FileId(16): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_http/src/gleam/http/request.gleam"), FileId(18): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_http/src/gleam/http/service.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_http", is_library: true } (Durability(2))    
2023-08-04T09:30:46.265066Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265074Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R43    
2023-08-04T09:30:46.265083Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(59)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265092Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265100Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R44    
2023-08-04T09:30:46.265109Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(56)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265117Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265125Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R45    
2023-08-04T09:30:46.265134Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(55)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265160Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265169Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R46    
2023-08-04T09:30:46.265178Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(58)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265187Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265195Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R47    
2023-08-04T09:30:46.265204Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(57)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265212Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265220Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R48    
2023-08-04T09:30:46.265228Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(52)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265236Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265244Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R49    
2023-08-04T09:30:46.265252Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(51)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265261Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265268Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R50    
2023-08-04T09:30:46.265276Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(53)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265285Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265292Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R51    
2023-08-04T09:30:46.265301Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(54)) = SourceRootId(6) (Durability(2))    
2023-08-04T09:30:46.265309Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265316Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R52    
2023-08-04T09:30:46.265325Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(6)) = SourceRoot { file_set: {FileId(59): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/socket/transport.gleam"), FileId(56): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/logger.gleam"), FileId(55): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/tcp.gleam"), FileId(58): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/socket/options.gleam"), FileId(57): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/acceptor.gleam"), FileId(52): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/ssl.gleam"), FileId(51): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten.gleam"), FileId(53): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/handler.gleam"), FileId(54): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten/src/glisten/socket.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/glisten", is_library: true } (Durability(2))    
2023-08-04T09:30:46.265359Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265367Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R53    
2023-08-04T09:30:46.265376Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(39)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265384Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265392Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R54    
2023-08-04T09:30:46.265401Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(28)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265409Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265416Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R55    
2023-08-04T09:30:46.265425Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(34)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265433Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265441Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R56    
2023-08-04T09:30:46.265449Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(42)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265457Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265465Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R57    
2023-08-04T09:30:46.265473Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(37)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265481Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265489Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R58    
2023-08-04T09:30:46.265497Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(44)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265505Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265513Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R59    
2023-08-04T09:30:46.265521Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(41)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265529Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265537Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R60    
2023-08-04T09:30:46.265545Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(27)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265562Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265571Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R61    
2023-08-04T09:30:46.265579Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(36)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265587Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265595Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R62    
2023-08-04T09:30:46.265604Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(46)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265612Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265619Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R63    
2023-08-04T09:30:46.265628Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(32)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265636Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265643Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R64    
2023-08-04T09:30:46.265652Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(31)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265660Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265667Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R65    
2023-08-04T09:30:46.265676Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(35)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265684Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265691Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R66    
2023-08-04T09:30:46.265699Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(45)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265707Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265715Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R67    
2023-08-04T09:30:46.265723Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(47)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265731Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265739Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R68    
2023-08-04T09:30:46.265747Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(29)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265755Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265763Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R69    
2023-08-04T09:30:46.265783Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(38)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265792Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265799Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R70    
2023-08-04T09:30:46.265808Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(30)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265816Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265823Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R71    
2023-08-04T09:30:46.265832Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(33)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265840Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265847Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R72    
2023-08-04T09:30:46.265864Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(43)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265873Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265881Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R73    
2023-08-04T09:30:46.265889Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(26)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265897Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265905Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R74    
2023-08-04T09:30:46.265913Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(40)) = SourceRootId(7) (Durability(2))    
2023-08-04T09:30:46.265922Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265930Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R75    
2023-08-04T09:30:46.265938Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(7)) = SourceRoot { file_set: {FileId(39): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/uri.gleam"), FileId(28): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/io.gleam"), FileId(34): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/regex.gleam"), FileId(42): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/iterator.gleam"), FileId(37): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/bool.gleam"), FileId(44): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/pair.gleam"), FileId(41): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/set.gleam"), FileId(27): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/list.gleam"), FileId(36): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/function.gleam"), FileId(46): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/order.gleam"), FileId(32): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/string.gleam"), FileId(31): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/bit_builder.gleam"), FileId(35): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/string_builder.gleam"), FileId(45): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/result.gleam"), FileId(47): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/dynamic.gleam"), FileId(29): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/int.gleam"), FileId(38): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/map.gleam"), FileId(30): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/queue.gleam"), FileId(33): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/base.gleam"), FileId(43): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/option.gleam"), FileId(26): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/bit_string.gleam"), FileId(40): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib/src/gleam/float.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_stdlib", is_library: true } (Durability(2))    
2023-08-04T09:30:46.265978Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.265986Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R76    
2023-08-04T09:30:46.265998Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(6)) = SourceRootId(8) (Durability(2))    
2023-08-04T09:30:46.266006Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266014Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R77    
2023-08-04T09:30:46.266023Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(8)) = SourceRoot { file_set: {FileId(6): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_bitwise/src/gleam/bitwise.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_bitwise", is_library: true } (Durability(2))    
2023-08-04T09:30:46.266033Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266041Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R78    
2023-08-04T09:30:46.266049Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(70)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266058Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266065Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R79    
2023-08-04T09:30:46.266074Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(74)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266082Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266091Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R80    
2023-08-04T09:30:46.266099Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(75)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266118Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266126Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R81    
2023-08-04T09:30:46.266135Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(69)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266143Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266151Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R82    
2023-08-04T09:30:46.266159Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(71)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266168Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266175Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R83    
2023-08-04T09:30:46.266184Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(72)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266192Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266200Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R84    
2023-08-04T09:30:46.266209Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(73)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266217Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266225Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R85    
2023-08-04T09:30:46.266234Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(68)) = SourceRootId(9) (Durability(2))    
2023-08-04T09:30:46.266242Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266250Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R86    
2023-08-04T09:30:46.266259Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(9)) = SourceRoot { file_set: {FileId(70): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai/experimental/web_components.gleam"), FileId(74): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai/html/attrs.gleam"), FileId(75): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai/html.gleam"), FileId(69): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai/experimental/on.gleam"), FileId(71): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai/experimental/head.gleam"), FileId(72): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai/internal/document.gleam"), FileId(73): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai/internal/render.gleam"), FileId(68): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai/src/nakai.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/nakai", is_library: true } (Durability(2))    
2023-08-04T09:30:46.266277Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266285Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R87    
2023-08-04T09:30:46.266306Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(50)) = SourceRootId(10) (Durability(2))    
2023-08-04T09:30:46.266315Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266322Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R88    
2023-08-04T09:30:46.266331Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(10)) = SourceRoot { file_set: {FileId(50): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gliew/src/gliew.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gliew", is_library: true } (Durability(2))    
2023-08-04T09:30:46.266342Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266349Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R89    
2023-08-04T09:30:46.266358Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(12)) = SourceRootId(11) (Durability(2))    
2023-08-04T09:30:46.266367Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266375Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R90    
2023-08-04T09:30:46.266384Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(8)) = SourceRootId(11) (Durability(2))    
2023-08-04T09:30:46.266392Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266400Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R91    
2023-08-04T09:30:46.266409Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(11)) = SourceRootId(11) (Durability(2))    
2023-08-04T09:30:46.266417Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266425Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R92    
2023-08-04T09:30:46.266434Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(13)) = SourceRootId(11) (Durability(2))    
2023-08-04T09:30:46.266442Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266450Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R93    
2023-08-04T09:30:46.266458Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(10)) = SourceRootId(11) (Durability(2))    
2023-08-04T09:30:46.266467Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266475Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R94    
2023-08-04T09:30:46.266484Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileSourceRootQuery(FileId(9)) = SourceRootId(11) (Durability(2))    
2023-08-04T09:30:46.266492Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266500Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R95    
2023-08-04T09:30:46.266509Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: SourceRootQuery(SourceRootId(11)) = SourceRoot { file_set: {FileId(12): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang/src/gleam/erlang/process.gleam"), FileId(8): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang/src/gleam/erlang.gleam"), FileId(11): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang/src/gleam/erlang/os.gleam"), FileId(13): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang/src/gleam/erlang/charlist.gleam"), FileId(10): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang/src/gleam/erlang/atom.gleam"), FileId(9): Path("/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang/src/gleam/erlang/file.gleam")}, root_path: "/Users/maurobalbi/Documents/repos/try_gleam/build/packages/gleam_erlang", is_library: true } (Durability(2))    
2023-08-04T09:30:46.266688Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266698Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R96    
2023-08-04T09:30:46.266710Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: ModuleMapQuery(()) = ModuleMap { module_names: {FileId(40): "gleam/float", FileId(24): "gleam/otp/supervisor", FileId(75): "nakai/html", FileId(47): "gleam/dynamic", FileId(72): "nakai/internal/document", FileId(53): "glisten/handler", FileId(36): "gleam/function", FileId(66): "mist/internal/logger", FileId(16): "gleam/http/request", FileId(13): "gleam/erlang/charlist", FileId(49): "gleeunit", FileId(31): "gleam/bit_builder", FileId(52): "glisten/ssl", FileId(70): "nakai/experimental/web_components", FileId(21): "gleam/otp/task", FileId(17): "gleam/http/cookie", FileId(2): "try_gleam_test", FileId(23): "gleam/otp/node", FileId(20): "gleam/otp/intensity_tracker", FileId(7): "gleam/crypto", FileId(68): "nakai", FileId(69): "nakai/experimental/on", FileId(46): "gleam/order", FileId(58): "glisten/socket/options", FileId(18): "gleam/http/service", FileId(5): "blabla2", FileId(51): "glisten", FileId(50): "gliew", FileId(37): "gleam/bool", FileId(29): "gleam/int", FileId(42): "gleam/iterator", FileId(15): "gleam/http/response", FileId(1): "", FileId(6): "gleam/bitwise", FileId(44): "gleam/pair", FileId(30): "gleam/queue", FileId(48): "gleeunit/should", FileId(39): "gleam/uri", FileId(60): "mist", FileId(8): "gleam/erlang", FileId(26): "gleam/bit_string", FileId(27): "gleam/list", FileId(38): "gleam/map", FileId(57): "glisten/acceptor", FileId(32): "gleam/string", FileId(25): "gleam/otp/port", FileId(64): "mist/internal/handler", FileId(67): "mist/internal/encoder", FileId(71): "nakai/experimental/head", FileId(43): "gleam/option", FileId(22): "gleam/otp/actor", FileId(9): "gleam/erlang/file", FileId(12): "gleam/erlang/process", FileId(35): "gleam/string_builder", FileId(56): "glisten/logger", FileId(73): "nakai/internal/render", FileId(33): "gleam/base", FileId(11): "gleam/erlang/os", FileId(10): "gleam/erlang/atom", FileId(65): "mist/internal/websocket", FileId(3): "try_gleam", FileId(28): "gleam/io", FileId(4): "t", FileId(63): "mist/internal/file", FileId(45): "gleam/result", FileId(54): "glisten/socket", FileId(34): "gleam/regex", FileId(41): "gleam/set", FileId(55): "glisten/tcp", FileId(62): "mist/internal/http", FileId(14): "gleam/http", FileId(0): "test", FileId(19): "gleam/otp/system", FileId(59): "glisten/socket/transport", FileId(74): "nakai/html/attrs", FileId(61): "mist/websocket"}, files: {"gleeunit/should": FileId(48), "nakai/experimental/head": FileId(71), "gleam/http/service": FileId(18), "gleam/float": FileId(40), "gleam/otp/port": FileId(25), "glisten/acceptor": FileId(57), "glisten/handler": FileId(53), "gleam/iterator": FileId(42), "nakai/experimental/web_components": FileId(70), "gleam/uri": FileId(39), "gleam/result": FileId(45), "mist/internal/logger": FileId(66), "gleeunit": FileId(49), "gleam/http/cookie": FileId(17), "nakai/html": FileId(75), "gleam/string": FileId(32), "glisten/socket/options": FileId(58), "glisten/socket/transport": FileId(59), "mist/internal/encoder": FileId(67), "gleam/otp/system": FileId(19), "gleam/crypto": FileId(7), "gleam/http": FileId(14), "gleam/otp/supervisor": FileId(24), "gleam/regex": FileId(34), "mist/internal/file": FileId(63), "gleam/otp/actor": FileId(22), "gleam/erlang/file": FileId(9), "try_gleam_test": FileId(2), "gleam/io": FileId(28), "t": FileId(4), "glisten/socket": FileId(54), "gleam/bitwise": FileId(6), "gleam/dynamic": FileId(47), "gleam/string_builder": FileId(35), "nakai": FileId(68), "try_gleam": FileId(3), "mist/internal/handler": FileId(64), "mist": FileId(60), "gleam/erlang/process": FileId(12), "gleam/erlang/os": FileId(11), "gleam/list": FileId(27), "gleam/order": FileId(46), "gleam/otp/intensity_tracker": FileId(20), "": FileId(1), "gleam/http/request": FileId(16), "gleam/bit_string": FileId(26), "gleam/otp/task": FileId(21), "gleam/set": FileId(41), "gleam/erlang/atom": FileId(10), "mist/internal/websocket": FileId(65), "nakai/internal/render": FileId(73), "gleam/map": FileId(38), "glisten": FileId(51), "glisten/tcp": FileId(55), "nakai/experimental/on": FileId(69), "gleam/http/response": FileId(15), "gleam/bool": FileId(37), "gleam/function": FileId(36), "gleam/option": FileId(43), "mist/websocket": FileId(61), "gleam/base": FileId(33), "test": FileId(0), "gleam/int": FileId(29), "mist/internal/http": FileId(62), "nakai/html/attrs": FileId(74), "glisten/logger": FileId(56), "gleam/erlang/charlist": FileId(13), "gleam/pair": FileId(44), "gliew": FileId(50), "gleam/queue": FileId(30), "gleam/bit_builder": FileId(31), "gleam/erlang": FileId(8), "gleam/otp/node": FileId(23), "blabla2": FileId(5), "glisten/ssl": FileId(52), "nakai/internal/document": FileId(72)} } (Durability(2))    
2023-08-04T09:30:46.266790Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266799Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R97    
2023-08-04T09:30:46.266813Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(2)) = "import gleeunit\nimport gleeunit/should\nimport gleam\n\npub const ab: #(Int,Int) = #(1, 2)\n\n\npub fn main() {\n  gleeunit.main()\n}\n\n// gleeunit test functions end in `_test`\npub fn hello_world_test() {\n  1\n  |> should.equal(1)\n}\n" (Durability(0))    
2023-08-04T09:30:46.266825Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266833Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R98    
2023-08-04T09:30:46.266844Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(3)) = "import gleam/int\nimport gleam/io.{print}\nimport test\n\npub fn main(a: String) {\n  a\n  print(\"123\")\n}\n\nif erlang {\n  const b = 2\n}\n\nif javascript {\n  const b = 15\n}\n\n// type Cat {\n//   Cat(name: fn(Int) -> Int)\n// }\n\n// fn bla(c a: String, b d: Int) -> Int {\n//   a\n//   main()\n//   c\n// }\n\n// pub fn test() {\n//   let d = fn(a, b) -> Int { a + b }(b, b)\n//   let c = #(1, d)\n//   let assert #(1, b) = c\n//   let q = Cat(fn(a) { a }).name\n\n//   let f = bla(b, a: int.int_to_string(1))\n\n//   print(\"1\")\n//   \"123\" <> \"123\"\n// }\n" (Durability(0))    
2023-08-04T09:30:46.266860Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266868Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R99    
2023-08-04T09:30:46.266879Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(4)) = "" (Durability(0))    
2023-08-04T09:30:46.266898Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266906Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R100    
2023-08-04T09:30:46.266915Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(0)) = "import blabla2.{main, B, Bla}\nimport gliew.{worker_loop}\nfn main() {\n  \n}\nif erlang {\n  fn bla(b) {\n    let b = b\n\n    b\n  }\n}\n\n\nif javascript {\n  fn bla(aa) {\n    snake()\n    let b = aa\n    let bbb = InvalidBase\n    b\n  }\n}\n\nfn snake() {\n  rat(1)\n}\n\nfn rat(a) {\n  snake()\n}\n\nconst asdfasdfasdf = 1\n\n// type Bla {\n//   Bla(name: Int)\n// }\n\nfn bla2(bbb) {\n  let asdf = Bla(name: 1)\n  asdf.name\n  bbb\n  // use a <- bla\n  a\n  // bla()\n  // snake()\n  // dodo()\n  // main\n  // worker_loop\n  // b\n  // Bla(a, 2)\n  // bbb\n}\n\nfn dodo(a) {\n  case a {\n    #(a,b) -> {\n      b\n    }\n  }\n  b\n  a +. 1.1\n  bla()\n  let a = 1\n  a\n}\n" (Durability(0))    
2023-08-04T09:30:46.266933Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266941Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R101    
2023-08-04T09:30:46.266951Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(5)) = "import gleam/int.{InvalidBase}\nfn name() { bla }\nif erlang {\n  fn bla(b) {\n    let b = b\n    b\n  }\n}\n\nif javascript {\n  fn bla(b) {\n    let b = a\n    let b = InvalidBase\n    b\n  }\n}\ntype Mogie { Mogie(name: Int) } \n\nfn wops() { case Mogie { a -> a} }\n\npub fn main(a, b) {\n  let bla = name\n  b\n}\n\nconst bla2 = 1\n\npub type B(a,b) {\n  Bla(name: a, Int)\n}\n\n" (Durability(0))    
2023-08-04T09:30:46.266965Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.266973Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R102    
2023-08-04T09:30:46.266982Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(6)) = "//// A set of functions for bitwise operations on integers.\n\n/// Calculates the bitwise AND of its arguments.\npub fn and(x: Int, y: Int) -> Int {\n  do_and(x, y)\n}\n\nif erlang {\n  external fn do_and(Int, Int) -> Int =\n    \"erlang\" \"band\"\n}\n\nif javascript {\n  external fn do_and(Int, Int) -> Int =\n    \"../gleam_bitwise.mjs\" \"and\"\n}\n\n/// Calculates the bitwise NOT of its argument.\npub fn not(x: Int) -> Int {\n  do_not(x)\n}\n\nif erlang {\n  external fn do_not(Int) -> Int =\n    \"erlang\" \"bnot\"\n}\n\nif javascript {\n  external fn do_not(Int) -> Int =\n    \"../gleam_bitwise.mjs\" \"not\"\n}\n\n/// Calculates the bitwise OR of its arguments.\npub fn or(x: Int, y: Int) -> Int {\n  do_or(x, y)\n}\n\nif erlang {\n  external fn do_or(Int, Int) -> Int =\n    \"erlang\" \"bor\"\n}\n\nif javascript {\n  external fn do_or(Int, Int) -> Int =\n    \"../gleam_bitwise.mjs\" \"or\"\n}\n\n/// Calculates the bitwise XOR of its arguments.\npub fn exclusive_or(x: Int, y: Int) -> Int {\n  do_exclusive_or(x, y)\n}\n\nif erlang {\n  external fn do_exclusive_or(Int, Int) -> Int =\n    \"erlang\" \"bxor\"\n}\n\nif javascript {\n  external fn do_exclusive_or(Int, Int) -> Int =\n    \"../gleam_bitwise.mjs\" \"exclusive_or\"\n}\n\n/// Calculates the result of an arithmetic left bitshift.\npub fn shift_left(x: Int, y: Int) -> Int {\n  do_shift_left(x, y)\n}\n\nif erlang {\n  external fn do_shift_left(Int, Int) -> Int =\n    \"erlang\" \"bsl\"\n}\n\nif javascript {\n  external fn do_shift_left(Int, Int) -> Int =\n    \"../gleam_bitwise.mjs\" \"shift_left\"\n}\n\n/// Calculates the result of an arithmetic right bitshift.\npub fn shift_right(x: Int, y: Int) -> Int {\n  do_shift_right(x, y)\n}\n\nif erlang {\n  external fn do_shift_right(Int, Int) -> Int =\n    \"erlang\" \"bsr\"\n}\n\nif javascript {\n  external fn do_shift_right(Int, Int) -> Int =\n    \"../gleam_bitwise.mjs\" \"shift_right\"\n}\n" (Durability(0))    
2023-08-04T09:30:46.267021Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267030Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R103    
2023-08-04T09:30:46.267039Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(7)) = "//// Set of cryptographic functions.\n\nimport gleam/bit_string\nimport gleam/bitwise\nimport gleam/string\nimport gleam/base\nimport gleam/result\n\n/// Generates N bytes randomly uniform 0..255, and returns the result in a binary.\n///\n/// Uses a cryptographically secure prng seeded and periodically mixed with\n/// operating system provided entropy.\n/// By default this is the RAND_bytes method from OpenSSL.\n///\n/// https://erlang.org/doc/man/crypto.html#strong_rand_bytes-1\npub external fn strong_random_bytes(Int) -> BitString =\n  \"crypto\" \"strong_rand_bytes\"\n\npub type HashAlgorithm {\n  Sha224\n  Sha256\n  Sha384\n  Sha512\n}\n\n/// Computes a digest of the input bit string.\npub external fn hash(HashAlgorithm, BitString) -> BitString =\n  \"crypto\" \"hash\"\n\ntype Hmac {\n  Hmac\n}\n\nexternal fn erl_hmac(Hmac, HashAlgorithm, BitString, BitString) -> BitString =\n  \"crypto\" \"mac\"\n\n/// Calculates the HMAC (hash-based message authentication code) for a bit\n/// string.\n///\n/// Based on the Erlang [`crypto:mac`](https://www.erlang.org/doc/man/crypto.html#mac-4)\n/// function.\n///\npub fn hmac(data: BitString, algorithm: HashAlgorithm, key: BitString) {\n  erl_hmac(Hmac, algorithm, key, data)\n}\n\nfn do_secure_compare(\n  left: BitString,\n  right: BitString,\n  accumulator: Int,\n) -> Bool {\n  case left, right {\n    <<x, left:bit_string>>, <<y, right:bit_string>> -> {\n      let accumulator = bitwise.or(accumulator, bitwise.exclusive_or(x, y))\n      do_secure_compare(left, right, accumulator)\n    }\n    <<>>, <<>> -> accumulator == 0\n  }\n}\n\n/// Compares the two binaries in constant-time to avoid timing attacks.\n///\n/// For more details see: http://codahale.com/a-lesson-in-timing-attacks/\n///\npub fn secure_compare(left: BitString, right: BitString) -> Bool {\n  case bit_string.byte_size(left) == bit_string.byte_size(right) {\n    True -> do_secure_compare(left, right, 0)\n    False -> False\n  }\n}\n\n// Based off of https://github.com/elixir-plug/plug_crypto/blob/v1.2.1/lib/plug/crypto/message_verifier.ex#L1\n//\n/// Sign a message which can later be verified using the `verify_signed_message`\n/// function to detect if the message has been tampered with.\n///\n/// A web application could use this verifier to sign HTTP cookies. The data can\n/// be read by the user, but cannot be tampered with.\n///\npub fn sign_message(\n  message: BitString,\n  secret: BitString,\n  digest_type: HashAlgorithm,\n) -> String {\n  let input = signing_input(digest_type, message)\n  let signature = hmac(<<input:utf8>>, digest_type, secret)\n\n  string.concat([input, \".\", base.url_encode64(signature, False)])\n}\n\nfn signing_input(digest_type: HashAlgorithm, message: BitString) -> String {\n  let protected = case digest_type {\n    Sha224 -> \"HS224\"\n    Sha256 -> \"HS256\"\n    Sha384 -> \"HS384\"\n    Sha512 -> \"HS512\"\n  }\n  string.concat([\n    base.url_encode64(<<protected:utf8>>, False),\n    \".\",\n    base.url_encode64(message, False),\n  ])\n}\n\n// Based off of https://github.com/elixir-plug/plug_crypto/blob/v1.2.1/lib/plug/crypto/message_verifier.ex#L1\n//\n/// Verify a message created by the `sign_message` function.\n///\npub fn verify_signed_message(\n  message: String,\n  secret: BitString,\n) -> Result(BitString, Nil) {\n  use #(protected, payload, signature) <- result.then(case\n    string.split(message, on: \".\")\n  {\n    [a, b, c] -> Ok(#(a, b, c))\n    _ -> Error(Nil)\n  })\n  let text = string.concat([protected, \".\", payload])\n  use payload <- result.then(base.url_decode64(payload))\n  use signature <- result.then(base.url_decode64(signature))\n  use protected <- result.then(base.url_decode64(protected))\n  use digest_type <- result.then(case protected {\n    <<\"HS224\":utf8>> -> Ok(Sha224)\n    <<\"HS256\":utf8>> -> Ok(Sha256)\n    <<\"HS384\":utf8>> -> Ok(Sha384)\n    <<\"HS512\":utf8>> -> Ok(Sha512)\n    _ -> Error(Nil)\n  })\n  let challenge = hmac(<<text:utf8>>, digest_type, secret)\n  case secure_compare(challenge, signature) {\n    True -> Ok(payload)\n    False -> Error(Nil)\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.267100Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267109Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R104    
2023-08-04T09:30:46.267119Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(8)) = "import gleam/dynamic.{Dynamic}\nimport gleam/list\nimport gleam/erlang/atom.{Atom}\nimport gleam/erlang/charlist.{Charlist}\n\nexternal fn erl_format(String, List(a)) -> Charlist =\n  \"io_lib\" \"format\"\n\n/// Return a string representation of any term\npub fn format(term: any) -> String {\n  charlist.to_string(erl_format(\"~p\", [term]))\n}\n\npub external fn term_to_binary(a) -> BitString =\n  \"erlang\" \"term_to_binary\"\n\ntype Safe {\n  Safe\n}\n\nexternal fn erl_binary_to_term(BitString, List(Safe)) -> Dynamic =\n  \"erlang\" \"binary_to_term\"\n\npub fn binary_to_term(binary: BitString) -> Result(Dynamic, Nil) {\n  case rescue(fn() { erl_binary_to_term(binary, [Safe]) }) {\n    Ok(term) -> Ok(term)\n    Error(_) -> Error(Nil)\n  }\n}\n\npub fn unsafe_binary_to_term(binary: BitString) -> Result(Dynamic, Nil) {\n  case rescue(fn() { erl_binary_to_term(binary, []) }) {\n    Ok(term) -> Ok(term)\n    Error(_) -> Error(Nil)\n  }\n}\n\n/// Error value returned by `get_line` function\n///\npub type GetLineError {\n  Eof\n  NoData\n}\n\n/// Reads a line from standard input with the given prompt.\n///\n/// # Example\n///\n///    > get_line(\"Language: \")\n///    // -> Language: <- gleam\n///    Ok(\"gleam\\n\")\n///\npub external fn get_line(prompt: String) -> Result(String, GetLineError) =\n  \"gleam_erlang_ffi\" \"get_line\"\n\npub type TimeUnit {\n  Second\n  Millisecond\n  Microsecond\n  Nanosecond\n}\n\n/// Returns the current OS system time.\n///\n/// <https://erlang.org/doc/apps/erts/time_correction.html#OS_System_Time>\npub external fn system_time(TimeUnit) -> Int =\n  \"os\" \"system_time\"\n\n/// Returns the current OS system time as a tuple of Ints\n///\n/// http://erlang.org/doc/man/os.html#timestamp-0\npub external fn erlang_timestamp() -> #(Int, Int, Int) =\n  \"os\" \"timestamp\"\n\n/// Gleam doesn't offer any way to raise exceptions, but they may still occur\n/// due to bugs when working with unsafe code, such as when calling Erlang\n/// function.\n///\n/// This function will catch any error thrown and convert it into a result\n/// rather than crashing the process.\n///\npub external fn rescue(fn() -> a) -> Result(a, Crash) =\n  \"gleam_erlang_ffi\" \"rescue\"\n\npub type Crash {\n  Exited(Dynamic)\n  Thrown(Dynamic)\n  Errored(Dynamic)\n}\n\nexternal fn get_start_arguments() -> List(Charlist) =\n  \"init\" \"get_plain_arguments\"\n\n/// Get the arguments given to the program when it was started.\n///\n/// This is sometimes called `argv` in other languages.\npub fn start_arguments() -> List(String) {\n  get_start_arguments()\n  |> list.map(charlist.to_string)\n}\n\n/// Starts an OTP application's process tree in the background, as well as\n/// the trees of any applications that the given application depends upon. An\n/// OTP application typically maps onto a Gleam or Hex package.\n///\n/// Returns a list of the applications that were started. Calling this function\n/// for application that have already been started is a no-op so you do not need\n/// to check the application state beforehand.\n///\n/// In Gleam we prefer to not use these implicit background process trees, but\n/// you will likely still need to start the trees of OTP applications written in\n/// other BEAM languages such as Erlang or Elixir, including those included by\n/// default with Erlang/OTP.\n///\n/// For more information see the OTP documentation.\n/// - <https://www.erlang.org/doc/man/application.html#ensure_all_started-1>\n/// - <https://www.erlang.org/doc/man/application.html#start-1>\n///\npub external fn ensure_all_started(\n  application: Atom,\n) -> Result(List(Atom), EnsureAllStartedError) =\n  \"gleam_erlang_ffi\" \"ensure_all_started\"\n\npub type EnsureAllStartedError {\n  UnknownApplication(name: Atom)\n  ApplicationFailedToStart(name: Atom, reason: Dynamic)\n}\n\n/// A unique reference value.\n///\n/// It holds no particular meaning or value, but unique values are often useful\n/// in programs are used heavily within both Gleam and Erlang's OTP frameworks.\n///\n/// More can be read about refernces in the [Erlang documentation][1].\n///\n/// [1]: https://www.erlang.org/doc/efficiency_guide/advanced.html#unique_references\n///\npub external type Reference\n\n/// Create a new unique reference.\n///\npub external fn make_reference() -> Reference =\n  \"erlang\" \"make_ref\"\n" (Durability(0))    
2023-08-04T09:30:46.267181Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267190Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R105    
2023-08-04T09:30:46.267198Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(9)) = "//// Working with files on the filesystem.\n////\n//// The functions included in this module are for high-level concepts such as\n//// reading and writing.\n\nimport gleam/bit_string\nimport gleam/result\n\n/// Reason represents all of the reasons that Erlang surfaces of why a file\n/// system operation could fail. Most of these reasons are POSIX errors, which\n/// come from the operating system and start with `E`. Others have been added to\n/// represent other issues that may arise.\npub type Reason {\n  /// Permission denied.\n  Eacces\n  /// Resource temporarily unavailable.\n  Eagain\n  /// Bad file number\n  Ebadf\n  /// Bad message.\n  Ebadmsg\n  /// File busy.\n  Ebusy\n  /// Resource deadlock avoided.\n  Edeadlk\n  /// On most architectures, same as `Edeadlk`. On some architectures, it\n  /// means \"File locking deadlock error.\"\n  Edeadlock\n  /// Disk quota exceeded.\n  Edquot\n  /// File already exists.\n  Eexist\n  /// Bad address in system call argument.\n  Efault\n  /// File too large.\n  Efbig\n  /// Inappropriate file type or format. Usually caused by trying to set the\n  /// \"sticky bit\" on a regular file (not a directory).\n  Eftype\n  /// Interrupted system call.\n  Eintr\n  /// Invalid argument.\n  Einval\n  /// I/O error.\n  Eio\n  /// Illegal operation on a directory.\n  Eisdir\n  /// Too many levels of symbolic links.\n  Eloop\n  /// Too many open files.\n  Emfile\n  /// Too many links.\n  Emlink\n  /// Multihop attempted.\n  Emultihop\n  /// Filename too long\n  Enametoolong\n  /// File table overflow\n  Enfile\n  /// No buffer space available.\n  Enobufs\n  /// No such device.\n  Enodev\n  /// No locks available.\n  Enolck\n  /// Link has been severed.\n  Enolink\n  /// No such file or directory.\n  Enoent\n  /// Not enough memory.\n  Enomem\n  /// No space left on device.\n  Enospc\n  /// No STREAM resources.\n  Enosr\n  /// Not a STREAM.\n  Enostr\n  /// Function not implemented.\n  Enosys\n  /// Block device required.\n  Enotblk\n  /// Not a directory.\n  Enotdir\n  /// Operation not supported.\n  Enotsup\n  /// No such device or address.\n  Enxio\n  /// Operation not supported on socket.\n  Eopnotsupp\n  /// Value too large to be stored in data type.\n  Eoverflow\n  /// Not owner.\n  Eperm\n  /// Broken pipe.\n  Epipe\n  /// Result too large.\n  Erange\n  /// Read-only file system.\n  Erofs\n  /// Invalid seek.\n  Espipe\n  /// No such process.\n  Esrch\n  /// Stale remote file handle.\n  Estale\n  /// Text file busy.\n  Etxtbsy\n  /// Cross-domain link.\n  Exdev\n  /// File was requested to be read as UTF-8, but is not UTF-8 encoded.\n  NotUtf8\n}\n\n/// The type of file found by `file_info` or `link_info`.\n///\npub type FileType {\n  Device\n  Directory\n  Other\n  Regular\n  Symlink\n}\n\n/// The read/write permissions a user can have for a file.\n///\npub type Access {\n  NoAccess\n  Read\n  ReadWrite\n  Write\n}\n\n/// Meta information for a file.\n///\n/// Timestamps are in seconds before or after the Unix time epoch,\n/// `1970-01-01 00:00:00 UTC`.\n///\npub type FileInfo {\n  FileInfo(\n    /// File size in bytes.\n    ///\n    size: Int,\n    /// `Regular`, `Directory`, `Symlink`, `Device`, or `Other`.\n    ///\n    file_type: FileType,\n    /// `ReadWrite`, `Read`, `Write`, or `NoAccess`.\n    ///\n    access: Access,\n    /// Timestamp of most recent access.\n    ///\n    atime: Int,\n    /// Timestamp of most recent modification.\n    ///\n    mtime: Int,\n    /// Timestamp of most recent change (or file creation, depending on\n    /// operating system).\n    ///\n    ctime: Int,\n    /// File permissions encoded as a sum of bit values, including but not\n    /// limited to:\n    ///\n    /// Owner read, write, execute.\n    ///\n    /// `0o400`, `0o200`, `0o100`\n    ///\n    /// Group read, write, execute.\n    ///\n    /// `0o40`, `0o20`, `0o10`\n    ///\n    /// Other read, write, execute.\n    ///\n    /// `0o4`, `0o2`, `0o1`\n    ///\n    /// Set user ID, group ID on execution.\n    ///\n    /// `0x800`, `0x400`\n    ///\n    mode: Int,\n    /// Total links to a file (always `1` for file systems without links).\n    ///\n    links: Int,\n    /// The file system where a file is located (`0` for drive `A:` on Windows,\n    /// `1` for `B:`, etc.).\n    ///\n    major_device: Int,\n    /// Character device (or `0` on non-Unix systems).\n    ///\n    minor_device: Int,\n    /// The `inode` number for a file (always `0` on non-Unix file systems).\n    ///\n    inode: Int,\n    /// The owner of a file (always `0` on non-Unix file systems).\n    ///\n    user_id: Int,\n    /// The group id of a file (always `0` on non-Unix file systems).\n    ///\n    group_id: Int,\n  )\n}\n\n/// Results in `FileInfo` about the given `path` on success, otherwise a\n/// `Reason` for failure.\n///\n/// When `path` refers to a symlink, the result pertains to the link's target.\n/// To get `FileInfo` about a symlink itself, use `link_info`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > file_info(\"gleam.toml\")\n/// Ok(FileInfo(\n///   size: 430,\n///   file_type: Regular,\n///   access: ReadWrite,\n///   atime: 1680580321,\n///   mtime: 1680580272,\n///   ctime: 1680580272,\n///   mode: 33188,\n///   links: 1,\n///   major_device: 64,\n///   minor_device: 0,\n///   inode: 469028,\n///   user_id: 1000,\n///   group_id: 1000,\n/// ))\n///\n/// > file_info(\"/root\")\n/// Ok(FileInfo(\n///   size: 16,\n///   file_type: Directory,\n///   access: Read,\n///   atime: 1677789967,\n///   mtime: 1664561240,\n///   ctime: 1664561240,\n///   mode: 16877,\n///   links: 11,\n///   major_device: 54,\n///   minor_device: 0,\n///   inode: 34,\n///   user_id: 0,\n///   group_id: 0,\n/// ))\n///\n/// > file_info(\"./build/dev/erlang/rad/priv\")\n/// Ok(FileInfo(\n///   size: 140,\n///   file_type: Directory,\n///   access: ReadWrite,\n///   atime: 1680580321,\n///   mtime: 1680580272,\n///   ctime: 1680580272,\n///   mode: 33188,\n///   links: 1,\n///   major_device: 64,\n///   minor_device: 0,\n///   inode: 469028,\n///   user_id: 1000,\n///   group_id: 1000,\n/// ))\n///\n/// > file_info(\"/does_not_exist\")\n/// Error(Enoent)\n///\n/// > file_info(\"/root/.local/maybe_exists\")\n/// Error(Eacces)\n/// ```\n///\npub external fn file_info(String) -> Result(FileInfo, Reason) =\n  \"gleam_erlang_ffi\" \"file_info\"\n\n/// Results in `FileInfo` about the given `path` on success, otherwise a\n/// `Reason` for failure.\n///\n/// When `path` refers to a symlink, the result pertains to the link itself.\n/// To get `FileInfo` about a symlink's target, use `file_info`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > link_info(\"gleam.toml\")\n/// Ok(FileInfo(\n///   size: 430,\n///   file_type: Regular,\n///   access: ReadWrite,\n///   atime: 1680580321,\n///   mtime: 1680580272,\n///   ctime: 1680580272,\n///   mode: 33188,\n///   links: 1,\n///   major_device: 64,\n///   minor_device: 0,\n///   inode: 469028,\n///   user_id: 1000,\n///   group_id: 1000,\n/// ))\n///\n/// > link_info(\"/root\")\n/// Ok(FileInfo(\n///   size: 16,\n///   file_type: Directory,\n///   access: Read,\n///   atime: 1677789967,\n///   mtime: 1664561240,\n///   ctime: 1664561240,\n///   mode: 16877,\n///   links: 11,\n///   major_device: 54,\n///   minor_device: 0,\n///   inode: 34,\n///   user_id: 0,\n///   group_id: 0,\n/// ))\n///\n/// > link_info(\"./build/dev/erlang/rad/priv\")\n/// Ok(FileInfo(\n///   size: 41,\n///   file_type: Symlink,\n///   access: ReadWrite,\n///   atime: 1680581150,\n///   mtime: 1680581150,\n///   ctime: 1680581150,\n///   mode: 41471,\n///   links: 1,\n///   major_device: 64,\n///   minor_device: 0,\n///   inode: 471587,\n///   user_id: 1000,\n///   group_id: 1000,\n/// ))\n///\n/// > link_info(\"/does_not_exist\")\n/// Error(Enoent)\n///\n/// > link_info(\"/root/.local/maybe_exists\")\n/// Error(Eacces)\n/// ```\n///\npub external fn link_info(String) -> Result(FileInfo, Reason) =\n  \"gleam_erlang_ffi\" \"link_info\"\n\n/// Results in a `Bool` on success that indicates whether the given `path` has\n/// a `Directory` `FileType`, otherwise a `Reason` for failure.\n///\n/// When `path` refers to a symlink, the result pertains to the link's target.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_directory(\"/tmp\")\n/// Ok(True)\n///\n/// > is_directory(\"resume.pdf\")\n/// Ok(False)\n///\n/// > is_directory(\"/does_not_exist\")\n/// Error(Enoent)\n/// ```\n///\npub fn is_directory(path: String) -> Result(Bool, Reason) {\n  use FileInfo(file_type: file_type, ..) <- result.map(over: file_info(path))\n  file_type == Directory\n}\n\n/// Results in a `Bool` on success that indicates whether the given `path` has\n/// a `Regular` `FileType`, otherwise a `Reason` for failure.\n///\n/// When `path` refers to a symlink, the result pertains to the link's target.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_regular(\"resume.pdf\")\n/// Ok(True)\n///\n/// > is_regular(\"/tmp\")\n/// Ok(False)\n///\n/// > is_regular(\"/does_not_exist.txt\")\n/// Error(Enoent)\n/// ```\n///\npub fn is_regular(path: String) -> Result(Bool, Reason) {\n  use FileInfo(file_type: file_type, ..) <- result.map(over: file_info(path))\n  file_type == Regular\n}\n\n/// Results in a `Bool` on success that indicates whether the given `path`\n/// exists, otherwise a `Reason` for failure.\n///\n/// When `path` refers to a symlink, the result pertains to the link's target.\n/// To find whether a symlink itself exists, use `link_exists`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > file_exists(\"resume.pdf\")\n/// Ok(True)\n///\n/// > file_exists(\"/tmp\")\n/// Ok(True)\n///\n/// > file_exists(\"/does_not_exist\")\n/// Ok(False)\n///\n/// > file_exists(\"/root/.local/maybe_exists\")\n/// Error(Eacces)\n/// ```\n///\npub fn file_exists(path: String) -> Result(Bool, Reason) {\n  let result =\n    path\n    |> file_info\n    |> result.replace(True)\n  case result {\n    Error(Enoent) -> Ok(False)\n    _ -> result\n  }\n}\n\n/// Results in a `Bool` on success that indicates whether the given `path`\n/// exists, otherwise a `Reason` for failure.\n///\n/// When `path` refers to a symlink, the result pertains to the link itself.\n/// To find whether a symlink's target exists, use `file_exists`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > link_exists(\"resume.pdf\")\n/// Ok(True)\n///\n/// > link_exists(\"/tmp\")\n/// Ok(True)\n///\n/// > link_exists(\"/does_not_exist\")\n/// Ok(False)\n///\n/// > link_exists(\"/root/.local/maybe_exists\")\n/// Error(Eacces)\n/// ```\n///\npub fn link_exists(path: String) -> Result(Bool, Reason) {\n  let result =\n    path\n    |> link_info\n    |> result.replace(True)\n  case result {\n    Error(Enoent) -> Ok(False)\n    _ -> result\n  }\n}\n\n/// Tries to create a directory. Missing parent directories are not created.\n///\n/// Returns a Result of nil if the directory is created or Reason if the\n/// operation failed.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > make_directory(\"/tmp/foo\")\n/// Ok(Nil)\n///\n/// > make_directory(\"relative_directory\")\n/// Ok(Nil)\n///\n/// > make_directory(\"/tmp/missing_intermediate_directory/foo\")\n/// Error(Enoent)\n/// ```\n///\npub external fn make_directory(String) -> Result(Nil, Reason) =\n  \"gleam_erlang_ffi\" \"make_directory\"\n\n/// Lists all files in a directory, except files with\n/// [raw filenames](https://www.erlang.org/doc/apps/stdlib/unicode_usage.html#notes-about-raw-filenames).\n///\n/// Returns a Result containing the list of filenames in the directory, or Reason\n/// if the operation failed.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > list_directory(\"/tmp\")\n/// Ok([\"FB01293B-8597-4359-80D5-130140A0C0DE\",\"AlTest2.out\"])\n///\n/// > list_directory(\"resume.docx\")\n/// Error(Enotdir)\n/// ```\n///\npub external fn list_directory(String) -> Result(List(String), Reason) =\n  \"gleam_erlang_ffi\" \"list_directory\"\n\n/// Deletes a directory.\n///\n/// The directory must be empty before it can be deleted. Returns a nil Success\n/// or Reason if the operation failed.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > delete_directory(\"foo\")\n/// Ok(Nil)\n///\n/// > delete_directory(\"does_not_exist/\")\n/// Error(Enoent)\n/// ```\n///\npub external fn delete_directory(String) -> Result(Nil, Reason) =\n  \"gleam_erlang_ffi\" \"delete_directory\"\n\n/// Deletes a file or directory recursively.\n///\n/// Returns a nil Success or Reason if the operation failed.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > recursive_delete(\"foo\")\n/// Ok(Nil)\n///\n/// > recursive_delete(\"/bar\")\n/// Ok(Nil)\n///\n/// > recursive_delete(\"does_not_exist/\")\n/// Error(Enoent)\n/// ```\n///\npub external fn recursive_delete(String) -> Result(Nil, Reason) =\n  \"gleam_erlang_ffi\" \"recursive_delete\"\n\n/// Read the contents of the given file as a String\n///\n/// Assumes the file is UTF-8 encoded. Returns a Result containing the file's\n/// contents as a String if the operation was successful, or Reason if the file\n/// operation failed. If the file is not UTF-8 encoded, the `NotUTF8` variant\n/// will be returned.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > read(\"example.txt\")\n/// Ok(\"Hello, World!\")\n///\n/// > read(from: \"example.txt\")\n/// Ok(\"Hello, World!\")\n///\n/// > read(\"does_not_exist.txt\")\n/// Error(Enoent)\n///\n/// > read(\"cat.gif\")\n/// Error(NotUTF8)\n/// ```\n///\npub fn read(from path: String) -> Result(String, Reason) {\n  path\n  |> do_read_bits()\n  |> result.then(fn(content) {\n    case bit_string.to_string(content) {\n      Ok(string) -> Ok(string)\n      Error(Nil) -> Error(NotUtf8)\n    }\n  })\n}\n\n/// Read the contents of the given file as a BitString\n///\n/// Returns a Result containing the file's contents as a BitString if the\n/// operation was successful, or Reason if the operation failed.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > read_bits(\"example.txt\")\n/// Ok(<<\"Hello, World!\">>)\n///\n/// > read_bits(from: \"cat.gif\")\n/// Ok(<<71,73,70,56,57,97,1,0,1,0,0,0,0,59>>)\n///\n/// > read_bits(\"does_not_exist.txt\")\n/// Error(Enoent)\n/// ```\n///\npub fn read_bits(from path: String) -> Result(BitString, Reason) {\n  do_read_bits(path)\n}\n\nexternal fn do_read_bits(path) -> Result(BitString, Reason) =\n  \"gleam_erlang_ffi\" \"read_file\"\n\n/// Write the given String contents to a file of the given name.\n///\n/// Returns a Result with Nil if the operation was successful or a Reason\n/// otherwise.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > write(\"Hello, World!\", \"file.txt\")\n/// Ok(Nil)\n///\n/// > write(to: \"file.txt\", contents: \"Hello, World!\")\n/// Ok(Nil)\n///\n/// > write(\"Hello, World!\", \"does_not_exist/file.txt\")\n/// Error(Enoent)\n/// ```\n///\npub fn write(contents contents: String, to path: String) -> Result(Nil, Reason) {\n  contents\n  |> bit_string.from_string\n  |> do_write_bits(path)\n}\n\n/// Write the given BitString contents to a file of the given name.\n///\n/// Returns a Result with Nil if the operation was successful or a Reason\n/// otherwise.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > write_bits(<<71,73,70,56,57,97,1,0,1,0,0,0,0,59>>, \"cat.gif\")\n/// Ok(Nil)\n///\n/// > write_bits(to: \"cat.gif\", contents: <<71,73,70,56,57,97,1,0,1,0,0,0,0,59>>)\n/// Ok(Nil)\n///\n/// > write_bits(<<71,73,70,56,57,97,1,0,1,0,0,0,0,59>>, \"does_not_exist/cat.gif\")\n/// Error(Enoent)\n/// ```\n///\npub fn write_bits(\n  contents contents: BitString,\n  to path: String,\n) -> Result(Nil, Reason) {\n  do_write_bits(contents, path)\n}\n\nexternal fn do_write_bits(BitString, String) -> Result(Nil, Reason) =\n  \"gleam_erlang_ffi\" \"write_file\"\n\n/// Append the given String contents to a file of the given name.\n///\n/// Returns a Result with Nil if the operation was successful or a Reason\n/// otherwise.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > append(\"Hello, World!\", \"file.txt\")\n/// Ok(Nil)\n///\n/// > append(to: \"file.txt\", contents: \"Hello, World!\")\n/// Ok(Nil)\n///\n/// > append(\"Hello, World!\", \"does_not_exist/file.txt\")\n/// Error(Enoent)\n/// ```\n///\npub fn append(contents contents: String, to path: String) -> Result(Nil, Reason) {\n  contents\n  |> bit_string.from_string\n  |> do_append_bits(path)\n}\n\n/// Append the given BitString contents to a file of the given name.\n///\n/// Returns a Result with Nil if the operation was successful or a Reason\n/// otherwise.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > append_bits(<<71,73,70,56,57,97,1,0,1,0,0,0,0,59>>, \"cat.gif\")\n/// Ok(Nil)\n///\n/// > append_bits(to: \"cat.gif\", contents: <<71,73,70,56,57,97,1,0,1,0,0,0,0,59>>)\n/// Ok(Nil)\n///\n/// > append_bits(<<71,73,70,56,57,97,1,0,1,0,0,0,0,59>>, \"does_not_exist/cat.gif\")\n/// Error(Enoent)\n/// ```\n///\npub fn append_bits(\n  contents contents: BitString,\n  to path: String,\n) -> Result(Nil, Reason) {\n  do_append_bits(contents, path)\n}\n\nexternal fn do_append_bits(\n  contents: BitString,\n  path: String,\n) -> Result(Nil, Reason) =\n  \"gleam_erlang_ffi\" \"append_file\"\n\n/// Delete the given file.\n///\n/// Returns a Result with Nil if the operation was successful or a Reason\n/// otherwise.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > delete(\"file.txt\")\n/// Ok(Nil)\n///\n/// > delete(\"does_not_exist.txt\")\n/// Error(Enoent)\n/// ```\n///\npub external fn delete(String) -> Result(Nil, Reason) =\n  \"gleam_erlang_ffi\" \"delete_file\"\n" (Durability(0))    
2023-08-04T09:30:46.267422Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267430Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R106    
2023-08-04T09:30:46.267439Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(10)) = "import gleam/dynamic.{DecodeErrors, Dynamic}\n\n/// Atom is a special string-like data-type that is most commonly used for\n/// interfacing with code written in other BEAM languages such as Erlang and\n/// Elixir. It is preferable to define your own custom types to use instead of\n/// atoms where possible.\n///\n/// Atoms are not used much in typical Gleam code!\n///\n/// ## Creating atoms\n///\n/// We can create atoms with the the [`create_from_string`](#create_from_string)\n/// function, though we must be careful when doing so as atoms are never\n/// garbage collected. If we create too many atoms (for example, if we convert\n/// user input into atoms) we may hit the max limit of atoms and cause the\n/// virtual machine to crash.\n///\npub external type Atom\n\n/// An error returned when no atom is found in the virtual machine's atom table\n/// for a given string when calling the [`from_string`](#from_string) function.\npub type FromStringError {\n  AtomNotLoaded\n}\n\n/// Finds an existing Atom for the given String.\n///\n/// If no atom is found in the virtual machine's atom table for the String then\n/// an error is returned.\n///\n/// ## Examples\n///\n///    > from_string(\"ok\")\n///    Ok(create_from_string(\"ok\"))\n///\n///    > from_string(\"some_new_atom\")\n///    Error(AtomNotLoaded)\n///\npub external fn from_string(String) -> Result(Atom, FromStringError) =\n  \"gleam_erlang_ffi\" \"atom_from_string\"\n\n/// Creates an atom from a string, inserting a new value into the virtual\n/// machine's atom table if an atom does not already exist for the given\n/// string.\n///\n/// We must be careful when using this function as there is a limit to the\n/// number of atom that can fit in the virtual machine's atom table. Never\n/// convert user input into atoms as filling the atom table will cause the\n/// virtual machine to crash!\n///\npub external fn create_from_string(String) -> Atom =\n  \"erlang\" \"binary_to_atom\"\n\n/// Retuns a `String` corresponding to the text representation of the given\n/// `Atom`.\n///\n/// ## Examples\n///\n///    > let ok_atom = create_from_string(\"ok\")\n///    > to_string(ok_atom)\n///    \"ok\"\n///\npub external fn to_string(Atom) -> String =\n  \"erlang\" \"atom_to_binary\"\n\n/// Checks to see whether a `Dynamic` value is an atom, and return the atom if\n/// it is.\n///\n/// ## Examples\n///\n///    > import gleam/dynamic\n///    > from_dynamic(dynamic.from(create_from_string(\"hello\")))\n///    Ok(create_from_string(\"hello\"))\n///\n///    > from_dynamic(dynamic.from(123))\n///    Error([DecodeError(expected: \"Atom\", found: \"Int\", path: [])])\n///\npub external fn from_dynamic(from: Dynamic) -> Result(Atom, DecodeErrors) =\n  \"gleam_erlang_ffi\" \"atom_from_dynamic\"\n" (Durability(0))    
2023-08-04T09:30:46.267488Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267496Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R107    
2023-08-04T09:30:46.267505Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(11)) = "//// Access to the shell's environment variables\n\nimport gleam/map.{Map}\n\n/// Returns the list of all available environment variables as a list of key,\n/// tuples.\n///\n/// ## Examples\n///\n///    > get_all_env()\n///    map.from_list([\n///      #(\"SHELL\", \"/bin/bash\"),\n///      #(\"PWD\", \"/home/j3rn\"),\n///      ...\n///    ])\n///\npub external fn get_all_env() -> Map(String, String) =\n  \"gleam_erlang_ffi\" \"get_all_env\"\n\n/// Returns the value associated with the given environment variable name.\n///\n/// ## Examples\n///\n///    > get_env(\"SHELL\")\n///    \"/bin/bash\"\n///\n///    > get_env(name: \"PWD\")\n///    \"/home/j3rn\"\n///\npub external fn get_env(name: String) -> Result(String, Nil) =\n  \"gleam_erlang_ffi\" \"get_env\"\n\n/// Associates the given value with the given environment variable name.\n///\n/// ## Examples\n///\n///    > set_env(\"MYVAR\", \"MYVALUE\")\n///    Nil\n///    > get_env(\"MYVAR\")\n///    \"MYVALUE\"\n///\n///    > set_env(value: \"MYVALUE\", name: \"MYVAR\")\n///    Nil\n///\npub external fn set_env(name: String, value: String) -> Nil =\n  \"gleam_erlang_ffi\" \"set_env\"\n\n/// Removes the environment variable with the given name.\n///\n/// Returns Nil regardless of whether the variable ever existed.\n///\n/// ## Examples\n///\n///    > get_env(\"MYVAR\")\n///    Ok(\"MYVALUE\")\n///    > unset_env(\"MYVAR\")\n///    Nil\n///    > get_env(\"MYVAR\")\n///    Error(Nil)\n///\n///    > unset_env(name: \"MYVAR\")\n///    Nil\n///\npub external fn unset_env(name: String) -> Nil =\n  \"gleam_erlang_ffi\" \"unset_env\"\n\n/// Represents operating system kernels\npub type OsFamily {\n  // The family which includes modern versions of the Windows operating system.\n  WindowsNt\n  // The family of operating systems based on the open source Linux kernel.\n  Linux\n  // The family of Apple operating systems such as macOS and iOS.\n  Darwin\n  // The family of operating systems based on the FreeBSD kernel.\n  FreeBsd\n  // An operating system kernel other than Linux, Darwin, FreeBSD, or NT.\n  Other(String)\n}\n\n/// Returns the kernel of the host operating system.\n///\n/// Unknown kernels are reported as `Other(String)`; e.g. `Other(\"sunos\")`.\n///\n/// ## Examples\n///\n///    > family()\n///    Linux\n///    > family()\n///    Darwin\n///    > family()\n///    Other(\"sunos\")\n///\npub external fn family() -> OsFamily =\n  \"gleam_erlang_ffi\" \"os_family\"\n" (Durability(0))    
2023-08-04T09:30:46.267550Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267559Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R108    
2023-08-04T09:30:46.267567Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(12)) = "import gleam/string\nimport gleam/dynamic.{Dynamic}\nimport gleam/erlang.{Reference}\nimport gleam/erlang/atom.{Atom}\n\n/// A `Pid` (or Process identifier) is a reference to an Erlang process. Each\n/// process has a `Pid` and it is one of the lowest level building blocks of\n/// inter-process communication in the Erlang and Gleam OTP frameworks.\n///\npub external type Pid\n\n/// Get the `Pid` for the current process.\npub external fn self() -> Pid =\n  \"erlang\" \"self\"\n\n/// Create a new Erlang process that runs concurrently to the creator. In other\n/// languages this might be called a fibre, a green thread, or a coroutine.\n///\n/// If `linked` is `True` then the created process is linked to the creator\n/// process. When a process terminates an exit signal is sent to all other\n/// processes that are linked to it, causing the process to either terminate or\n/// have to handle the signal.\n///\n/// More can be read about processes and links in the [Erlang documentation][1].\n///\n/// [1]: https://www.erlang.org/doc/reference_manual/processes.html\n///\npub fn start(running implementation: fn() -> anything, linked link: Bool) -> Pid {\n  case link {\n    True -> spawn_link(implementation)\n    False -> spawn(implementation)\n  }\n}\n\nexternal fn spawn(fn() -> anything) -> Pid =\n  \"erlang\" \"spawn\"\n\nexternal fn spawn_link(fn() -> anything) -> Pid =\n  \"erlang\" \"spawn_link\"\n\n/// A `Subject` is a value that processes can use to send and receive messages\n/// to and from each other in a well typed way.\n///\n/// Each subject is \"owned\" by the process that created it. Any process can use\n/// the `send` function to sent a message of the correct type to the process\n/// that owns the subject, and the owner can use the `receive` function or the\n/// `Selector` type to receive these messages.\n///\n/// The `Subject` type is similar to the \"channel\" types found in other\n/// languages and the \"topic\" concept found in some pub-sub systems.\n///\n/// # Examples\n///\n/// ```gleam\n/// let subject = new_subject()\n///\n/// // Send a message with the subject\n/// send(subject, \"Hello, Joe!\")\n///\n/// // Receive the message\n/// receive(subject, within: 10)\n/// ```\n///\npub opaque type Subject(message) {\n  Subject(owner: Pid, tag: Reference)\n}\n\n/// Create a new `Subject` owned by the current process.\n///\npub fn new_subject() -> Subject(message) {\n  Subject(owner: self(), tag: erlang.make_reference())\n}\n\n/// Get the owner process for a `Subject`. This is the process that created the\n/// `Subject` and will receive messages sent with it.\n///\npub fn subject_owner(subject: Subject(message)) -> Pid {\n  subject.owner\n}\n\nexternal type DoNotLeak\n\nexternal fn raw_send(Pid, message) -> DoNotLeak =\n  \"erlang\" \"send\"\n\n/// Send a message to a process using a `Subject`. The message must be of the\n/// type that the `Subject` accepts.\n///\n/// This function does not wait for the `Subject` owner process to call the\n/// `receive` function, instead it returns once the message has been placed in\n/// the process' mailbox.\n///\n/// # Ordering\n///\n/// If process P1 sends two messages to process P2 it is guarenteed that process\n/// P1 will receive the messages in the order they were sent.\n///\n/// If you wish to receive the messages in a different order you can send them\n/// on two different subjects and the receiver function can call the `receive`\n/// function for each subject in the desired order, or you can write some Erlang\n/// code to perform a selective receive.\n///\n/// # Examples\n///\n/// ```gleam\n/// let subject = new_subject()\n/// send(subject, \"Hello, Joe!\")\n/// ```\n///\npub fn send(subject: Subject(message), message: message) -> Nil {\n  raw_send(subject.owner, #(subject.tag, message))\n  Nil\n}\n\n/// Receive a message that has been sent to current process using the `Subject`.\n///\n/// If there is not an existing message for the `Subject` in the process'\n/// mailbox or one does not arrive `within` the permitted timeout then the\n/// `Error(Nil)` is returned.\n///\n/// Only the process that is owner of the `Subject` can receive a message using\n/// it. If a process that does not own the `Subject` attempts to receive with it\n/// then it will not receive a message.\n///\n/// To wait for messages from multiple `Subject`s at the same time see the\n/// `Selector` type.\n///\npub fn receive(\n  from subject: Subject(message),\n  within milliseconds: Int,\n) -> Result(message, Nil) {\n  new_selector()\n  |> selecting(subject, fn(x) { x })\n  |> select(within: milliseconds)\n}\n\n/// A type that enables a process to wait for messages from multiple `Subject`s\n/// at the same time, returning whichever message arrives first.\n///\n/// Used with the `new_selector`, `selecting`, and `select` functions.\n///\n/// # Examples\n///\n/// ```gleam\n/// > let int_subject = new_subject()\n/// > let float_subject = new_subject()\n/// > send(int_subject, 1)\n/// >\n/// > let selector =\n/// >   new_selector()\n/// >   |> selecting(int_subject, int.to_string)\n/// >   |> selecting(float_subject, float.to_string)\n/// >\n/// > select(selector)\n/// Ok(\"1\")\n/// ```\n///\npub external type Selector(payload)\n\n/// Create a new `Selector` which can be used to receive messages on multiple\n/// `Subject`s at once.\n///\npub external fn new_selector() -> Selector(payload) =\n  \"gleam_erlang_ffi\" \"new_selector\"\n\n/// Receive a message that has been sent to current process using any of the\n/// `Subject`s that have been added to the `Selector` with the `selecting`\n/// function.\n///\n/// If there is not an existing message for the `Selector` in the process'\n/// mailbox or one does not arrive `within` the permitted timeout then the\n/// `Error(Nil)` is returned.\n///\n/// Only the process that is owner of the `Subject`s can receive a message using\n/// them. If a process that does not own the a `Subject` attempts to receive\n/// with it then it will not receive a message.\n///\n/// To wait forever for the next message rather than for a limited amount of\n/// time see the `select_forever` function.\n///\npub external fn select(\n  from: Selector(payload),\n  within: Int,\n) -> Result(payload, Nil) =\n  \"gleam_erlang_ffi\" \"select\"\n\n/// Similar to the `select` function but will wait forever for a message to\n/// arrive rather than timing out after a specified amount of time.\n///\npub external fn select_forever(from: Selector(payload)) -> payload =\n  \"gleam_erlang_ffi\" \"select\"\n\n/// Add a transformation function to a selector. When a message is received\n/// using this selector the tranformation function is applied to the message.\n///\n/// This function can be used to change the type of messages received and may\n/// be useful when combined with the `merge_selector` function.\n///\npub external fn map_selector(Selector(a), fn(a) -> b) -> Selector(b) =\n  \"gleam_erlang_ffi\" \"map_selector\"\n\n/// Merge one selector into another, producing a selector that contains the\n/// message handlers of both.\n///\n/// If a subject is handled by both selectors the handler function of the\n/// second selector is used.\n///\npub external fn merge_selector(Selector(a), Selector(a)) -> Selector(a) =\n  \"gleam_erlang_ffi\" \"merge_selector\"\n\npub type ExitMessage {\n  ExitMessage(pid: Pid, reason: ExitReason)\n}\n\npub type ExitReason {\n  Normal\n  Killed\n  Abnormal(reason: String)\n}\n\n/// Add a handler for trapped exit messages. In order for these messages to be\n/// sent to the process when a linked process exits the process must call the\n/// `trap_exit` beforehand.\n///\npub fn selecting_trapped_exits(\n  selector: Selector(a),\n  handler: fn(ExitMessage) -> a,\n) -> Selector(a) {\n  let tag = atom.create_from_string(\"EXIT\")\n  let handler = fn(message: #(Atom, Pid, Dynamic)) -> a {\n    let reason = message.2\n    let normal = dynamic.from(Normal)\n    let killed = dynamic.from(Killed)\n    let reason = case dynamic.string(reason) {\n      _ if reason == normal -> Normal\n      _ if reason == killed -> Killed\n      Ok(reason) -> Abnormal(reason)\n      Error(_) -> Abnormal(string.inspect(reason))\n    }\n    handler(ExitMessage(message.1, reason))\n  }\n  insert_selector_handler(selector, #(tag, 3), handler)\n}\n\n// TODO: implement in Gleam\n/// Discard all messages in the current process' mailbox.\n///\n/// Warning: This function may cause other processes to crash if they sent a\n/// message to the current process and are waiting for a response, so use with\n/// caution.\n///\npub external fn flush_messages() -> Nil =\n  \"gleam_erlang_ffi\" \"flush_messages\"\n\n/// Add a new `Subject` to the `Selector` to that it's messages can be received.\n///\n/// The `mapping` function provided with the `Subject` can be used to convert\n/// the type of messages received using this `Subject`. This is useful for when\n/// you wish to add multiple `Subject`s to a `Seletor` when they have differing\n/// message types. If you do not wish to transform the incoming messages in any\n/// way then the `identity` function can be given.\n///\npub fn selecting(\n  selector: Selector(payload),\n  for subject: Subject(message),\n  mapping transform: fn(message) -> payload,\n) -> Selector(payload) {\n  let handler = fn(message: #(Reference, message)) { transform(message.1) }\n  insert_selector_handler(selector, #(subject.tag, 2), handler)\n}\n\n/// Add a handler to a selector for 2 element tuple messages with a given tag\n/// element in the first position.\n///\n/// Typically you want to use the `selecting` function with a `Subject` instead,\n/// but this function may be useful if you need to receive messages sent from\n/// other BEAM languages that do not use the `Subject` type.\n///\npub fn selecting_record2(\n  selector: Selector(payload),\n  tag: tag,\n  mapping transform: fn(Dynamic) -> payload,\n) -> Selector(payload) {\n  let handler = fn(message: #(tag, Dynamic)) { transform(message.1) }\n  insert_selector_handler(selector, #(tag, 2), handler)\n}\n\n/// Add a handler to a selector for 3 element tuple messages with a given tag\n/// element in the first position.\n///\n/// Typically you want to use the `selecting` function with a `Subject` instead,\n/// but this function may be useful if you need to receive messages sent from\n/// other BEAM languages that do not use the `Subject` type.\n///\npub fn selecting_record3(\n  selector: Selector(payload),\n  tag: tag,\n  mapping transform: fn(Dynamic, Dynamic) -> payload,\n) -> Selector(payload) {\n  let handler = fn(message: #(tag, Dynamic, Dynamic)) {\n    transform(message.1, message.2)\n  }\n  insert_selector_handler(selector, #(tag, 3), handler)\n}\n\n/// Add a handler to a selector for 4 element tuple messages with a given tag\n/// element in the first position.\n///\n/// Typically you want to use the `selecting` function with a `Subject` instead,\n/// but this function may be useful if you need to receive messages sent from\n/// other BEAM languages that do not use the `Subject` type.\n///\npub fn selecting_record4(\n  selector: Selector(payload),\n  tag: tag,\n  mapping transform: fn(Dynamic, Dynamic, Dynamic) -> payload,\n) -> Selector(payload) {\n  let handler = fn(message: #(tag, Dynamic, Dynamic, Dynamic)) {\n    transform(message.1, message.2, message.3)\n  }\n  insert_selector_handler(selector, #(tag, 4), handler)\n}\n\n/// Add a handler to a selector for 5 element tuple messages with a given tag\n/// element in the first position.\n///\n/// Typically you want to use the `selecting` function with a `Subject` instead,\n/// but this function may be useful if you need to receive messages sent from\n/// other BEAM languages that do not use the `Subject` type.\n///\npub fn selecting_record5(\n  selector: Selector(payload),\n  tag: tag,\n  mapping transform: fn(Dynamic, Dynamic, Dynamic, Dynamic) -> payload,\n) -> Selector(payload) {\n  let handler = fn(message: #(tag, Dynamic, Dynamic, Dynamic, Dynamic)) {\n    transform(message.1, message.2, message.3, message.4)\n  }\n  insert_selector_handler(selector, #(tag, 5), handler)\n}\n\n/// Add a handler to a selector for 6 element tuple messages with a given tag\n/// element in the first position.\n///\n/// Typically you want to use the `selecting` function with a `Subject` instead,\n/// but this function may be useful if you need to receive messages sent from\n/// other BEAM languages that do not use the `Subject` type.\n///\npub fn selecting_record6(\n  selector: Selector(payload),\n  tag: tag,\n  mapping transform: fn(Dynamic, Dynamic, Dynamic, Dynamic, Dynamic) -> payload,\n) -> Selector(payload) {\n  let handler = fn(message: #(tag, Dynamic, Dynamic, Dynamic, Dynamic, Dynamic)) {\n    transform(message.1, message.2, message.3, message.4, message.5)\n  }\n  insert_selector_handler(selector, #(tag, 6), handler)\n}\n\n/// Add a handler to a selector for 7 element tuple messages with a given tag\n/// element in the first position.\n///\n/// Typically you want to use the `selecting` function with a `Subject` instead,\n/// but this function may be useful if you need to receive messages sent from\n/// other BEAM languages that do not use the `Subject` type.\n///\npub fn selecting_record7(\n  selector: Selector(payload),\n  tag: tag,\n  mapping transform: fn(Dynamic, Dynamic, Dynamic, Dynamic, Dynamic, Dynamic) ->\n    payload,\n) -> Selector(payload) {\n  let handler = fn(\n    message: #(tag, Dynamic, Dynamic, Dynamic, Dynamic, Dynamic, Dynamic),\n  ) {\n    transform(message.1, message.2, message.3, message.4, message.5, message.6)\n  }\n  insert_selector_handler(selector, #(tag, 7), handler)\n}\n\n/// Add a handler to a selector for 8 element tuple messages with a given tag\n/// element in the first position.\n///\n/// Typically you want to use the `selecting` function with a `Subject` instead,\n/// but this function may be useful if you need to receive messages sent from\n/// other BEAM languages that do not use the `Subject` type.\n///\npub fn selecting_record8(\n  selector: Selector(payload),\n  tag: tag,\n  mapping transform: fn(\n    Dynamic,\n    Dynamic,\n    Dynamic,\n    Dynamic,\n    Dynamic,\n    Dynamic,\n    Dynamic,\n  ) ->\n    payload,\n) -> Selector(payload) {\n  let handler = fn(\n    message: #(\n      tag,\n      Dynamic,\n      Dynamic,\n      Dynamic,\n      Dynamic,\n      Dynamic,\n      Dynamic,\n      Dynamic,\n    ),\n  ) {\n    transform(\n      message.1,\n      message.2,\n      message.3,\n      message.4,\n      message.5,\n      message.6,\n      message.7,\n    )\n  }\n  insert_selector_handler(selector, #(tag, 8), handler)\n}\n\ntype AnythingSelectorTag {\n  Anything\n}\n\n/// Add a catch-all handler to a selector that will be used when no other\n/// handler in a selector is suitable for a given message.\n///\n/// This may be useful for when you want to ensure that any message in the inbox\n/// is handled, or when you need to handle messages from other BEAM languages\n/// which do not use subjects or record format messages.\n///\npub fn selecting_anything(\n  selector: Selector(payload),\n  mapping handler: fn(Dynamic) -> payload,\n) -> Selector(payload) {\n  insert_selector_handler(selector, Anything, handler)\n}\n\nexternal fn insert_selector_handler(\n  Selector(payload),\n  for: tag,\n  mapping: fn(message) -> payload,\n) -> Selector(payload) =\n  \"gleam_erlang_ffi\" \"insert_selector_handler\"\n\n/// Suspends the process calling this function for the specified number of\n/// milliseconds.\n///\npub external fn sleep(Int) -> Nil =\n  \"gleam_erlang_ffi\" \"sleep\"\n\n/// Suspends the process forever! This may be useful for suspending the main\n/// process in a Gleam program when it has no more work to do but we want other\n/// processes to continue to work.\n///\npub external fn sleep_forever() -> Nil =\n  \"gleam_erlang_ffi\" \"sleep_forever\"\n\n/// Check to see whether the process for a given `Pid` is alive.\n///\n/// See the [Erlang documentation][1] for more information.\n///\n/// [1]: http://erlang.org/doc/man/erlang.html#is_process_alive-1\n///\npub external fn is_alive(Pid) -> Bool =\n  \"erlang\" \"is_process_alive\"\n\ntype ProcessMonitorFlag {\n  Process\n}\n\nexternal fn erlang_monitor_process(ProcessMonitorFlag, Pid) -> Reference =\n  \"erlang\" \"monitor\"\n\npub opaque type ProcessMonitor {\n  ProcessMonitor(tag: Reference)\n}\n\n/// A message received when a monitored process exits.\n///\npub type ProcessDown {\n  ProcessDown(pid: Pid, reason: Dynamic)\n}\n\n/// Start monitoring a process so that when the monitored process exits a\n/// message is to the monitoring process.\n///\n/// The message is only sent once, when the target process exits. If the\n/// process was not alive when this function is called the message will never\n/// be received.\n///\n/// The down message can be received with a `Selector` and the\n/// `selecting_process_down` function.\n///\n/// The process can be demonitored with the `demonitor_process` function.\n///\npub fn monitor_process(pid: Pid) -> ProcessMonitor {\n  Process\n  |> erlang_monitor_process(pid)\n  |> ProcessMonitor\n}\n\n/// Add a `ProcessMonitor` to a `Selector` so that the `ProcessDown` message can\n/// be received using the `Selector` and the `select` function.\n///\npub fn selecting_process_down(\n  selector: Selector(payload),\n  monitor: ProcessMonitor,\n  mapping: fn(ProcessDown) -> payload,\n) -> Selector(payload) {\n  insert_selector_handler(selector, monitor.tag, mapping)\n}\n\n/// Remove the monitor for a process so that when the monitor process exits a\n/// `ProcessDown` message is not sent to the monitoring process.\n///\n/// If the message has already been sent it is removed from the monitoring\n/// process' mailbox.\n///\npub external fn demonitor_process(monitor: ProcessMonitor) -> Nil =\n  \"gleam_erlang_ffi\" \"demonitor\"\n\n/// An error returned when making a call to a process.\n///\npub type CallError(msg) {\n  /// The process being called exited before it sent a response.\n  ///\n  CalleeDown(reason: Dynamic)\n\n  /// The process being called did not response within the permitted amount of\n  /// time.\n  ///\n  CallTimeout\n}\n\n// This function is based off of Erlang's gen:do_call/4.\n/// Send a message to a process and wait for a reply.\n///\n/// If the receiving process exits or does not reply within the allowed amount\n/// of time then an error is returned.\n///\npub fn try_call(\n  subject: Subject(request),\n  make_request: fn(Subject(response)) -> request,\n  within timeout: Int,\n) -> Result(response, CallError(response)) {\n  let reply_subject = new_subject()\n\n  // Monitor the callee process so we can tell if it goes down (meaning we\n  // won't get a reply)\n  let monitor = monitor_process(subject_owner(subject))\n\n  // Send the request to the process over the channel\n  send(subject, make_request(reply_subject))\n\n  // Await a reply or handle failure modes (timeout, process down, etc)\n  let result =\n    new_selector()\n    |> selecting(reply_subject, Ok)\n    |> selecting_process_down(\n      monitor,\n      fn(down: ProcessDown) { Error(CalleeDown(reason: down.reason)) },\n    )\n    |> select(timeout)\n\n  // Demonitor the process and close the channels as we're done\n  demonitor_process(monitor)\n\n  // Prepare an appropriate error (if present) for the caller\n  case result {\n    Error(Nil) -> Error(CallTimeout)\n    Ok(res) -> res\n  }\n}\n\n/// Send a message to a process and wait for a reply.\n///\n/// If the receiving process exits or does not reply within the allowed amount\n/// of time the calling process crashes. If you wish an error to be returned\n/// instead see the `try_call` function.\n///\npub fn call(\n  subject: Subject(request),\n  make_request: fn(Subject(response)) -> request,\n  within timeout: Int,\n) -> response {\n  let assert Ok(resp) = try_call(subject, make_request, timeout)\n  resp\n}\n\n/// Creates a link between the calling process and another process.\n///\n/// When a process crashes any linked processes will also crash. This is useful\n/// to ensure that groups of processes that depend on each other all either\n/// succeed or fail together.\n///\n/// Returns `True` if the link was created successfully, returns `False` if the\n/// process was not alive and as such could not be linked.\n///\npub external fn link(pid: Pid) -> Bool =\n  \"gleam_erlang_ffi\" \"link\"\n\nexternal fn erlang_unlink(pid: Pid) -> Bool =\n  \"erlang\" \"unlink\"\n\n/// Removes any existing link between the caller process and the target process.\n///\npub fn unlink(pid: Pid) -> Nil {\n  erlang_unlink(pid)\n  Nil\n}\n\npub external type Timer\n\nexternal fn erlang_send_after(Int, Pid, msg) -> Timer =\n  \"erlang\" \"send_after\"\n\n/// Send a message over a channel after a specified number of milliseconds.\n///\npub fn send_after(subject: Subject(msg), delay: Int, message: msg) -> Timer {\n  erlang_send_after(delay, subject.owner, #(subject.tag, message))\n}\n\nexternal fn erlang_cancel_timer(Timer) -> Dynamic =\n  \"erlang\" \"cancel_timer\"\n\n/// Values returned when a timer is cancelled.\n///\npub type Cancelled {\n  /// The timer could not be found. It likely has already triggered.\n  ///\n  TimerNotFound\n\n  /// The timer was found and cancelled before it triggered.\n  ///\n  /// The amount of remaining time before the timer was due to be triggered is\n  /// returned in milliseconds.\n  ///\n  Cancelled(time_remaining: Int)\n}\n\n/// Cancel a given timer, causing it not to trigger if it has not done already.\n///\npub fn cancel_timer(timer: Timer) -> Cancelled {\n  case dynamic.int(erlang_cancel_timer(timer)) {\n    Ok(i) -> Cancelled(i)\n    Error(_) -> TimerNotFound\n  }\n}\n\ntype KillFlag {\n  Kill\n}\n\nexternal fn erlang_kill(to: Pid, because: KillFlag) -> Bool =\n  \"erlang\" \"exit\"\n\n// Go, my pretties. Kill! Kill!\n// - Bart Simpson\n//\n/// Send an untrappable `kill` exit signal to the target process.\n///\n/// See the documentation for the Erlang [`erlang:exit`][1] function for more\n/// information.\n///\n/// [1]: https://erlang.org/doc/man/erlang.html#exit-1\n///\npub fn kill(pid: Pid) -> Nil {\n  erlang_kill(pid, Kill)\n  Nil\n}\n\nexternal fn erlang_send_exit(to: Pid, because: whatever) -> Bool =\n  \"erlang\" \"exit\"\n\n// TODO: test\n/// Sends an exit signal to a process, indicating that the process is to shut\n/// down.\n///\n/// See the [Erlang documentation][erl] for more information.\n/// [erl]: http://erlang.org/doc/man/erlang.html#exit-2\n///\npub fn send_exit(to pid: Pid) -> Nil {\n  erlang_send_exit(pid, Normal)\n  Nil\n}\n\n/// Sends an exit signal to a process, indicating that the process is to shut\n/// down due to an abnormal reason such as a failure.\n///\n/// See the [Erlang documentation][erl] for more information.\n/// [erl]: http://erlang.org/doc/man/erlang.html#exit-2\n///\npub fn send_abnormal_exit(pid: Pid, reason: String) -> Nil {\n  erlang_send_exit(pid, Abnormal(reason))\n  Nil\n}\n\n/// Set whether the current process is to trap exit signals or not.\n///\n/// When not trapping exits if a linked process crashes the exit signal\n/// propagates to the process which will also crash.\n/// This is the normal behaviour before this function is called.\n///\n/// When trapping exits (after this function is called) if a linked process\n/// crashes an exit message is sent to the process instead. These messages can\n/// be handled with the `selecting_trapped_exits` function.\n///\npub external fn trap_exits(Bool) -> Nil =\n  \"gleam_erlang_ffi\" \"trap_exits\"\n" (Durability(0))    
2023-08-04T09:30:46.267834Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267842Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R109    
2023-08-04T09:30:46.267851Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(13)) = "//// A charlist is a list of integers where all the integers are valid code\n//// points.\n////\n//// In practice, you will not come across them often, except perhaps when\n//// interfacing with Erlang, in particular when using older libraries that do\n//// not accept binaries as arguments.\n\n/// A list of characters represented as ints. Commonly used by older Erlang\n/// modules.\npub external type Charlist\n\n/// Transform a charlist to a string\npub external fn to_string(Charlist) -> String =\n  \"unicode\" \"characters_to_binary\"\n\n// Calls `unicode:characters_to_binary(Data, unicode, unicode)`\n// Note: `unicode is an alias for utf8`\n// See <https://www.erlang.org/doc/man/unicode.html#characters_to_binary-1>\n\n/// Transform a string to a charlist\npub external fn from_string(String) -> Charlist =\n  \"unicode\" \"characters_to_list\"\n// Calls `unicode:characters_to_list(Data, unicode)`\n// Note: `unicode is an alias for utf8`\n// See <https://www.erlang.org/doc/man/unicode.html#characters_to_list-1>\n" (Durability(0))    
2023-08-04T09:30:46.267870Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267879Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R110    
2023-08-04T09:30:46.267887Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(14)) = "//// Functions for working with HTTP data structures in Gleam.\n////\n//// This module makes it easy to create and modify Requests and Responses, data types.\n//// A general HTTP message type is defined that enables functions to work on both requests and responses.\n////\n//// This module does not implement a HTTP client or HTTP server, but it can be used as a base for them.\n\nimport gleam/dynamic.{DecodeError, Dynamic}\nimport gleam/string\n\n/// HTTP standard method as defined by [RFC 2616](https://tools.ietf.org/html/rfc2616),\n/// and PATCH which is defined by [RFC 5789](https://tools.ietf.org/html/rfc5789).\npub type Method {\n  Get\n  Post\n  Head\n  Put\n  Delete\n  Trace\n  Connect\n  Options\n  Patch\n\n  /// Non-standard but valid HTTP methods.\n  Other(String)\n}\n\n// TODO: check if the a is a valid HTTP method (i.e. it is a token, as per the\n// spec) and return Ok(Other(s)) if so.\npub fn parse_method(s) -> Result(Method, Nil) {\n  case string.lowercase(s) {\n    \"connect\" -> Ok(Connect)\n    \"delete\" -> Ok(Delete)\n    \"get\" -> Ok(Get)\n    \"head\" -> Ok(Head)\n    \"options\" -> Ok(Options)\n    \"patch\" -> Ok(Patch)\n    \"post\" -> Ok(Post)\n    \"put\" -> Ok(Put)\n    \"trace\" -> Ok(Trace)\n    _ -> Error(Nil)\n  }\n}\n\npub fn method_to_string(method: Method) -> String {\n  case method {\n    Connect -> \"connect\"\n    Delete -> \"delete\"\n    Get -> \"get\"\n    Head -> \"head\"\n    Options -> \"options\"\n    Patch -> \"patch\"\n    Post -> \"post\"\n    Put -> \"put\"\n    Trace -> \"trace\"\n    Other(s) -> s\n  }\n}\n\n/// The two URI schemes for HTTP\n///\npub type Scheme {\n  Http\n  Https\n}\n\n/// Convert a scheme into a string.\n///\n/// # Examples\n///\n///    > scheme_to_string(Http)\n///    \"http\"\n///\n///    > scheme_to_string(Https)\n///    \"https\"\n///\npub fn scheme_to_string(scheme: Scheme) -> String {\n  case scheme {\n    Http -> \"http\"\n    Https -> \"https\"\n  }\n}\n\n/// Parse a HTTP scheme from a string\n///\n/// # Examples\n///\n///    > scheme_to_string(\"http\")\n///    Ok(Http)\n///\n///    > scheme_to_string(\"ftp\")\n///    Error(Nil)\n///\npub fn scheme_from_string(scheme: String) -> Result(Scheme, Nil) {\n  case string.lowercase(scheme) {\n    \"http\" -> Ok(Http)\n    \"https\" -> Ok(Https)\n    _ -> Error(Nil)\n  }\n}\n\npub fn method_from_dynamic(value: Dynamic) -> Result(Method, List(DecodeError)) {\n  case do_method_from_dynamic(value) {\n    Ok(method) -> Ok(method)\n    Error(_) -> Error([DecodeError(\"HTTP method\", dynamic.classify(value), [])])\n  }\n}\n\nif erlang {\n  external fn do_method_from_dynamic(Dynamic) -> Result(Method, nil) =\n    \"gleam_http_native\" \"decode_method\"\n}\n\nif javascript {\n  external fn do_method_from_dynamic(Dynamic) -> Result(Method, Nil) =\n    \"../gleam_http_native.mjs\" \"decode_method\"\n}\n\n/// A HTTP header is a key-value pair. Header keys should be all lowercase\n/// characters.\npub type Header =\n  #(String, String)\n" (Durability(0))    
2023-08-04T09:30:46.267937Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.267945Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R111    
2023-08-04T09:30:46.267957Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(15)) = "import gleam/result\nimport gleam/http.{Header}\nimport gleam/http/cookie\nimport gleam/list\nimport gleam/string\nimport gleam/option\n\n// TODO: document\npub type Response(body) {\n  Response(status: Int, headers: List(Header), body: body)\n}\n\n/// Update the body of a response using a given result returning function.\n///\n/// If the given function returns an `Ok` value the body is set, if it returns\n/// an `Error` value then the error is returned.\n///\npub fn try_map(\n  response: Response(old_body),\n  transform: fn(old_body) -> Result(new_body, error),\n) -> Result(Response(new_body), error) {\n  use body <- result.then(transform(response.body))\n  Ok(set_body(response, body))\n}\n\n/// Construct an empty Response.\n///\n/// The body type of the returned response is `String` and could be set with a\n/// call to `set_body`.\n///\npub fn new(status: Int) -> Response(String) {\n  Response(status: status, headers: [], body: \"\")\n}\n\n/// Get the value for a given header.\n///\n/// If the response does not have that header then `Error(Nil)` is returned.\n///\npub fn get_header(response: Response(body), key: String) -> Result(String, Nil) {\n  list.key_find(response.headers, string.lowercase(key))\n}\n\n/// Set the header with the given value under the given header key.\n///\n/// If the response already has that key, it is replaced.\npub fn set_header(\n  response: Response(body),\n  key: String,\n  value: String,\n) -> Response(body) {\n  let headers = list.key_set(response.headers, key, string.lowercase(value))\n  Response(..response, headers: headers)\n}\n\n/// Prepend the header with the given value under the given header key.\n///\n/// Similar to `set_header` except if the header already exists it prepends\n/// another header with the same key.\npub fn prepend_header(\n  response: Response(body),\n  key: String,\n  value: String,\n) -> Response(body) {\n  let headers = [#(string.lowercase(key), value), ..response.headers]\n  Response(..response, headers: headers)\n}\n\n/// Set the body of the response, overwriting any existing body.\n///\npub fn set_body(\n  response: Response(old_body),\n  body: new_body,\n) -> Response(new_body) {\n  let Response(status: status, headers: headers, ..) = response\n  Response(status: status, headers: headers, body: body)\n}\n\n/// Update the body of a response using a given function.\n///\npub fn map(\n  response: Response(old_body),\n  transform: fn(old_body) -> new_body,\n) -> Response(new_body) {\n  response.body\n  |> transform\n  |> set_body(response, _)\n}\n\n/// Create a response that redirects to the given uri.\n///\npub fn redirect(uri: String) -> Response(String) {\n  Response(\n    status: 303,\n    headers: [#(\"location\", uri)],\n    body: string.append(\"You are being redirected to \", uri),\n  )\n}\n\n/// Fetch the cookies sent in a response. \n///\n/// Badly formed cookies will be discarded.\n///\npub fn get_cookies(resp) -> List(#(String, String)) {\n  let Response(headers: headers, ..) = resp\n  headers\n  |> list.filter_map(fn(header) {\n    let #(name, value) = header\n    case name {\n      \"set-cookie\" -> Ok(cookie.parse(value))\n      _ -> Error(Nil)\n    }\n  })\n  |> list.flatten()\n}\n\n/// Set a cookie value for a client\n///\npub fn set_cookie(\n  response: Response(t),\n  name: String,\n  value: String,\n  attributes: cookie.Attributes,\n) -> Response(t) {\n  prepend_header(\n    response,\n    \"set-cookie\",\n    cookie.set_header(name, value, attributes),\n  )\n}\n\n/// Expire a cookie value for a client\n///\n/// Note: The attributes value should be the same as when the response cookie was set.\npub fn expire_cookie(\n  response: Response(t),\n  name: String,\n  attributes: cookie.Attributes,\n) -> Response(t) {\n  let attrs = cookie.Attributes(..attributes, max_age: option.Some(0))\n  set_cookie(response, name, \"\", attrs)\n}\n" (Durability(0))    
2023-08-04T09:30:46.268012Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268020Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R112    
2023-08-04T09:30:46.268028Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(16)) = "import gleam/result\n// TODO: validate_req\nimport gleam/http.{Get, Header, Method, Scheme}\nimport gleam/http/cookie\nimport gleam/option.{None, Option, Some}\nimport gleam/uri.{Uri}\nimport gleam/list\nimport gleam/string\nimport gleam/string_builder\n\n// TODO: document\npub type Request(body) {\n  Request(\n    method: Method,\n    headers: List(Header),\n    body: body,\n    scheme: Scheme,\n    host: String,\n    port: Option(Int),\n    path: String,\n    query: Option(String),\n  )\n}\n\n/// Return the uri that a request was sent to.\n///\npub fn to_uri(request: Request(a)) -> Uri {\n  Uri(\n    scheme: option.Some(http.scheme_to_string(request.scheme)),\n    userinfo: option.None,\n    host: option.Some(request.host),\n    port: request.port,\n    path: request.path,\n    query: request.query,\n    fragment: option.None,\n  )\n}\n\n/// Construct a request from a URI.\n///\npub fn from_uri(uri: Uri) -> Result(Request(String), Nil) {\n  use scheme <- result.then(\n    uri.scheme\n    |> option.unwrap(\"\")\n    |> http.scheme_from_string,\n  )\n  use host <- result.then(\n    uri.host\n    |> option.to_result(Nil),\n  )\n  let req =\n    Request(\n      method: Get,\n      headers: [],\n      body: \"\",\n      scheme: scheme,\n      host: host,\n      port: uri.port,\n      path: uri.path,\n      query: uri.query,\n    )\n  Ok(req)\n}\n\n/// Get the value for a given header.\n///\n/// If the request does not have that header then `Error(Nil)` is returned.\n///\npub fn get_header(request: Request(body), key: String) -> Result(String, Nil) {\n  list.key_find(request.headers, string.lowercase(key))\n}\n\n/// Set the header with the given value under the given header key.\n///\n/// If already present, it is replaced.\npub fn set_header(\n  request: Request(body),\n  key: String,\n  value: String,\n) -> Request(body) {\n  let headers = list.key_set(request.headers, string.lowercase(key), value)\n  Request(..request, headers: headers)\n}\n\n/// Prepend the header with the given value under the given header key.\n///\n/// Similar to `set_header` except if the header already exists it prepends\n/// another header with the same key.\npub fn prepend_header(\n  request: Request(body),\n  key: String,\n  value: String,\n) -> Request(body) {\n  let headers = [#(string.lowercase(key), value), ..request.headers]\n  Request(..request, headers: headers)\n}\n\n// TODO: record update syntax, which can't be done currently as body type changes\n/// Set the body of the request, overwriting any existing body.\n///\npub fn set_body(req: Request(old_body), body: new_body) -> Request(new_body) {\n  let Request(\n    method: method,\n    headers: headers,\n    scheme: scheme,\n    host: host,\n    port: port,\n    path: path,\n    query: query,\n    ..,\n  ) = req\n  Request(\n    method: method,\n    headers: headers,\n    body: body,\n    scheme: scheme,\n    host: host,\n    port: port,\n    path: path,\n    query: query,\n  )\n}\n\n/// Update the body of a request using a given function.\n///\npub fn map(\n  request: Request(old_body),\n  transform: fn(old_body) -> new_body,\n) -> Request(new_body) {\n  request.body\n  |> transform\n  |> set_body(request, _)\n}\n\n/// Return the non-empty segments of a request path.\n///\npub fn path_segments(request: Request(body)) -> List(String) {\n  request.path\n  |> uri.path_segments\n}\n\n/// Decode the query of a request.\npub fn get_query(request: Request(body)) -> Result(List(#(String, String)), Nil) {\n  case request.query {\n    option.Some(query_string) -> uri.parse_query(query_string)\n    option.None -> Ok([])\n  }\n}\n\n// TODO: escape\n/// Set the query of the request.\n///\npub fn set_query(\n  req: Request(body),\n  query: List(#(String, String)),\n) -> Request(body) {\n  let pair = fn(t: #(String, String)) {\n    string_builder.from_strings([t.0, \"=\", t.1])\n  }\n  let query =\n    query\n    |> list.map(pair)\n    |> list.intersperse(string_builder.from_string(\"&\"))\n    |> string_builder.concat\n    |> string_builder.to_string\n    |> option.Some\n  Request(..req, query: query)\n}\n\n/// Set the method of the request.\n///\npub fn set_method(req: Request(body), method: Method) -> Request(body) {\n  Request(..req, method: method)\n}\n\n/// A request with commonly used default values. This request can be used as\n/// an initial value and then update to create the desired request.\n///\npub fn new() -> Request(String) {\n  Request(\n    method: Get,\n    headers: [],\n    body: \"\",\n    scheme: http.Https,\n    host: \"localhost\",\n    port: option.None,\n    path: \"\",\n    query: option.None,\n  )\n}\n\n/// Construct a request from a URL string\n///\npub fn to(url: String) -> Result(Request(String), Nil) {\n  url\n  |> uri.parse\n  |> result.then(from_uri)\n}\n\n/// Set the scheme (protocol) of the request.\n///\npub fn set_scheme(req: Request(body), scheme: Scheme) -> Request(body) {\n  Request(..req, scheme: scheme)\n}\n\n/// Set the method of the request.\n///\npub fn set_host(req: Request(body), host: String) -> Request(body) {\n  Request(..req, host: host)\n}\n\n/// Set the port of the request.\n///\npub fn set_port(req: Request(body), port: Int) -> Request(body) {\n  Request(..req, port: option.Some(port))\n}\n\n/// Set the path of the request.\n///\npub fn set_path(req: Request(body), path: String) -> Request(body) {\n  Request(..req, path: path)\n}\n\n/// Send a cookie with a request\n///\n/// Multiple cookies are added to the same cookie header.\npub fn set_cookie(req: Request(body), name: String, value: String) {\n  let new_cookie_string = string.join([name, value], \"=\")\n\n  let #(cookies_string, headers) = case list.key_pop(req.headers, \"cookie\") {\n    Ok(#(cookies_string, headers)) -> {\n      let cookies_string =\n        string.join([cookies_string, new_cookie_string], \"; \")\n      #(cookies_string, headers)\n    }\n    Error(Nil) -> #(new_cookie_string, req.headers)\n  }\n\n  Request(..req, headers: [#(\"cookie\", cookies_string), ..headers])\n}\n\n/// Fetch the cookies sent in a request.\n///\n/// Note badly formed cookie pairs will be ignored.\n/// RFC6265 specifies that invalid cookie names/attributes should be ignored.\npub fn get_cookies(req) -> List(#(String, String)) {\n  let Request(headers: headers, ..) = req\n\n  headers\n  |> list.filter_map(fn(header) {\n    let #(name, value) = header\n    case name {\n      \"cookie\" -> Ok(cookie.parse(value))\n      _ -> Error(Nil)\n    }\n  })\n  |> list.flatten()\n}\n" (Durability(0))    
2023-08-04T09:30:46.268120Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268128Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R113    
2023-08-04T09:30:46.268137Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(17)) = "import gleam/result\nimport gleam/int\nimport gleam/list\nimport gleam/regex\nimport gleam/string\nimport gleam/option.{Option, Some}\nimport gleam/http.{Scheme}\n\n/// Policy options for the SameSite cookie attribute\n///\n/// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite\npub type SameSitePolicy {\n  Lax\n  Strict\n  None\n}\n\nfn same_site_to_string(policy) {\n  case policy {\n    Lax -> \"Lax\"\n    Strict -> \"Strict\"\n    None -> \"None\"\n  }\n}\n\n/// Attributes of a cookie when sent to a client in the `set-cookie` header.\npub type Attributes {\n  Attributes(\n    max_age: Option(Int),\n    domain: Option(String),\n    path: Option(String),\n    secure: Bool,\n    http_only: Bool,\n    same_site: Option(SameSitePolicy),\n  )\n}\n\n/// Helper to create sensible default attributes for a set cookie.\n///\n/// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Attributes\npub fn defaults(scheme: Scheme) {\n  Attributes(\n    max_age: option.None,\n    domain: option.None,\n    path: option.Some(\"/\"),\n    secure: scheme == http.Https,\n    http_only: True,\n    same_site: Some(Lax),\n  )\n}\n\nconst epoch = \"Expires=Thu, 01 Jan 1970 00:00:00 GMT\"\n\nfn cookie_attributes_to_list(attributes) {\n  let Attributes(\n    max_age: max_age,\n    domain: domain,\n    path: path,\n    secure: secure,\n    http_only: http_only,\n    same_site: same_site,\n  ) = attributes\n  [\n    // Expires is a deprecated attribute for cookies, it has been replaced with MaxAge\n    // MaxAge is widely supported and so Expires values are not set.\n    // Only when deleting cookies is the exception made to use the old format,\n    // to ensure complete clearup of cookies if required by an application.\n    case max_age {\n      option.Some(0) -> option.Some([epoch])\n      _ -> option.None\n    },\n    option.map(max_age, fn(max_age) { [\"Max-Age=\", int.to_string(max_age)] }),\n    option.map(domain, fn(domain) { [\"Domain=\", domain] }),\n    option.map(path, fn(path) { [\"Path=\", path] }),\n    case secure {\n      True -> option.Some([\"Secure\"])\n      False -> option.None\n    },\n    case http_only {\n      True -> option.Some([\"HttpOnly\"])\n      False -> option.None\n    },\n    option.map(\n      same_site,\n      fn(same_site) { [\"SameSite=\", same_site_to_string(same_site)] },\n    ),\n  ]\n  |> list.filter_map(option.to_result(_, Nil))\n}\n\npub fn set_header(name: String, value: String, attributes: Attributes) -> String {\n  [[name, \"=\", value], ..cookie_attributes_to_list(attributes)]\n  |> list.map(string.join(_, \"\"))\n  |> string.join(\"; \")\n}\n\n/// Parse a list of cookies from a header string. Any malformed cookies will be\n/// discarded.\n///\npub fn parse(cookie_string: String) -> List(#(String, String)) {\n  let assert Ok(re) = regex.from_string(\"[,;]\")\n  regex.split(re, cookie_string)\n  |> list.filter_map(fn(pair) {\n    case string.split_once(string.trim(pair), \"=\") {\n      Ok(#(\"\", _)) -> Error(Nil)\n      Ok(#(key, value)) -> {\n        let key = string.trim(key)\n        let value = string.trim(value)\n        use _ <- result.then(check_token(key))\n        use _ <- result.then(check_token(value))\n        Ok(#(key, value))\n      }\n      Error(Nil) -> Error(Nil)\n    }\n  })\n}\n\nfn check_token(token: String) -> Result(Nil, Nil) {\n  case string.pop_grapheme(token) {\n    Error(Nil) -> Ok(Nil)\n    Ok(#(\" \", _)) -> Error(Nil)\n    Ok(#(\"\\t\", _)) -> Error(Nil)\n    Ok(#(\"\\r\", _)) -> Error(Nil)\n    Ok(#(\"\\n\", _)) -> Error(Nil)\n    Ok(#(\"\\f\", _)) -> Error(Nil)\n    Ok(#(_, rest)) -> check_token(rest)\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.268196Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268204Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R114    
2023-08-04T09:30:46.268213Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(18)) = "import gleam/http.{Delete, Patch, Post, Put}\nimport gleam/http/request.{Request}\nimport gleam/http/response.{Response}\nimport gleam/list\nimport gleam/result\n\n// TODO: document\npub type Service(in, out) =\n  fn(Request(in)) -> Response(out)\n\npub type Middleware(before_req, before_resp, after_req, after_resp) =\n  fn(Service(before_req, before_resp)) -> Service(after_req, after_resp)\n\n/// A middleware that transform the response body returned by the service using\n/// a given function.\n///\npub fn map_response_body(\n  service: Service(req, a),\n  with mapper: fn(a) -> b,\n) -> Service(req, b) {\n  fn(req) {\n    req\n    |> service\n    |> response.map(mapper)\n  }\n}\n\n/// A middleware that prepends a header to the request.\n///\npub fn prepend_response_header(\n  service: Service(req, resp),\n  key: String,\n  value: String,\n) -> Service(req, resp) {\n  fn(req) {\n    req\n    |> service\n    |> response.prepend_header(key, value)\n  }\n}\n\nfn ensure_post(req: Request(a)) {\n  case req.method {\n    Post -> Ok(req)\n    _ -> Error(Nil)\n  }\n}\n\nfn get_override_method(request: Request(t)) -> Result(http.Method, Nil) {\n  use query_params <- result.then(request.get_query(request))\n  use method <- result.then(list.key_find(query_params, \"_method\"))\n  use method <- result.then(http.parse_method(method))\n  case method {\n    Put | Patch | Delete -> Ok(method)\n    _ -> Error(Nil)\n  }\n}\n\n/// A middleware that overrides an incoming POST request with a method given in\n/// the request's `_method` query paramerter. This is useful as web browsers\n/// typically only support GET and POST requests, but our application may\n/// expect other HTTP methods that are more semantically correct.\n///\n/// The methods PUT, PATCH, and DELETE are accepted for overriding, all others\n/// are ignored.\n///\n/// The `_method` query paramerter can be specified in a HTML form like so:\n///\n///    <form method=\"POST\" action=\"/item/1?_method=DELETE\">\n///      <button type=\"submit\">Delete item</button>\n///    </form>\n///\npub fn method_override(service: Service(req, resp)) -> Service(req, resp) {\n  fn(request) {\n    request\n    |> ensure_post\n    |> result.then(get_override_method)\n    |> result.map(request.set_method(request, _))\n    |> result.unwrap(request)\n    |> service\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.268246Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268254Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R115    
2023-08-04T09:30:46.268263Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(19)) = "import gleam/dynamic.{Dynamic}\nimport gleam/erlang/atom.{Atom}\nimport gleam/erlang/process.{Pid}\n\npub type Mode {\n  Running\n  Suspended\n}\n\npub type DebugOption {\n  NoDebug\n}\n\npub external type DebugState\n\npub external fn debug_state(List(DebugOption)) -> DebugState =\n  \"sys\" \"debug_options\"\n\npub type StatusInfo {\n  StatusInfo(\n    module: Atom,\n    parent: Pid,\n    mode: Mode,\n    debug_state: DebugState,\n    state: Dynamic,\n  )\n}\n\n// TODO: document\n// TODO: implement remaining messages\npub type SystemMessage {\n  // {replace_state, StateFn}\n  // {change_code, Mod, Vsn, Extra}\n  // {terminate, Reason}\n  // {debug, {log, Flag}}\n  // {debug, {trace, Flag}}\n  // {debug, {log_to_file, FileName}}\n  // {debug, {statistics, Flag}}\n  // {debug, no_debug}\n  // {debug, {install, {Func, FuncState}}}\n  // {debug, {install, {FuncId, Func, FuncState}}}\n  // {debug, {remove, FuncOrId}}\n  Resume(fn() -> Nil)\n  Suspend(fn() -> Nil)\n  GetState(fn(Dynamic) -> Nil)\n  GetStatus(fn(StatusInfo) -> Nil)\n}\n\nexternal type DoNotLeak\n\n/// Get the state of a given OTP compatible process. This function is only\n/// intended for debugging.\n///\n/// For more information see the [Erlang documentation][1].\n///\n/// [1]: https://erlang.org/doc/man/sys.html#get_state-1\n///\npub external fn get_state(from: Pid) -> Dynamic =\n  \"sys\" \"get_state\"\n\nexternal fn erl_suspend(Pid) -> DoNotLeak =\n  \"sys\" \"suspend\"\n\n/// Request an OTP compatible process to suspend, causing it to only handle\n/// system messages.\n///\n/// For more information see the [Erlang documentation][1].\n///\n/// [1]: https://erlang.org/doc/man/sys.html#suspend-1\n///\npub fn suspend(pid: Pid) -> Nil {\n  erl_suspend(pid)\n  Nil\n}\n\nexternal fn erl_resume(from: Pid) -> DoNotLeak =\n  \"sys\" \"resume\"\n\n/// Request a suspended OTP compatible process to result, causing it to handle\n/// all messages rather than only system messages.\n///\n/// For more information see the [Erlang documentation][1].\n///\n/// [1]: https://erlang.org/doc/man/sys.html#resume-1\n///\npub fn resume(pid: Pid) -> Nil {\n  erl_resume(pid)\n  Nil\n}\n" (Durability(0))    
2023-08-04T09:30:46.268307Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268315Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R116    
2023-08-04T09:30:46.268324Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(20)) = "//// The intensity tracker is used to monitor how frequently an event happens,\n//// erroring if it happens too many times within a period of time.\n\nimport gleam/list\n\n// TODO: test\npub opaque type IntensityTracker {\n  IntensityTracker(limit: Int, period: Int, events: List(Int))\n}\n\npub type TooIntense {\n  TooIntense\n}\n\npub fn new(limit limit: Int, period period: Int) -> IntensityTracker {\n  IntensityTracker(limit: limit, period: period, events: [])\n}\n\nexternal fn monotonic_time(Int) -> Int =\n  \"erlang\" \"monotonic_time\"\n\nfn now_seconds() -> Int {\n  monotonic_time(1)\n}\n\npub fn trim_window(events: List(Int), now: Int, period: Int) -> List(Int) {\n  case events {\n    [] -> []\n    [event, ..events] ->\n      case now >= event + period {\n        True -> [event, ..trim_window(events, now, period)]\n        False -> []\n      }\n  }\n}\n\npub fn add_event(\n  tracker: IntensityTracker,\n) -> Result(IntensityTracker, TooIntense) {\n  let now = now_seconds()\n  let events = trim_window([now, ..tracker.events], now, tracker.period)\n  case list.length(events) >= tracker.limit {\n    True -> Error(TooIntense)\n    False -> Ok(IntensityTracker(..tracker, events: events))\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.268346Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268354Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R117    
2023-08-04T09:30:46.268363Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(21)) = "//// A task is a kind of process that performs a single task and then shuts\n//// down. Commonly tasks are used to convert sequential code into concurrent\n//// code by performing computation in another process.\n////\n////    let task = task.async(fn() { do_some_work() })\n////    let value = do_some_other_work()\n////    value + task.await(task, 100)\n////\n//// Tasks spawned with async can be awaited on by their caller process (and\n//// only their caller) as shown in the example above. They are implemented by\n//// spawning a process that sends a message to the caller once the given\n//// computation is performed.\n////\n//// There are two important things to consider when using `async`:\n////\n//// 1. If you are using async tasks, you must await a reply as they are always\n////    sent.\n////\n//// 2. async tasks link the caller and the spawned process. This means that,\n////    if the caller crashes, the task will crash too and vice-versa. This is\n////    on purpose: if the process meant to receive the result no longer\n////    exists, there is no purpose in completing the computation.\n////\n//// This module is inspired by Elixir's [Task module][1].\n////\n//// [1]: https://hexdocs.pm/elixir/master/Task.html\n////\n\n// TODO: await_many\nimport gleam/erlang/process.{Pid, ProcessMonitor, Selector}\nimport gleam/dynamic.{Dynamic}\n\npub opaque type Task(value) {\n  Task(\n    owner: Pid,\n    pid: Pid,\n    monitor: ProcessMonitor,\n    selector: Selector(Message(value)),\n  )\n}\n\n// TODO: test\n/// Spawn a task process that calls a given function in order to perform some\n/// work. The result of this function is send back to the parent and can be\n/// received using the `await` function.\n///\n/// See the top level module documentation for more information on async/await.\n///\npub fn async(work: fn() -> value) -> Task(value) {\n  let owner = process.self()\n  let subject = process.new_subject()\n  let pid =\n    process.start(linked: True, running: fn() { process.send(subject, work()) })\n  let monitor = process.monitor_process(pid)\n  let selector =\n    process.new_selector()\n    |> process.selecting_process_down(monitor, FromMonitor)\n    |> process.selecting(subject, FromSubject)\n  Task(owner: owner, pid: pid, monitor: monitor, selector: selector)\n}\n\npub type AwaitError {\n  Timeout\n  Exit(reason: Dynamic)\n}\n\n// We can only wait on a task if we are the owner of it so crash if we are\n// waiting on a task we don't own.\nfn assert_owner(task: Task(a)) -> Nil {\n  let self = process.self()\n  case task.owner == self {\n    True -> Nil\n    False ->\n      process.send_abnormal_exit(\n        self,\n        \"awaited on a task that does not belong to this process\",\n      )\n  }\n}\n\ntype Message(value) {\n  FromMonitor(process.ProcessDown)\n  FromSubject(value)\n}\n\n// TODO: test\n/// Wait for the value computed by a task.\n///\n/// If the a value is not received before the timeout has elapsed or if the\n/// task process crashes then an error is returned.\n///\npub fn try_await(task: Task(value), timeout: Int) -> Result(value, AwaitError) {\n  assert_owner(task)\n  case process.select(task.selector, timeout) {\n    // The task process has sent back a value\n    Ok(FromSubject(x)) -> {\n      process.demonitor_process(task.monitor)\n      Ok(x)\n    }\n\n    // The task process crashed without sending a value\n    Ok(FromMonitor(process.ProcessDown(reason: reason, ..))) ->\n      Error(Exit(reason))\n\n    // The task process is alive but has not sent a value yet\n    Error(Nil) -> Error(Timeout)\n  }\n}\n\n// TODO: test\n/// Wait for the value computed by a task.\n///\n/// If the a value is not received before the timeout has elapsed or if the\n/// task process crashes then this function crashes.\n///\npub fn await(task: Task(value), timeout: Int) -> value {\n  let assert Ok(value) = try_await(task, timeout)\n  value\n}\n\n/// Wait endlessly for the value computed by a task.\n///\n/// Be Careful! This function does not return until there is a value to\n/// receive. If a value is not received then the process will be stuck waiting\n/// forever.\n///\npub fn try_await_forever(task: Task(value)) -> Result(value, AwaitError) {\n  assert_owner(task)\n  case process.select_forever(task.selector) {\n    // The task process has sent back a value\n    FromSubject(x) -> {\n      process.demonitor_process(task.monitor)\n      Ok(x)\n    }\n\n    // The task process crashed without sending a value\n    FromMonitor(process.ProcessDown(reason: reason, ..)) -> Error(Exit(reason))\n  }\n}\n\n/// Wait endlessly for the value computed by a task.\n///\n/// Be Careful! Like `try_await_forever`, this function does not return until there is a value to\n/// receive.\n///\n/// If the task process crashes then this function crashes.\n///\npub fn await_forever(task: Task(value)) -> value {\n  let assert Ok(value) = try_await_forever(task)\n  value\n}\n" (Durability(0))    
2023-08-04T09:30:46.268434Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268442Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R118    
2023-08-04T09:30:46.268451Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(22)) = "//// This module provides the _Actor_ abstraction, one of the most common\n//// building blocks of Gleam OTP programs.\n//// \n//// An Actor is a process like any other BEAM process and can be be used to hold\n//// state, execute code, and communicate with other processes by sending and\n//// receiving messages. The advantage of using the actor abstraction over a bare\n//// process is that it provides a single interface for commonly needed\n//// functionality, including support for the [tracing and debugging\n//// features in OTP](erlang-sys).\n////\n//// Gleam's Actor is similar to Erlang's `gen_server` and Elixir's `GenServer`\n//// but differs in that it offers a fully typed interface. This different API is\n//// why Gleam uses the name Actor rather than some variation of generic-server.\n////\n//// [erlang-sys]: https://www.erlang.org/doc/man/sys.html\n////\n//// ## Example\n////\n//// An Actor can be used to create a client-server interaction between an Actor\n//// (the server) and other processes (the clients). In this example we have an\n//// Actor that works as a stack, allowing clients to push and pop elements.\n////\n//// ```gleam\n//// pub fn main() {\n////   // Start the actor with initial state of an empty list, and the\n////   // `handle_message` callback function (defined below).\n////   // We assert that it starts successfully.\n////   // \n////   // In real-world Gleam OTP programs we would likely write a wrapper functions\n////   // called `start`, `push` `pop`, `shutdown` to start and interact with the\n////   // Actor. We are not doing that here for the sake of showing how the Actor \n////   // API works.\n////   let assert Ok(actor) = actor.start([], handle_message)\n//// \n////   // We can send a message to the actor to push elements onto the stack.\n////   process.send(actor, Push(\"Joe\"))\n////   process.send(actor, Push(\"Mike\"))\n////   process.send(actor, Push(\"Robert\"))\n//// \n////   // The `Push` message expects no response, these messages are sent purely for\n////   // the side effect of mutating the state held by the actor.\n////   //\n////   // We can also send the `Pop` message to take a value off of the actor's\n////   // stack. This message expects a response, so we use `process.call` to send a\n////   // message and wait until a reply is received.\n////   //\n////   // In this instance we are giving the actor 10 milliseconds to reply, if the\n////   // `call` function doesn't get a reply within this time it will panic and\n////   // crash the client process.\n////   let assert Ok(\"Robert\") = process.call(actor, Pop, 10)\n////   let assert Ok(\"Mike\") = process.call(actor, Pop, 10)\n////   let assert Ok(\"Joe\") = process.call(actor, Pop, 10)\n//// \n////   // The stack is now empty, so if we pop again the actor replies with an error.\n////   let assert Error(Nil) = process.call(actor, Pop, 10)\n//// \n////   // Lastly, we can send a message to the actor asking it to shut down.\n////   process.send(actor, Shutdown)\n//// }\n//// ```\n////\n//// Here is the code that is used to implement this actor:\n////\n//// ```gleam\n//// // First step of implementing the stack Actor is to define the message type that\n//// // it can receive.\n//// //\n//// // The type of the elements in the stack is no fixed so a type parameter is used\n//// // for it instead of a concrete type such as `String` or `Int`.\n//// pub type Message(element) {\n////   // The `Shutdown` message is used to tell the actor to stop.\n////   // It is the simplest message type, it contains no data.\n////   Shutdown\n//// \n////   // The `Push` message is used to add a new element to the stack.\n////   // It contains the item to add, the type of which is the `element`\n////   // parameterised type.\n////   Push(push: element)\n//// \n////   // The `Pop` message is used to remove an element from the stack.\n////   // It contains a `Subject`, which is used to send the response back to the\n////   // message sender. In this case the reply is of type `Result(element, Nil)`.\n////   Pop(reply_with: Subject(Result(element, Nil)))\n//// }\n//// \n//// // The last part is to implement the `handle_message` callback function.\n//// //\n//// // This function is called by the Actor each for each message it receives.\n//// // Actor is single threaded only does one thing at a time, so it handles\n//// // messages sequentially and one at a time, in the order they are received.\n//// //\n//// // The function takes the message and the current state, and returns a data\n//// // structure that indicates what to do next, along with the new state.\n//// fn handle_message(message: Message(e), stack: List(e)) -> actor.Next(List(e)) {\n////   case message {\n////     // For the `Shutdown` message we return the `actor.Stop` value, which causes\n////     // the actor to discard any remaining messages and stop.\n////     Shutdown -> actor.Stop(process.Normal)\n//// \n////     // For the `Push` message we add the new element to the stack and return\n////     // `actor.Continue` with this new stack, causing the actor to process any\n////     // queued messages or wait for more.\n////     Push(value) -> {\n////       let new_state = [value, ..stack]\n////       actor.Continue(new_state)\n////     }\n//// \n////     // For the `Pop` message we attempt to remove an element from the stack,\n////     // sending it or an error back to the caller, before continuing.\n////     Pop(client) ->\n////       case stack {\n////         [] -> {\n////           // When the stack is empty we can't pop an element, so we send an\n////           // error back.\n////           process.send(client, Error(Nil))\n////           actor.Continue([])\n////         }\n//// \n////         [first, ..rest] -> {\n////           // Otherwise we send the first element back and use the remaining\n////           // elements as the new state.\n////           process.send(client, Ok(first))\n////           actor.Continue(rest)\n////         }\n////       }\n////   }\n//// }\n//// ```\n\nimport gleam/erlang/process.{Abnormal, ExitReason, Pid, Selector, Subject}\nimport gleam/erlang/charlist.{Charlist}\nimport gleam/otp/system.{\n  DebugState, GetState, GetStatus, Mode, Resume, Running, StatusInfo, Suspend,\n  Suspended, SystemMessage,\n}\nimport gleam/string\nimport gleam/dynamic.{Dynamic}\nimport gleam/erlang/atom\n\ntype Message(message) {\n  /// A regular message excepted by the process\n  Message(message)\n\n  /// An OTP system message, for debugging or maintenance\n  System(SystemMessage)\n\n  /// An unexpected message\n  Unexpected(Dynamic)\n}\n\n/// The type used to indicate what to do after handling a message.\n///\npub type Next(state) {\n  /// Continue handling messages.\n  ///\n  Continue(state)\n\n  /// Stop handling messages and shut down.\n  ///\n  Stop(ExitReason)\n}\n\n/// The type used to indicate whether an actor has started successfully or not.\n///\npub type InitResult(state, message) {\n  /// The actor has successfully initialised. The actor can start handling\n  /// messages and actor's channel sender can be returned to the parent\n  /// process.\n  ///\n  Ready(state: state, selector: Selector(message))\n\n  /// The actor has failed to initialise. The actor shuts down and an error is\n  /// returned to the parent process.\n  ///\n  Failed(String)\n}\n\ntype Self(state, msg) {\n  Self(\n    mode: Mode,\n    parent: Pid,\n    state: state,\n    selector: Selector(Message(msg)),\n    debug_state: DebugState,\n    message_handler: fn(msg, state) -> Next(state),\n  )\n}\n\n/// This data structure holds all the values required by the `start_spec`\n/// function in order to create an actor.\n///\n/// If you do not need to configure the initialisation behaviour of your actor\n/// consider using the `start` function.\n///\npub type Spec(state, msg) {\n  Spec(\n    /// The initialisation functionality for the actor. This function is called\n    /// just after the actor starts but before the channel sender is returned\n    /// to the parent.\n    ///\n    /// This function is used to ensure that any required data or state is\n    /// correct. If this function returns an error it means that the actor has\n    /// failed to start and an error is returned to the parent.\n    ///\n    init: fn() -> InitResult(state, msg),\n    /// How many milliseconds the `init` function has to return before it is\n    /// considered to have taken too long and failed.\n    ///\n    init_timeout: Int,\n    /// This function is called to handle each message that the actor receives.\n    ///\n    loop: fn(msg, state) -> Next(state),\n  )\n}\n\n// TODO: Check needed functionality here to be OTP compatible\nfn exit_process(reason: ExitReason) -> ExitReason {\n  // TODO\n  reason\n}\n\nfn receive_message(self: Self(state, msg)) -> Message(msg) {\n  let selector = case self.mode {\n    // When suspended we only respond to system messages\n    Suspended ->\n      process.new_selector()\n      |> selecting_system_messages\n\n    // When running we respond to all messages\n    Running ->\n      // We add the handler for unexpected messages first so that the user\n      // supplied selector can override it if desired\n      process.new_selector()\n      |> process.selecting_anything(Unexpected)\n      |> process.merge_selector(self.selector)\n      |> selecting_system_messages\n  }\n\n  process.select_forever(selector)\n}\n\nfn selecting_system_messages(\n  selector: Selector(Message(msg)),\n) -> Selector(Message(msg)) {\n  selector\n  |> process.selecting_record3(\n    atom.create_from_string(\"system\"),\n    convert_system_message,\n  )\n}\n\nexternal fn convert_system_message(Dynamic, Dynamic) -> Message(msg) =\n  \"gleam_otp_external\" \"convert_system_message\"\n\nfn process_status_info(self: Self(state, msg)) -> StatusInfo {\n  StatusInfo(\n    module: atom.create_from_string(\"gleam@otp@actor\"),\n    parent: self.parent,\n    mode: self.mode,\n    debug_state: self.debug_state,\n    state: dynamic.from(self.state),\n  )\n}\n\nfn loop(self: Self(state, msg)) -> ExitReason {\n  case receive_message(self) {\n    System(system) ->\n      case system {\n        GetState(callback) -> {\n          callback(dynamic.from(self.state))\n          loop(self)\n        }\n        Resume(callback) -> {\n          callback()\n          loop(Self(..self, mode: Running))\n        }\n        Suspend(callback) -> {\n          callback()\n          loop(Self(..self, mode: Suspended))\n        }\n        GetStatus(callback) -> {\n          callback(process_status_info(self))\n          loop(self)\n        }\n      }\n\n    Unexpected(message) -> {\n      log_warning(\n        charlist.from_string(\"Actor discarding unexpected message: ~s\"),\n        [charlist.from_string(string.inspect(message))],\n      )\n      loop(self)\n    }\n\n    Message(msg) ->\n      case self.message_handler(msg, self.state) {\n        Stop(reason) -> exit_process(reason)\n        Continue(state) -> loop(Self(..self, state: state))\n      }\n  }\n}\n\n// TODO: replace this when we have Gleam bindings to the logger\nexternal fn log_warning(Charlist, List(Charlist)) -> Nil =\n  \"logger\" \"warning\"\n\nfn initialise_actor(\n  spec: Spec(state, msg),\n  ack: Subject(Result(Subject(msg), ExitReason)),\n) {\n  let subject = process.new_subject()\n  case spec.init() {\n    Ready(state, selector) -> {\n      let selector =\n        process.new_selector()\n        |> process.selecting(subject, Message)\n        |> process.merge_selector(process.map_selector(selector, Message))\n      // Signal to parent that the process has initialised successfully\n      process.send(ack, Ok(subject))\n      // Start message receive loop\n      let self =\n        Self(\n          state: state,\n          parent: process.subject_owner(ack),\n          selector: selector,\n          message_handler: spec.loop,\n          debug_state: system.debug_state([]),\n          mode: Running,\n        )\n      loop(self)\n    }\n\n    Failed(reason) -> {\n      process.send(ack, Error(Abnormal(reason)))\n      exit_process(Abnormal(reason))\n    }\n  }\n}\n\npub type StartError {\n  InitTimeout\n  InitFailed(ExitReason)\n  InitCrashed(Dynamic)\n}\n\n/// The result of starting a Gleam actor.\n///\n/// This type is compatible with Gleam supervisors. If you wish to convert it\n/// to a type compatible with Erlang supervisors see the `ErlangStartResult`\n/// type and `erlang_start_result` function.\n///\npub type StartResult(msg) =\n  Result(Subject(msg), StartError)\n\n/// An Erlang supervisor compatible process start result.\n///\n/// If you wish to convert this into a `StartResult` compatible with Gleam\n/// supervisors see the `from_erlang_start_result` and `wrap_erlang_starter`\n/// functions.\n///\npub type ErlangStartResult =\n  Result(Pid, Dynamic)\n\n/// Convert a Gleam actor start result into an Erlang supervisor compatible\n/// process start result.\n///\npub fn to_erlang_start_result(res: StartResult(msg)) -> ErlangStartResult {\n  case res {\n    Ok(x) -> Ok(process.subject_owner(x))\n    Error(x) -> Error(dynamic.from(x))\n  }\n}\n\ntype StartInitMessage(msg) {\n  Ack(Result(Subject(msg), ExitReason))\n  Mon(process.ProcessDown)\n}\n\n// TODO: test init_timeout. Currently if we test it eunit prints an error from\n// the process death. How do we avoid this?\n//\n/// Start an actor from a given specification. If the actor's `init` function\n/// returns an error or does not return within `init_timeout` then an error is\n/// returned.\n///\n/// If you do not need to specify the initialisation behaviour of your actor\n/// consider using the `start` function.\n///\npub fn start_spec(spec: Spec(state, msg)) -> Result(Subject(msg), StartError) {\n  let ack_subject = process.new_subject()\n\n  let child =\n    process.start(\n      linked: True,\n      running: fn() { initialise_actor(spec, ack_subject) },\n    )\n\n  let monitor = process.monitor_process(child)\n  let selector =\n    process.new_selector()\n    |> process.selecting(ack_subject, Ack)\n    |> process.selecting_process_down(monitor, Mon)\n\n  let result = case process.select(selector, spec.init_timeout) {\n    // Child started OK\n    Ok(Ack(Ok(channel))) -> Ok(channel)\n\n    // Child initialiser returned an error\n    Ok(Ack(Error(reason))) -> Error(InitFailed(reason))\n\n    // Child went down while initialising\n    Ok(Mon(down)) -> Error(InitCrashed(down.reason))\n\n    // Child did not finish initialising in time\n    Error(Nil) -> {\n      process.kill(child)\n      Error(InitTimeout)\n    }\n  }\n\n  // Remove the monitor used for the starting of the actor as to avoid an extra\n  // message arriving at the parent if the child dies later.\n  process.demonitor_process(monitor)\n\n  result\n}\n\n/// Start an actor with a given initial state and message handling loop\n/// function.\n///\n/// This function returns a `Result` but it will always be `Ok` so it is safe\n/// to use with `assert` if you are not starting this actor as part of a\n/// supervision tree.\n///\n/// If you wish to configure the initialisation behaviour of a new actor see\n/// the `Spec` record and the `start_spec` function.\n///\npub fn start(\n  state: state,\n  loop: fn(msg, state) -> Next(state),\n) -> Result(Subject(msg), StartError) {\n  start_spec(Spec(\n    init: fn() { Ready(state, process.new_selector()) },\n    loop: loop,\n    init_timeout: 5000,\n  ))\n}\n\n/// Send a message over a given channel.\n///\n/// This is a re-export of `process.send`, for the sake of convenience.\n///\npub fn send(subject: Subject(msg), msg: msg) -> Nil {\n  process.send(subject, msg)\n}\n\n// TODO: test\n/// Send a synchronous message and wait for a response from the receiving\n/// process.\n///\n/// If a reply is not received within the given timeout then the sender process\n/// crashes. If you wish receive a `Result` rather than crashing see the\n/// `process.try_call` function.\n///\n/// This is a re-export of `process.call`, for the sake of convenience.\n///\npub fn call(\n  selector: Subject(message),\n  make_message: fn(Subject(reply)) -> message,\n  timeout: Int,\n) -> reply {\n  process.call(selector, make_message, timeout)\n}\n" (Durability(0))    
2023-08-04T09:30:46.268643Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268651Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R119    
2023-08-04T09:30:46.268660Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(23)) = "pub external type Node\n" (Durability(0))    
2023-08-04T09:30:46.268669Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268677Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R120    
2023-08-04T09:30:46.268686Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(24)) = "// TODO: specify amount of time permitted for shut-down\nimport gleam/result\nimport gleam/string\nimport gleam/option.{None, Option, Some}\nimport gleam/erlang/process.{Pid, Subject}\nimport gleam/otp/actor.{StartError}\nimport gleam/otp/intensity_tracker.{IntensityTracker}\nimport gleam/otp/node.{Node}\n\n/// This data structure holds all the values required by the `start_spec`\n/// function in order to create an supervisor.\n///\n/// If you do not need to configure the behaviour of your supervisor consider\n/// using the `start` function.\n///\npub type Spec(argument, return) {\n  Spec(\n    argument: argument,\n    max_frequency: Int,\n    frequency_period: Int,\n    init: fn(Children(argument)) -> Children(return),\n  )\n}\n\n/// This type represents the starting children of a supervisor within the\n/// `init` function.\n///\npub opaque type Children(argument) {\n  Ready(Starter(argument))\n  Failed(ChildStartError)\n}\n\n/// This type contains all the information required to start a new child and\n/// add it to the `Children`.\n///\n/// This is typically created with the `worker` function.\n///\npub opaque type ChildSpec(msg, argument, returning) {\n  ChildSpec(\n    // TODO: merge this into one field\n    start: fn(argument) -> Result(Subject(msg), StartError),\n    returning: fn(argument, Subject(msg)) -> returning,\n  )\n}\n\ntype ChildStartError {\n  ChildStartError(previous_pid: Option(Pid), error: StartError)\n}\n\npub opaque type Message {\n  Exit(process.ExitMessage)\n  RetryRestart(Pid)\n}\n\ntype Instruction {\n  StartAll\n  StartFrom(Pid)\n}\n\ntype State(a) {\n  State(\n    restarts: IntensityTracker,\n    starter: Starter(a),\n    retry_restarts: Subject(Pid),\n  )\n}\n\ntype Starter(argument) {\n  Starter(\n    argument: argument,\n    exec: Option(\n      fn(Instruction) ->\n        Result(#(Starter(argument), Instruction), ChildStartError),\n    ),\n  )\n}\n\ntype Child(argument) {\n  Child(pid: Pid, argument: argument)\n}\n\nfn start_child(\n  child_spec: ChildSpec(msg, argument_in, argument_out),\n  argument: argument_in,\n) -> Result(Child(argument_out), ChildStartError) {\n  use subject <- result.then(\n    child_spec.start(argument)\n    |> result.map_error(ChildStartError(None, _)),\n  )\n\n  Ok(Child(\n    pid: process.subject_owner(subject),\n    // Merge the new child's pid into the argument to produce the new argument\n    // used to start any remaining children.\n    argument: child_spec.returning(argument, subject),\n  ))\n}\n\n// TODO: more sophsiticated stopping of processes. i.e. give supervisors\n// more time to shut down.\nfn shutdown_child(pid: Pid, _spec: ChildSpec(msg, arg_1, arg_2)) -> Nil {\n  process.send_exit(pid)\n}\n\nfn perform_instruction_for_child(\n  argument: argument_in,\n  instruction: Instruction,\n  child_spec: ChildSpec(msg, argument_in, argument_out),\n  child: Child(argument_out),\n) -> Result(#(Child(argument_out), Instruction), ChildStartError) {\n  let current = child.pid\n  case instruction {\n    // This child is older than the StartFrom target, we don't need to\n    // restart it\n    StartFrom(target) if target != current -> Ok(#(child, instruction))\n\n    // This pid either is the cause of the problem, or we have the StartAll\n    // instruction. Either way it and its younger siblings need to be restarted.\n    _ -> {\n      shutdown_child(current, child_spec)\n      use child <- result.then(start_child(child_spec, argument))\n      Ok(#(child, StartAll))\n    }\n  }\n}\n\nfn add_child_to_starter(\n  starter: Starter(argument_in),\n  child_spec: ChildSpec(msg, argument_in, argument_out),\n  child: Child(argument_out),\n) -> Starter(argument_out) {\n  let starter = fn(instruction) {\n    // Restart the older children. We use `try` to return early if the older\n    // children failed to start\n    use #(starter, instruction) <- result.then(case starter.exec {\n      Some(start) -> start(instruction)\n      None -> Ok(#(starter, instruction))\n    })\n\n    // Perform the instruction, restarting the child as required\n    use #(child, instruction) <- result.then(perform_instruction_for_child(\n      starter.argument,\n      instruction,\n      child_spec,\n      child,\n    ))\n\n    // Create a new starter for the next time the supervisor needs to restart\n    let starter = add_child_to_starter(starter, child_spec, child)\n\n    Ok(#(starter, instruction))\n  }\n\n  Starter(exec: Some(starter), argument: child.argument)\n}\n\nfn start_and_add_child(\n  state: Starter(argument_0),\n  child_spec: ChildSpec(msg, argument_0, argument_1),\n) -> Children(argument_1) {\n  case start_child(child_spec, state.argument) {\n    Ok(child) -> Ready(add_child_to_starter(state, child_spec, child))\n    Error(reason) -> Failed(reason)\n  }\n}\n\n/// Add a child to the collection of children of the supervisor\n///\n/// This function starts the child from the child spec.\n///\npub fn add(\n  children: Children(argument),\n  child_spec: ChildSpec(msg, argument, new_argument),\n) -> Children(new_argument) {\n  case children {\n    // If one of the previous children has failed then we cannot continue\n    Failed(fail) -> Failed(fail)\n\n    // If everything is OK so far then we can add the child\n    Ready(state) -> start_and_add_child(state, child_spec)\n  }\n}\n\n// TODO: test\n// TODO: unlimitd shut down duration\n/// Prepare a new supervisor type child.\n///\n/// If you wish to prepare a new non-supervisor type child see the `worker`\n/// function.\n///\n/// If you wish to change the type of the argument for later children see the\n/// `returning` function.\n///\n/// Note: Gleam supervisors do not yet support different shutdown periods per\n/// child so this function is currently identical in behaviour to `worker`. It is\n/// recommended to use this function for supervisor children nevertheless so the\n/// correct shut down behaviour is used in later releases of this library.\n///\npub fn supervisor(\n  start: fn(argument) -> Result(Subject(msg), StartError),\n) -> ChildSpec(msg, argument, argument) {\n  ChildSpec(start: start, returning: fn(argument, _channel) { argument })\n}\n\n/// Prepare a new worker type child.\n///\n/// If you wish to prepare a new supervisor type child see the `supervisor`\n/// function.\n///\n/// If you wish to change the type of the argument for later children see the\n/// `returning` function.\n///\npub fn worker(\n  start: fn(argument) -> Result(Subject(msg), StartError),\n) -> ChildSpec(msg, argument, argument) {\n  ChildSpec(start: start, returning: fn(argument, _channel) { argument })\n}\n\n// TODO: test\n/// As each child is added to a supervisors children a new argument is prepared\n/// with which to start the next child. By default argument is the same as the\n/// previous argument, but this function can be used to change it to something\n/// else by passing a function that takes the previous argument and the sender\n/// of the previous child.\n///\npub fn returning(\n  child: ChildSpec(msg, argument_a, argument_b),\n  updater: fn(argument_a, Subject(msg)) -> argument_c,\n) -> ChildSpec(msg, argument_a, argument_c) {\n  ChildSpec(start: child.start, returning: updater)\n}\n\nfn init(\n  spec: Spec(argument, return),\n) -> actor.InitResult(State(return), Message) {\n  // Create a subject so that we can asynchronously retry restarting when we\n  // fail to bring an exited child\n  let retry = process.new_subject()\n\n  // Trap exits so that we get a message when a child crashes\n  process.trap_exits(True)\n\n  // Combine selectors\n  let selector =\n    process.new_selector()\n    |> process.selecting(retry, RetryRestart)\n    |> process.selecting_trapped_exits(Exit)\n\n  // Start any children\n  let result =\n    Starter(argument: spec.argument, exec: None)\n    |> Ready\n    |> spec.init\n\n  // Pass back up the result\n  case result {\n    Ready(starter) -> {\n      let restarts =\n        intensity_tracker.new(\n          limit: spec.max_frequency,\n          period: spec.frequency_period,\n        )\n      let state =\n        State(starter: starter, restarts: restarts, retry_restarts: retry)\n      actor.Ready(state, selector)\n    }\n\n    Failed(error) ->\n      actor.Failed(case error.error {\n        actor.InitTimeout -> \"Child initialisation timed out\"\n        actor.InitCrashed(reason) ->\n          string.append(\n            \"Child crashed during initialisation: \",\n            string.inspect(reason),\n          )\n        actor.InitFailed(reason) ->\n          string.append(\n            \"Child failed to start during initialisation: \",\n            string.inspect(reason),\n          )\n      })\n  }\n}\n\ntype HandleExitError {\n  RestartFailed(pid: Pid, restarts: IntensityTracker)\n  TooManyRestarts\n}\n\nfn handle_exit(pid: Pid, state: State(a)) -> actor.Next(State(a)) {\n  let outcome = {\n    // If we are handling an exit then we must have some children\n    let assert Some(start) = state.starter.exec\n\n    // Check to see if there has been too many restarts in this period\n    use restarts <- result.then(\n      state.restarts\n      |> intensity_tracker.add_event\n      |> result.map_error(fn(_) { TooManyRestarts }),\n    )\n\n    // Restart the exited child and any following children\n    use #(starter, _) <- result.then(\n      start(StartFrom(pid))\n      |> result.map_error(fn(e: ChildStartError) {\n        RestartFailed(option.unwrap(e.previous_pid, pid), restarts)\n      }),\n    )\n\n    Ok(State(..state, starter: starter, restarts: restarts))\n  }\n\n  case outcome {\n    Ok(state) -> actor.Continue(state)\n    Error(RestartFailed(failed_child, restarts)) -> {\n      // Asynchronously enqueue the restarting of this child again as we were\n      // unable to restart them this time. We do this asynchronously as we want\n      // to have a chance to handle any system messages that have come in.\n      process.send(state.retry_restarts, failed_child)\n      let state = State(..state, restarts: restarts)\n      actor.Continue(state)\n    }\n    Error(TooManyRestarts) ->\n      actor.Stop(process.Abnormal(\n        \"Child processes restarted too many times within allowed period\",\n      ))\n  }\n}\n\nfn loop(message: Message, state: State(argument)) -> actor.Next(State(argument)) {\n  case message {\n    Exit(exit_message) -> handle_exit(exit_message.pid, state)\n    RetryRestart(pid) -> handle_exit(pid, state)\n  }\n}\n\n/// Start a supervisor from a given specification.\n///\npub fn start_spec(spec: Spec(a, b)) -> Result(Subject(Message), StartError) {\n  actor.start_spec(actor.Spec(\n    init: fn() { init(spec) },\n    loop: loop,\n    init_timeout: 60_000,\n  ))\n}\n\n/// Start a supervisor from a given `init` function.\n///\n/// If you wish to have more control over the configuration of the supervisor\n/// see the `start_spec` function.\n///\npub fn start(\n  init: fn(Children(Nil)) -> Children(a),\n) -> Result(Subject(Message), StartError) {\n  start_spec(Spec(\n    init: init,\n    argument: Nil,\n    max_frequency: 5,\n    frequency_period: 1,\n  ))\n}\n\n/// A type used to describe the situation in which an Erlang based application\n/// is starting.\n///\n/// For more information see the [Erlang distributed application\n/// documentation][1] and the Learn Your Some Erlang chapter on [distributed\n/// applications][2].\n///\n/// [1]: https://erlang.org/doc/design_principles/distributed_applications.html\n/// [2]: https://learnyousomeerlang.com/distributed-otp-applications\n///\npub type ApplicationStartMode {\n  Normal\n  Takeover(Node)\n  Failover(Node)\n}\n\npub external type ApplicationStop\n\npub external fn application_stopped() -> ApplicationStop =\n  \"gleam_otp_external\" \"application_stopped\"\n\n/// The result of starting a Gleam actor.\n///\n/// This type is compatible with Gleam supervisors. If you wish to convert it\n/// to a type compatible with Erlang supervisors see the `ErlangStartResult`\n/// type and `erlang_start_result` function.\n///\npub type StartResult(msg) =\n  actor.StartResult(msg)\n\n/// An Erlang supervisor compatible process start result.\n///\npub type ErlangStartResult =\n  actor.ErlangStartResult\n\n/// Convert a Gleam actor start result into an Erlang supervisor compatible\n/// process start result.\n///\npub fn to_erlang_start_result(res: StartResult(msg)) -> ErlangStartResult {\n  actor.to_erlang_start_result(res)\n}\n" (Durability(0))    
2023-08-04T09:30:46.268845Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268853Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R121    
2023-08-04T09:30:46.268862Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(25)) = "/// Ports are how code running on the Erlang virtual machine interacts with\n/// the outside world. Bytes of data can be sent to and read from ports,\n/// providing a form of message passing to an external program or resource.\n///\n/// For more information on ports see the [Erlang ports documentation][1].\n///\n/// [1]: https://erlang.org/doc/reference_manual/ports.html\n///\npub external type Port\n" (Durability(0))    
2023-08-04T09:30:46.268877Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268885Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R122    
2023-08-04T09:30:46.268894Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(26)) = "//// Working with raw bit string data.\n//// The `BitString` type should be used instead of a String type when not utf8\n//// encoded.\n\n/// Converts a UTF-8 `String` type into a raw `BitString` type.\n///\npub fn from_string(x: String) -> BitString {\n  do_from_string(x)\n}\n\nif erlang {\n  external fn do_from_string(String) -> BitString =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn do_from_string(String) -> BitString =\n    \"../gleam_stdlib.mjs\" \"bit_string_from_string\"\n}\n\n/// Returns an integer which is the number of bytes in the bit string.\n///\npub fn byte_size(x: BitString) -> Int {\n  do_byte_size(x)\n}\n\nif erlang {\n  external fn do_byte_size(BitString) -> Int =\n    \"erlang\" \"byte_size\"\n}\n\nif javascript {\n  external fn do_byte_size(BitString) -> Int =\n    \"../gleam_stdlib.mjs\" \"length\"\n}\n\n/// Creates a new bit string by joining two binaries.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > append(to: from_string(\"butter\"), suffix: from_string(\"fly\"))\n/// from_string(\"butterfly\")\n/// ```\n///\npub fn append(to first: BitString, suffix second: BitString) -> BitString {\n  concat([first, second])\n}\n\n/// Extracts a sub-section of a bit string.\n///\n/// The slice will start at given position and continue up to specified\n/// length.\n/// A negative length can be used to extract bytes at the end of a bit string.\n///\n/// This function runs in constant time.\n///\npub fn slice(\n  from string: BitString,\n  at position: Int,\n  take length: Int,\n) -> Result(BitString, Nil) {\n  do_slice(string, position, length)\n}\n\nif erlang {\n  external fn do_slice(\n    string: BitString,\n    position: Int,\n    length: Int,\n  ) -> Result(BitString, Nil) =\n    \"gleam_stdlib\" \"bit_string_slice\"\n}\n\nif javascript {\n  external fn do_slice(\n    string: BitString,\n    position: Int,\n    length: Int,\n  ) -> Result(BitString, Nil) =\n    \"../gleam_stdlib.mjs\" \"bit_string_slice\"\n}\n\n/// Tests to see whether a bit string is valid UTF-8.\n///\npub fn is_utf8(bits: BitString) -> Bool {\n  do_is_utf8(bits)\n}\n\nif erlang {\n  fn do_is_utf8(bits: BitString) -> Bool {\n    case bits {\n      <<>> -> True\n      <<_:utf8, rest:binary>> -> do_is_utf8(rest)\n      _ -> False\n    }\n  }\n}\n\nif javascript {\n  fn do_is_utf8(bits: BitString) -> Bool {\n    case to_string(bits) {\n      Ok(_) -> True\n      _ -> False\n    }\n  }\n}\n\n/// Converts a bit string to a string.\n///\n/// Returns an error if the bit string is invalid UTF-8 data.\n///\npub fn to_string(bits: BitString) -> Result(String, Nil) {\n  do_to_string(bits)\n}\n\nif erlang {\n  external fn unsafe_to_string(BitString) -> String =\n    \"gleam_stdlib\" \"identity\"\n\n  fn do_to_string(bits: BitString) -> Result(String, Nil) {\n    case is_utf8(bits) {\n      True -> Ok(unsafe_to_string(bits))\n      False -> Error(Nil)\n    }\n  }\n}\n\nif javascript {\n  external fn do_to_string(BitString) -> Result(String, Nil) =\n    \"../gleam_stdlib.mjs\" \"bit_string_to_string\"\n}\n\n/// Creates a new bit string by joining multiple binaries.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > concat([from_string(\"butter\"), from_string(\"fly\")])\n/// from_string(\"butterfly\")\n/// ```\n///\npub fn concat(bit_strings: List(BitString)) -> BitString {\n  do_concat(bit_strings)\n}\n\nif erlang {\n  external fn do_concat(List(BitString)) -> BitString =\n    \"gleam_stdlib\" \"bit_string_concat\"\n}\n\nif javascript {\n  external fn do_concat(List(BitString)) -> BitString =\n    \"../gleam_stdlib.mjs\" \"bit_string_concat\"\n}\n" (Durability(0))    
2023-08-04T09:30:46.268956Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.268965Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R123    
2023-08-04T09:30:46.268973Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(27)) = "//// Lists are an ordered sequence of elements and are one of the most common\n//// data types in Gleam.\n////\n//// New elements can be added and removed from the front of a list in\n//// constant time, while adding and removing from the end requires traversing\n//// the copying the whole list, so keep this in mind when designing your\n//// programs.\n////\n//// There is a dedicated syntax for prefixing to a list:\n////\n//// ```gleam\n//// let new_list = [1, 2, ..existing_list]\n//// ```\n////\n//// And a matching syntax for getting the first elements of a list:\n////\n//// ```gleam\n//// case list {\n////   [first_element, ..rest] -> first_element\n////   _ -> \"this pattern matches when the list is empty\"\n//// }\n//// ```\n////\n\nimport gleam/int\nimport gleam/float\nimport gleam/order.{Order}\nimport gleam/pair\nimport gleam/map.{Map}\n\n/// An error value returned by the `strict_zip` function.\n///\npub type LengthMismatch {\n  LengthMismatch\n}\n\n/// Counts the number of elements in a given list.\n///\n/// This function has to traverse the list to determine the number of elements,\n/// so it runs in linear time.\n///\n/// This function is natively implemented by the virtual machine and is highly\n/// optimised.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > length([])\n/// 0\n/// ```\n///\n/// ```gleam\n/// > length([1])\n/// 1\n/// ```\n///\n/// ```gleam\n/// > length([1, 2])\n/// 2\n/// ```\n///\npub fn length(of list: List(a)) -> Int {\n  do_length(list)\n}\n\nif erlang {\n  external fn do_length(List(a)) -> Int =\n    \"erlang\" \"length\"\n}\n\nif javascript {\n  fn do_length(list: List(a)) -> Int {\n    do_length_acc(list, 0)\n  }\n\n  fn do_length_acc(list: List(a), count: Int) -> Int {\n    case list {\n      [_, ..list] -> do_length_acc(list, count + 1)\n      _ -> count\n    }\n  }\n}\n\n/// Creates a new list from a given list containing the same elements but in the\n/// opposite order.\n///\n/// This function has to traverse the list to create the new reversed list, so\n/// it runs in linear time.\n///\n/// This function is natively implemented by the virtual machine and is highly\n/// optimised.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > reverse([])\n/// []\n/// ```\n///\n/// ```gleam\n/// > reverse([1])\n/// [1]\n/// ```\n///\n/// ```gleam\n/// > reverse([1, 2])\n/// [2, 1]\n/// ```\n///\npub fn reverse(xs: List(a)) -> List(a) {\n  do_reverse(xs)\n}\n\nif erlang {\n  external fn do_reverse(List(a)) -> List(a) =\n    \"lists\" \"reverse\"\n}\n\nif javascript {\n  fn do_reverse(list) {\n    do_reverse_acc(list, [])\n  }\n\n  fn do_reverse_acc(remaining, accumulator) {\n    case remaining {\n      [] -> accumulator\n      [item, ..rest] -> do_reverse_acc(rest, [item, ..accumulator])\n    }\n  }\n}\n\n/// Determines whether or not the list is empty.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_empty([])\n/// True\n/// ```\n///\n/// ```gleam\n/// > is_empty([1])\n/// False\n/// ```\n///\n/// ```gleam\n/// > is_empty([1, 1])\n/// False\n/// ```\n///\npub fn is_empty(list: List(a)) -> Bool {\n  list == []\n}\n\n/// Determines whether or not a given element exists within a given list.\n///\n/// This function traverses the list to find the element, so it runs in linear\n/// time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [] |> contains(any: 0)\n/// False\n/// ```\n///\n/// ```gleam\n/// > [0] |> contains(any: 0)\n/// True\n/// ```\n///\n/// ```gleam\n/// > [1] |> contains(any: 0)\n/// False\n/// ```\n///\n/// ```gleam\n/// > [1, 1] |> contains(any: 0)\n/// False\n/// ```\n///\n/// ```gleam\n/// > [1, 0] |> contains(any: 0)\n/// True\n/// ```\n///\npub fn contains(list: List(a), any elem: a) -> Bool {\n  case list {\n    [] -> False\n    [first, ..] if first == elem -> True\n    [_, ..rest] -> contains(rest, elem)\n  }\n}\n\n/// Gets the first element from the start of the list, if there is one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > first([])\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > first([0])\n/// Ok(0)\n/// ```\n///\n/// ```gleam\n/// > first([1, 2])\n/// Ok(1)\n/// ```\n///\npub fn first(list: List(a)) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [x, ..] -> Ok(x)\n  }\n}\n\n/// Returns the list minus the first element. If the list is empty, `Error(Nil)` is\n/// returned.\n///\n/// This function runs in constant time and does not make a copy of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > rest([])\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > rest([0])\n/// Ok([])\n/// ```\n///\n/// ```gleam\n/// > rest([1, 2])\n/// Ok([2])\n/// ```\n///\npub fn rest(list: List(a)) -> Result(List(a), Nil) {\n  case list {\n    [] -> Error(Nil)\n    [_, ..xs] -> Ok(xs)\n  }\n}\n\nfn update_group(\n  f: fn(element) -> key,\n) -> fn(Map(key, List(element)), element) -> Map(key, List(element)) {\n  fn(groups, elem) {\n    case map.get(groups, f(elem)) {\n      Ok(existing) -> map.insert(groups, f(elem), [elem, ..existing])\n      Error(_) -> map.insert(groups, f(elem), [elem])\n    }\n  }\n}\n\n/// Takes a list and groups the values by a key\n/// which is built from a key function.\n///\n/// Does not preserve the initial value order.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [Ok(3), Error(\"Wrong\"), Ok(200), Ok(73)]\n///   |> group(by: fn(i) {\n///     case i {\n///       Ok(_) -> \"Successful\"\n///       Error(_) -> \"Failed\"\n///     }\n///   })\n///   |> map.to_list\n///\n/// [\n///   #(\"Failed\", [Error(\"Wrong\")]),\n///   #(\"Successful\", [Ok(73), Ok(200), Ok(3)])\n/// ]\n///\n/// > group(from: [1,2,3,4,5], with: fn(i) {fn(i) { i - i / 3 * 3 }})\n/// |> map.to_list\n/// [#(0, [3]), #(1, [4, 1]), #(2, [5, 2])]\n/// ```\n///\npub fn group(list: List(v), by key: fn(v) -> k) -> Map(k, List(v)) {\n  fold(list, map.new(), update_group(key))\n}\n\nfn do_filter(list: List(a), fun: fn(a) -> Bool, acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> {\n      let new_acc = case fun(x) {\n        True -> [x, ..acc]\n        False -> acc\n      }\n      do_filter(xs, fun, new_acc)\n    }\n  }\n}\n\n/// Returns a new list containing only the elements from the first list for\n/// which the given functions returns `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > filter([2, 4, 6, 1], fn(x) { x > 2 })\n/// [4, 6]\n/// ```\n///\n/// ```gleam\n/// > filter([2, 4, 6, 1], fn(x) { x > 6 })\n/// []\n/// ```\n///\npub fn filter(list: List(a), for predicate: fn(a) -> Bool) -> List(a) {\n  do_filter(list, predicate, [])\n}\n\nfn do_filter_map(\n  list: List(a),\n  fun: fn(a) -> Result(b, e),\n  acc: List(b),\n) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> {\n      let new_acc = case fun(x) {\n        Ok(x) -> [x, ..acc]\n        Error(_) -> acc\n      }\n      do_filter_map(xs, fun, new_acc)\n    }\n  }\n}\n\n/// Returns a new list containing only the elements from the first list for\n/// which the given functions returns `Ok(_)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > filter_map([2, 4, 6, 1], Error)\n/// []\n/// ```\n///\n/// ```gleam\n/// > filter_map([2, 4, 6, 1], fn(x) { Ok(x + 1) })\n/// [3, 5, 7, 2]\n/// ```\n///\npub fn filter_map(list: List(a), with fun: fn(a) -> Result(b, e)) -> List(b) {\n  do_filter_map(list, fun, [])\n}\n\nfn do_map(list: List(a), fun: fn(a) -> b, acc: List(b)) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> do_map(xs, fun, [fun(x), ..acc])\n  }\n}\n\n/// Returns a new list containing only the elements of the first list after the\n/// function has been applied to each one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > map([2, 4, 6], fn(x) { x * 2 })\n/// [4, 8, 12]\n/// ```\n///\npub fn map(list: List(a), with fun: fn(a) -> b) -> List(b) {\n  do_map(list, fun, [])\n}\n\n/// Similar to `map` but also lets you pass around an accumulated value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > map_fold(\n///     over: [1, 2, 3],\n///     from: 100,\n///     with: fn(memo, i) { #(memo + i, i * 2) }\n///   )\n/// #(106, [2, 4, 6])\n/// ```\n///\npub fn map_fold(\n  over list: List(a),\n  from acc: acc,\n  with fun: fn(acc, a) -> #(acc, b),\n) -> #(acc, List(b)) {\n  fold(\n    over: list,\n    from: #(acc, []),\n    with: fn(acc, item) {\n      let #(current_acc, items) = acc\n      let #(next_acc, next_item) = fun(current_acc, item)\n      #(next_acc, [next_item, ..items])\n    },\n  )\n  |> pair.map_second(reverse)\n}\n\nfn do_index_map(\n  list: List(a),\n  fun: fn(Int, a) -> b,\n  index: Int,\n  acc: List(b),\n) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> {\n      let acc = [fun(index, x), ..acc]\n      do_index_map(xs, fun, index + 1, acc)\n    }\n  }\n}\n\n/// Returns a new list containing only the elements of the first list after the\n/// function has been applied to each one and their index.\n///\n/// The index starts at 0, so the first element is 0, the second is 1, and so\n/// on.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > index_map([\"a\", \"b\"], fn(i, x) { #(i, x) })\n/// [#(0, \"a\"), #(1, \"b\")]\n/// ```\n///\npub fn index_map(list: List(a), with fun: fn(Int, a) -> b) -> List(b) {\n  do_index_map(list, fun, 0, [])\n}\n\nfn do_try_map(\n  list: List(a),\n  fun: fn(a) -> Result(b, e),\n  acc: List(b),\n) -> Result(List(b), e) {\n  case list {\n    [] -> Ok(reverse(acc))\n    [x, ..xs] ->\n      case fun(x) {\n        Ok(y) -> do_try_map(xs, fun, [y, ..acc])\n        Error(error) -> Error(error)\n      }\n  }\n}\n\n/// Takes a function that returns a `Result` and applies it to each element in a\n/// given list in turn.\n///\n/// If the function returns `Ok(new_value)` for all elements in the list then a\n/// list of the new values is returned.\n///\n/// If the function returns `Error(reason)` for any of the elements then it is\n/// returned immediately. None of the elements in the list are processed after\n/// one returns an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > try_map([1, 2, 3], fn(x) { Ok(x + 2) })\n/// Ok([3, 4, 5])\n/// ```\n///\n/// ```gleam\n/// > try_map([1, 2, 3], fn(_) { Error(0) })\n/// Error(0)\n/// ```\n///\n/// ```gleam\n/// > try_map([[1], [2, 3]], first)\n/// Ok([1, 2])\n/// ```\n///\n/// ```gleam\n/// > try_map([[1], [], [2]], first)\n/// Error(Nil)\n/// ```\n///\npub fn try_map(\n  over list: List(a),\n  with fun: fn(a) -> Result(b, e),\n) -> Result(List(b), e) {\n  do_try_map(list, fun, [])\n}\n\n/// Returns a list that is the given list with up to the given number of\n/// elements removed from the front of the list.\n///\n/// If the element has less than the number of elements an empty list is\n/// returned.\n///\n/// This function runs in linear time but does not copy the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > drop([1, 2, 3, 4], 2)\n/// [3, 4]\n/// ```\n///\n/// ```gleam\n/// > drop([1, 2, 3, 4], 9)\n/// []\n/// ```\n///\npub fn drop(from list: List(a), up_to n: Int) -> List(a) {\n  case n <= 0 {\n    True -> list\n    False ->\n      case list {\n        [] -> []\n        [_, ..xs] -> drop(xs, n - 1)\n      }\n  }\n}\n\nfn do_take(list: List(a), n: Int, acc: List(a)) -> List(a) {\n  case n <= 0 {\n    True -> reverse(acc)\n    False ->\n      case list {\n        [] -> reverse(acc)\n        [x, ..xs] -> do_take(xs, n - 1, [x, ..acc])\n      }\n  }\n}\n\n/// Returns a list containing the first given number of elements from the given\n/// list.\n///\n/// If the element has less than the number of elements then the full list is\n/// returned.\n///\n/// This function runs in linear time but does not copy the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > take([1, 2, 3, 4], 2)\n/// [1, 2]\n/// ```\n///\n/// ```gleam\n/// > take([1, 2, 3, 4], 9)\n/// [1, 2, 3, 4]\n/// ```\n///\npub fn take(from list: List(a), up_to n: Int) -> List(a) {\n  do_take(list, n, [])\n}\n\n/// Returns a new empty list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new()\n/// []\n/// ```\n///\npub fn new() -> List(a) {\n  []\n}\n\n/// Joins one list onto the end of another.\n///\n/// This function runs in linear time, and it traverses and copies the first\n/// list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > append([1, 2], [3])\n/// [1, 2, 3]\n/// ```\n///\npub fn append(first: List(a), second: List(a)) -> List(a) {\n  do_append(first, second)\n}\n\nif erlang {\n  external fn do_append(List(a), List(a)) -> List(a) =\n    \"lists\" \"append\"\n}\n\nif javascript {\n  fn do_append(first: List(a), second: List(a)) -> List(a) {\n    do_append_acc(reverse(first), second)\n  }\n\n  fn do_append_acc(first: List(a), second: List(a)) -> List(a) {\n    case first {\n      [] -> second\n      [item, ..rest] -> do_append_acc(rest, [item, ..second])\n    }\n  }\n}\n\n/// Prefixes an item to a list. This can also be done using the dedicated\n/// syntax instead\n///\n/// ```gleam\n/// let new_list = [1, ..existing_list]\n/// ```\n///\npub fn prepend(to list: List(a), this item: a) -> List(a) {\n  [item, ..list]\n}\n\n// Reverses a list and prepends it to another list\nfn reverse_and_prepend(list prefix: List(a), to suffix: List(a)) -> List(a) {\n  case prefix {\n    [] -> suffix\n    [first, ..rest] -> reverse_and_prepend(list: rest, to: [first, ..suffix])\n  }\n}\n\nfn do_flatten(lists: List(List(a)), acc: List(a)) -> List(a) {\n  case lists {\n    [] -> reverse(acc)\n    [list, ..further_lists] ->\n      do_flatten(further_lists, reverse_and_prepend(list: list, to: acc))\n  }\n}\n\n/// Flattens a list of lists into a single list.\n///\n/// This function traverses all elements twice.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > flatten([[1], [2, 3], []])\n/// [1, 2, 3]\n/// ```\n///\npub fn flatten(lists: List(List(a))) -> List(a) {\n  do_flatten(lists, [])\n}\n\n/// Maps the list with the given function and then flattens it.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > flat_map([2, 4, 6], fn(x) { [x, x + 1] })\n/// [2, 3, 4, 5, 6, 7]\n/// ```\n///\npub fn flat_map(over list: List(a), with fun: fn(a) -> List(b)) -> List(b) {\n  map(list, fun)\n  |> flatten\n}\n\n/// Reduces a list of elements into a single value by calling a given function\n/// on each element, going from left to right.\n///\n/// `fold([1, 2, 3], 0, add)` is the equivalent of\n/// `add(add(add(0, 1), 2), 3)`.\n///\n/// This function runs in linear time.\n///\npub fn fold(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> acc {\n  case list {\n    [] -> initial\n    [x, ..rest] -> fold(rest, fun(initial, x), fun)\n  }\n}\n\n/// Reduces a list of elements into a single value by calling a given function\n/// on each element, going from right to left.\n///\n/// `fold_right([1, 2, 3], 0, add)` is the equivalent of\n/// `add(add(add(0, 3), 2), 1)`.\n///\n/// This function runs in linear time.\n///\n/// Unlike `fold` this function is not tail recursive. Where possible use\n/// `fold` instead as it will use less memory.\n///\npub fn fold_right(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> acc {\n  case list {\n    [] -> initial\n    [x, ..rest] -> fun(fold_right(rest, initial, fun), x)\n  }\n}\n\nfn do_index_fold(\n  over: List(a),\n  acc: acc,\n  with: fn(acc, a, Int) -> acc,\n  index: Int,\n) -> acc {\n  case over {\n    [] -> acc\n    [first, ..rest] ->\n      do_index_fold(rest, with(acc, first, index), with, index + 1)\n  }\n}\n\n/// Like fold but the folding function also receives the index of the current element.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [\"a\", \"b\", \"c\"]\n/// |> index_fold([], fn(acc, item, index) { ... })\n/// ```\n///\npub fn index_fold(\n  over over: List(a),\n  from initial: acc,\n  with fun: fn(acc, a, Int) -> acc,\n) -> acc {\n  do_index_fold(over, initial, fun, 0)\n}\n\n/// A variant of fold that might fail.\n///\n/// The folding function should return `Result(accumulator, error)`.\n/// If the returned value is `Ok(accumulator)` try_fold will try the next value in the list.\n/// If the returned value is `Error(error)` try_fold will stop and return that error.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [1, 2, 3, 4]\n/// |> try_fold(0, fn(acc, i) {\n///   case i < 3 {\n///     True -> Ok(acc + i)\n///     False -> Error(Nil)\n///   }\n/// })\n/// ```\n///\npub fn try_fold(\n  over collection: List(a),\n  from accumulator: acc,\n  with fun: fn(acc, a) -> Result(acc, e),\n) -> Result(acc, e) {\n  case collection {\n    [] -> Ok(accumulator)\n    [first, ..rest] ->\n      case fun(accumulator, first) {\n        Ok(result) -> try_fold(rest, result, fun)\n        Error(_) as error -> error\n      }\n  }\n}\n\npub type ContinueOrStop(a) {\n  Continue(a)\n  Stop(a)\n}\n\n/// A variant of fold that allows to stop folding earlier.\n///\n/// The folding function should return `ContinueOrStop(accumulator)`.\n/// If the returned value is `Continue(accumulator)` fold_until will try the next value in the list.\n/// If the returned value is `Stop(accumulator)` fold_until will stop and return that accumulator.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [1, 2, 3, 4]\n/// |> fold_until(0, fn(acc, i) {\n///   case i < 3 {\n///     True -> Continue(acc + i)\n///     False -> Stop(acc)\n///   }\n/// })\n/// ```\n///\npub fn fold_until(\n  over collection: List(a),\n  from accumulator: acc,\n  with fun: fn(acc, a) -> ContinueOrStop(acc),\n) -> acc {\n  case collection {\n    [] -> accumulator\n    [first, ..rest] ->\n      case fun(accumulator, first) {\n        Continue(next_accumulator) -> fold_until(rest, next_accumulator, fun)\n        Stop(b) -> b\n      }\n  }\n}\n\n/// Finds the first element in a given list for which the given function returns\n/// `True`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > find([1, 2, 3], fn(x) { x > 2 })\n/// Ok(3)\n/// ```\n///\n/// ```gleam\n/// > find([1, 2, 3], fn(x) { x > 4 })\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > find([], fn(_) { True })\n/// Error(Nil)\n/// ```\n///\npub fn find(\n  in haystack: List(a),\n  one_that is_desired: fn(a) -> Bool,\n) -> Result(a, Nil) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case is_desired(x) {\n        True -> Ok(x)\n        _ -> find(in: rest, one_that: is_desired)\n      }\n  }\n}\n\n/// Finds the first element in a given list for which the given function returns\n/// `Ok(new_value)`, then returns the wrapped `new_value`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > find_map([[], [2], [3]], first)\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > find_map([[], []], first)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > find_map([], first)\n/// Error(Nil)\n/// ```\n///\npub fn find_map(\n  in haystack: List(a),\n  with fun: fn(a) -> Result(b, c),\n) -> Result(b, Nil) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case fun(x) {\n        Ok(x) -> Ok(x)\n        _ -> find_map(in: rest, with: fun)\n      }\n  }\n}\n\n/// Returns `True` if the given function returns `True` for all the elements in\n/// the given list. If the function returns `False` for any of the elements it\n/// immediately returns `False` without checking the rest of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > all([], fn(x) { x > 3 })\n/// True\n/// ```\n///\n/// ```gleam\n/// > all([4, 5], fn(x) { x > 3 })\n/// True\n/// ```\n///\n/// ```gleam\n/// > all([4, 3], fn(x) { x > 3 })\n/// False\n/// ```\n///\npub fn all(in list: List(a), satisfying predicate: fn(a) -> Bool) -> Bool {\n  case list {\n    [] -> True\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> all(rest, predicate)\n        False -> False\n      }\n  }\n}\n\n/// Returns `True` if the given function returns `True` for any the elements in\n/// the given list. If the function returns `True` for any of the elements it\n/// immediately returns `True` without checking the rest of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > any([], fn(x) { x > 3 })\n/// False\n/// ```\n///\n/// ```gleam\n/// > any([4, 5], fn(x) { x > 3 })\n/// True\n/// ```\n///\n/// ```gleam\n/// > any([4, 3], fn(x) { x > 4 })\n/// False\n/// ```\n///\n/// ```gleam\n/// > any([3, 4], fn(x) { x > 3 })\n/// True\n/// ```\n///\npub fn any(in list: List(a), satisfying predicate: fn(a) -> Bool) -> Bool {\n  case list {\n    [] -> False\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> True\n        False -> any(rest, predicate)\n      }\n  }\n}\n\nfn do_zip(xs: List(a), ys: List(b), acc: List(#(a, b))) -> List(#(a, b)) {\n  case xs, ys {\n    [x, ..xs], [y, ..ys] -> do_zip(xs, ys, [#(x, y), ..acc])\n    _, _ -> reverse(acc)\n  }\n}\n\n/// Takes two lists and returns a single list of 2-element tuples.\n///\n/// If one of the lists is longer than the other, the remaining elements from\n/// the longer list are not used.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > zip([], [])\n/// []\n/// ```\n///\n/// ```gleam\n/// > zip([1, 2], [3])\n/// [#(1, 3)]\n/// ```\n///\n/// ```gleam\n/// > zip([1], [3, 4])\n/// [#(1, 3)]\n/// ```\n///\n/// ```gleam\n/// > zip([1, 2], [3, 4])\n/// [#(1, 3), #(2, 4)]\n/// ```\n///\npub fn zip(list: List(a), with other: List(b)) -> List(#(a, b)) {\n  do_zip(list, other, [])\n}\n\n/// Takes two lists and returns a single list of 2-element tuples.\n///\n/// If one of the lists is longer than the other, an `Error` is returned.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > strict_zip([], [])\n/// Ok([])\n/// ```\n///\n/// ```gleam\n/// > strict_zip([1, 2], [3])\n/// Error(LengthMismatch)\n/// ```\n///\n/// ```gleam\n/// > strict_zip([1], [3, 4])\n/// Error(LengthMismatch)\n/// ```\n///\n/// ```gleam\n/// > strict_zip([1, 2], [3, 4])\n/// Ok([#(1, 3), #(2, 4)])\n/// ```\n///\npub fn strict_zip(\n  list: List(a),\n  with other: List(b),\n) -> Result(List(#(a, b)), LengthMismatch) {\n  case length(of: list) == length(of: other) {\n    True -> Ok(zip(list, other))\n    False -> Error(LengthMismatch)\n  }\n}\n\nfn do_unzip(input, xs, ys) {\n  case input {\n    [] -> #(reverse(xs), reverse(ys))\n    [#(x, y), ..rest] -> do_unzip(rest, [x, ..xs], [y, ..ys])\n  }\n}\n\n/// Takes a single list of 2-element tuples and returns two lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > unzip([#(1, 2), #(3, 4)])\n/// #([1, 3], [2, 4])\n/// ```\n///\n/// ```gleam\n/// > unzip([])\n/// #([], [])\n/// ```\n///\npub fn unzip(input: List(#(a, b))) -> #(List(a), List(b)) {\n  do_unzip(input, [], [])\n}\n\nfn do_intersperse(list: List(a), separator: a, acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..rest] -> do_intersperse(rest, separator, [x, separator, ..acc])\n  }\n}\n\n/// Inserts a given value between each existing element in a given list.\n///\n/// This function runs in linear time and copies the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > intersperse([1, 1, 1], 2)\n/// [1, 2, 1, 2, 1]\n/// ```\n///\n/// ```gleam\n/// > intersperse([], 2)\n/// []\n/// ```\n///\npub fn intersperse(list: List(a), with elem: a) -> List(a) {\n  case list {\n    [] | [_] -> list\n    [x, ..rest] -> do_intersperse(rest, elem, [x])\n  }\n}\n\n/// Returns the element in the Nth position in the list, with 0 being the first\n/// position.\n///\n/// `Error(Nil)` is returned if the list is not long enough for the given index\n/// or if the index is less than 0.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > at([1, 2, 3], 1)\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > at([1, 2, 3], 5)\n/// Error(Nil)\n/// ```\n///\npub fn at(in list: List(a), get index: Int) -> Result(a, Nil) {\n  case index >= 0 {\n    True ->\n      list\n      |> drop(index)\n      |> first\n    False -> Error(Nil)\n  }\n}\n\n/// Removes any duplicate elements from a given list.\n///\n/// This function returns in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > unique([1, 1, 1, 4, 7, 3, 3, 4])\n/// [1, 4, 7, 3]\n/// ```\n///\npub fn unique(list: List(a)) -> List(a) {\n  case list {\n    [] -> []\n    [x, ..rest] -> [x, ..unique(filter(rest, fn(y) { y != x }))]\n  }\n}\n\n/// Merge lists `a` and `b` in ascending order\n/// but only up to `na` and `nb` number of items respectively.\n///\nfn merge_up(\n  na: Int,\n  nb: Int,\n  a: List(a),\n  b: List(a),\n  acc: List(a),\n  compare: fn(a, a) -> Order,\n) {\n  case na, nb, a, b {\n    0, 0, _, _ -> acc\n    _, 0, [ax, ..ar], _ -> merge_up(na - 1, nb, ar, b, [ax, ..acc], compare)\n    0, _, _, [bx, ..br] -> merge_up(na, nb - 1, a, br, [bx, ..acc], compare)\n    _, _, [ax, ..ar], [bx, ..br] ->\n      case compare(ax, bx) {\n        order.Gt -> merge_up(na, nb - 1, a, br, [bx, ..acc], compare)\n        _ -> merge_up(na - 1, nb, ar, b, [ax, ..acc], compare)\n      }\n  }\n}\n\n/// Merge lists `a` and `b` in descending order\n/// but only up to `na` and `nb` number of items respectively.\n///\nfn merge_down(\n  na: Int,\n  nb: Int,\n  a: List(a),\n  b: List(a),\n  acc: List(a),\n  compare: fn(a, a) -> Order,\n) {\n  case na, nb, a, b {\n    0, 0, _, _ -> acc\n    _, 0, [ax, ..ar], _ -> merge_down(na - 1, nb, ar, b, [ax, ..acc], compare)\n    0, _, _, [bx, ..br] -> merge_down(na, nb - 1, a, br, [bx, ..acc], compare)\n    _, _, [ax, ..ar], [bx, ..br] ->\n      case compare(bx, ax) {\n        order.Lt -> merge_down(na - 1, nb, ar, b, [ax, ..acc], compare)\n        _ -> merge_down(na, nb - 1, a, br, [bx, ..acc], compare)\n      }\n  }\n}\n\n/// Merge sort that alternates merging in ascending and descending order\n/// because the merge process also reverses the list.\n///\n/// Some copying is avoided by merging only a subset of the lists\n/// instead of creating and merging new smaller lists.\n///\nfn merge_sort(\n  l: List(a),\n  ln: Int,\n  compare: fn(a, a) -> Order,\n  down: Bool,\n) -> List(a) {\n  let n = ln / 2\n  let a = l\n  let b = drop(l, n)\n  case ln < 3 {\n    True ->\n      case down {\n        True -> merge_down(n, ln - n, a, b, [], compare)\n        False -> merge_up(n, ln - n, a, b, [], compare)\n      }\n    False ->\n      case down {\n        True ->\n          merge_down(\n            n,\n            ln - n,\n            merge_sort(a, n, compare, False),\n            merge_sort(b, ln - n, compare, False),\n            [],\n            compare,\n          )\n        False ->\n          merge_up(\n            n,\n            ln - n,\n            merge_sort(a, n, compare, True),\n            merge_sort(b, ln - n, compare, True),\n            [],\n            compare,\n          )\n      }\n  }\n}\n\n/// Sorts from smallest to largest based upon the ordering specified by a given\n/// function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/int\n/// > list.sort([4, 3, 6, 5, 4, 1, 2], by: int.compare)\n/// [1, 2, 3, 4, 4, 5, 6]\n/// ```\n///\npub fn sort(list: List(a), by compare: fn(a, a) -> Order) -> List(a) {\n  merge_sort(list, length(list), compare, True)\n}\n\n/// Creates a list of ints ranging from a given start and finish.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > range(0, 0)\n/// [0]\n/// ```\n///\n/// ```gleam\n/// > range(0, 5)\n/// [0, 1, 2, 3, 4, 5]\n/// ```\n///\n/// ```gleam\n/// > range(1, -5)\n/// [1, 0, -1, -2, -3, -4, -5]\n/// ```\n///\npub fn range(from start: Int, to stop: Int) -> List(Int) {\n  tail_recursive_range(start, stop, [])\n}\n\nfn tail_recursive_range(start: Int, stop: Int, acc: List(Int)) -> List(Int) {\n  case int.compare(start, stop) {\n    order.Eq -> reverse([stop, ..acc])\n    order.Gt -> tail_recursive_range(start - 1, stop, [start, ..acc])\n    order.Lt -> tail_recursive_range(start + 1, stop, [start, ..acc])\n  }\n}\n\nfn do_repeat(a: a, times: Int, acc: List(a)) -> List(a) {\n  case times <= 0 {\n    True -> acc\n    False -> do_repeat(a, times - 1, [a, ..acc])\n  }\n}\n\n/// Builds a list of a given value a given number of times.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > repeat(\"a\", times: 0)\n/// []\n/// ```\n///\n/// ```gleam\n/// > repeat(\"a\", times: 5)\n/// [\"a\", \"a\", \"a\", \"a\", \"a\"]\n/// ```\n///\npub fn repeat(item a: a, times times: Int) -> List(a) {\n  do_repeat(a, times, [])\n}\n\nfn do_split(list: List(a), n: Int, taken: List(a)) -> #(List(a), List(a)) {\n  case n <= 0 {\n    True -> #(reverse(taken), list)\n    False ->\n      case list {\n        [] -> #(reverse(taken), [])\n        [x, ..xs] -> do_split(xs, n - 1, [x, ..taken])\n      }\n  }\n}\n\n/// Splits a list in two before the given index.\n///\n/// If the list is not long enough to have the given index the before list will\n/// be the input list, and the after list will be empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > split([6, 7, 8, 9], 0)\n/// #([], [6, 7, 8, 9])\n/// ```\n///\n/// ```gleam\n/// > split([6, 7, 8, 9], 2)\n/// #([6, 7], [8, 9])\n/// ```\n///\n/// ```gleam\n/// > split([6, 7, 8, 9], 4)\n/// #([6, 7, 8, 9], [])\n/// ```\n///\npub fn split(list list: List(a), at index: Int) -> #(List(a), List(a)) {\n  do_split(list, index, [])\n}\n\nfn do_split_while(\n  list: List(a),\n  f: fn(a) -> Bool,\n  acc: List(a),\n) -> #(List(a), List(a)) {\n  case list {\n    [] -> #(reverse(acc), [])\n    [x, ..xs] ->\n      case f(x) {\n        False -> #(reverse(acc), list)\n        _ -> do_split_while(xs, f, [x, ..acc])\n      }\n  }\n}\n\n/// Splits a list in two before the first element that a given function returns\n/// `False` for.\n///\n/// If the function returns `True` for all elements the first list will be the\n/// input list, and the second list will be empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > split_while([1, 2, 3, 4, 5], fn(x) { x <= 3 })\n/// #([1, 2, 3], [4, 5])\n/// ```\n///\n/// ```gleam\n/// > split_while([1, 2, 3, 4, 5], fn(x) { x <= 5 })\n/// #([1, 2, 3, 4, 5], [])\n/// ```\n///\npub fn split_while(\n  list list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> #(List(a), List(a)) {\n  do_split_while(list, predicate, [])\n}\n\n/// Given a list of 2-element tuples, finds the first tuple that has a given\n/// key as the first element and returns the second element.\n///\n/// If no tuple is found with the given key then `Error(Nil)` is returned.\n///\n/// This function may be useful for interacting with Erlang code where lists of\n/// tuples are common.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > key_find([#(\"a\", 0), #(\"b\", 1)], \"a\")\n/// Ok(0)\n/// ```\n///\n/// ```gleam\n/// > key_find([#(\"a\", 0), #(\"b\", 1)], \"b\")\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > key_find([#(\"a\", 0), #(\"b\", 1)], \"c\")\n/// Error(Nil)\n/// ```\n///\npub fn key_find(\n  in keyword_list: List(#(k, v)),\n  find desired_key: k,\n) -> Result(v, Nil) {\n  find_map(\n    keyword_list,\n    fn(keyword) {\n      let #(key, value) = keyword\n      case key == desired_key {\n        True -> Ok(value)\n        False -> Error(Nil)\n      }\n    },\n  )\n}\n\nfn do_pop(haystack, predicate, checked) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case predicate(x) {\n        True -> Ok(#(x, append(reverse(checked), rest)))\n        False -> do_pop(rest, predicate, [x, ..checked])\n      }\n  }\n}\n\n/// Removes the first element in a given list for which the predicate function returns `True`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > pop([1, 2, 3], fn(x) { x > 2 })\n/// Ok(#(3, [1, 2]))\n/// ```\n///\n/// ```gleam\n/// > pop([1, 2, 3], fn(x) { x > 4 })\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > pop([], fn(_) { True })\n/// Error(Nil)\n/// ```\n///\npub fn pop(\n  in haystack: List(a),\n  one_that is_desired: fn(a) -> Bool,\n) -> Result(#(a, List(a)), Nil) {\n  do_pop(haystack, is_desired, [])\n}\n\nfn do_pop_map(haystack, mapper, checked) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case mapper(x) {\n        Ok(y) -> Ok(#(y, append(reverse(checked), rest)))\n        Error(_) -> do_pop_map(rest, mapper, [x, ..checked])\n      }\n  }\n}\n\n/// Removes the first element in a given list for which the given function returns\n/// `Ok(new_value)`, then returns the wrapped `new_value` as well as list with the value removed.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > pop_map([[], [2], [3]], first)\n/// Ok(#(2, [[], [3]]))\n/// ```\n///\n/// ```gleam\n/// > pop_map([[], []], first)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > pop_map([], first)\n/// Error(Nil)\n/// ```\n///\npub fn pop_map(\n  in haystack: List(a),\n  one_that is_desired: fn(a) -> Result(b, c),\n) -> Result(#(b, List(a)), Nil) {\n  do_pop_map(haystack, is_desired, [])\n}\n\n/// Given a list of 2-element tuples, finds the first tuple that has a given\n/// key as the first element. This function will return the second element\n/// of the found tuple and list with tuple removed.\n///\n/// If no tuple is found with the given key then `Error(Nil)` is returned.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > key_pop([#(\"a\", 0), #(\"b\", 1)], \"a\")\n/// Ok(#(0, [#(\"b\", 1)]))\n/// ```\n///\n/// ```gleam\n/// > key_pop([#(\"a\", 0), #(\"b\", 1)], \"b\")\n/// Ok(#(1, [#(\"a\", 0)]))\n/// ```\n///\n/// ```gleam\n/// > key_pop([#(\"a\", 0), #(\"b\", 1)], \"c\")\n/// Error(Nil)\n/// ```\n///\npub fn key_pop(\n  haystack: List(#(k, v)),\n  key: k,\n) -> Result(#(v, List(#(k, v))), Nil) {\n  pop_map(\n    haystack,\n    fn(entry) {\n      let #(k, v) = entry\n      case k {\n        k if k == key -> Ok(v)\n        _ -> Error(Nil)\n      }\n    },\n  )\n}\n\n/// Given a list of 2-element tuples, inserts a key and value into the list.\n///\n/// If there was already a tuple with the key then it is replaced, otherwise it\n/// is added to the end of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > key_set([#(5, 0), #(4, 1)], 4, 100)\n/// [#(5, 0), #(4, 100)]\n/// ```\n///\n/// ```gleam\n/// > key_set([#(5, 0), #(4, 1)], 1, 100)\n/// [#(5, 0), #(4, 1), #(1, 100)]\n/// ```\n///\npub fn key_set(list: List(#(a, b)), key: a, value: b) -> List(#(a, b)) {\n  case list {\n    [] -> [#(key, value)]\n    [#(k, _), ..rest] if k == key -> [#(key, value), ..rest]\n    [first, ..rest] -> [first, ..key_set(rest, key, value)]\n  }\n}\n\n/// Calls a function for each element in a list, discarding the return value.\n///\n/// Useful for calling a side effect for every item of a list.\n///\n/// ```gleam\n/// > list.each([1, 2, 3], io.println)\n/// Nil\n/// ```\n///\npub fn each(list: List(a), f: fn(a) -> b) -> Nil {\n  case list {\n    [] -> Nil\n    [x, ..xs] -> {\n      f(x)\n      each(xs, f)\n    }\n  }\n}\n\n/// Calls a `Result` returning function for each element in a list, discarding\n/// the return value. If the function returns `Error` then the iteration is\n/// stopped and the error is returned.\n///\n/// Useful for calling a side effect for every item of a list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > try_each(\n/// >   over: [1, 2, 3],\n/// >   with: function_that_might_fail,\n/// > )\n/// Ok(Nil)\n/// ```\n///\npub fn try_each(\n  over list: List(a),\n  with fun: fn(a) -> Result(b, e),\n) -> Result(Nil, e) {\n  case list {\n    [] -> Ok(Nil)\n    [x, ..xs] ->\n      case fun(x) {\n        Ok(_) -> try_each(over: xs, with: fun)\n        Error(e) -> Error(e)\n      }\n  }\n}\n\nfn do_partition(list, categorise, trues, falses) {\n  case list {\n    [] -> #(reverse(trues), reverse(falses))\n    [x, ..xs] ->\n      case categorise(x) {\n        True -> do_partition(xs, categorise, [x, ..trues], falses)\n        False -> do_partition(xs, categorise, trues, [x, ..falses])\n      }\n  }\n}\n\n/// Partitions a list into a tuple/pair of lists\n/// by a given categorisation function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3, 4, 5] |> list.partition(int.is_odd)\n/// #([1, 3, 5], [2, 4])\n/// ```\n///\npub fn partition(\n  list: List(a),\n  with categorise: fn(a) -> Bool,\n) -> #(List(a), List(a)) {\n  do_partition(list, categorise, [], [])\n}\n\n/// Returns all the permutations of a list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > permutations([1, 2])\n/// [[1, 2], [2, 1]]\n/// ```\n///\npub fn permutations(l: List(a)) -> List(List(a)) {\n  case l {\n    [] -> [[]]\n    _ ->\n      l\n      |> index_map(fn(i_idx, i) {\n        l\n        |> index_fold(\n          [],\n          fn(acc, j, j_idx) {\n            case i_idx == j_idx {\n              True -> acc\n              False -> [j, ..acc]\n            }\n          },\n        )\n        |> reverse\n        |> permutations\n        |> map(fn(permutation) { [i, ..permutation] })\n      })\n      |> flatten\n  }\n}\n\nfn do_window(acc: List(List(a)), l: List(a), n: Int) -> List(List(a)) {\n  let window = take(l, n)\n\n  case length(window) == n {\n    True -> do_window([window, ..acc], drop(l, 1), n)\n    False -> acc\n  }\n}\n\n/// Returns a list of sliding windows.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > window([1,2,3,4,5], 3)\n/// [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n/// ```\n///\n/// ```gleam\n/// > window([1, 2], 4)\n/// []\n/// ```\n///\npub fn window(l: List(a), by n: Int) -> List(List(a)) {\n  do_window([], l, n)\n  |> reverse\n}\n\n/// Returns a list of tuples containing two contiguous elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > window_by_2([1,2,3,4])\n/// [#(1, 2), #(2, 3), #(3, 4)]\n/// ```\n///\n/// ```gleam\n/// > window_by_2([1])\n/// []\n/// ```\n///\npub fn window_by_2(l: List(a)) -> List(#(a, a)) {\n  zip(l, drop(l, 1))\n}\n\n/// Drops the first elements in a given list for which the predicate function returns `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > drop_while([1, 2, 3, 4], fn (x) { x < 3 })\n/// [3, 4]\n/// ```\n///\npub fn drop_while(\n  in list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> List(a) {\n  case list {\n    [] -> []\n    [x, ..xs] ->\n      case predicate(x) {\n        True -> drop_while(xs, predicate)\n        False -> [x, ..xs]\n      }\n  }\n}\n\nfn do_take_while(\n  list: List(a),\n  predicate: fn(a) -> Bool,\n  acc: List(a),\n) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> do_take_while(rest, predicate, [first, ..acc])\n        False -> reverse(acc)\n      }\n  }\n}\n\n/// Takes the first elements in a given list for which the predicate function returns `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > take_while([1, 2, 3, 2, 4], fn (x) { x < 3 })\n/// [1, 2]\n/// ```\n///\npub fn take_while(\n  in list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> List(a) {\n  do_take_while(list, predicate, [])\n}\n\nfn do_chunk(\n  list: List(a),\n  f: fn(a) -> key,\n  previous_key: key,\n  current_chunk: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case list {\n    [first, ..rest] -> {\n      let key = f(first)\n      case key == previous_key {\n        False -> {\n          let new_acc = [reverse(current_chunk), ..acc]\n          do_chunk(rest, f, key, [first], new_acc)\n        }\n        _true -> do_chunk(rest, f, key, [first, ..current_chunk], acc)\n      }\n    }\n    _empty -> reverse([reverse(current_chunk), ..acc])\n  }\n}\n\n/// Returns a list of chunks in which\n/// the return value of calling `f` on each element is the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 2, 3, 4, 4, 6, 7, 7] |> chunk(by: fn(n) { n % 2 })\n/// [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n/// ```\n///\npub fn chunk(in list: List(a), by f: fn(a) -> key) -> List(List(a)) {\n  case list {\n    [] -> []\n    [first, ..rest] -> do_chunk(rest, f, f(first), [first], [])\n  }\n}\n\nfn do_sized_chunk(\n  list: List(a),\n  count: Int,\n  left: Int,\n  current_chunk: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case list {\n    [] ->\n      case current_chunk {\n        [] -> reverse(acc)\n        remaining -> reverse([reverse(remaining), ..acc])\n      }\n    [first, ..rest] -> {\n      let chunk = [first, ..current_chunk]\n      case left > 1 {\n        False -> do_sized_chunk(rest, count, count, [], [reverse(chunk), ..acc])\n        True -> do_sized_chunk(rest, count, left - 1, chunk, acc)\n      }\n    }\n  }\n}\n\n/// Returns a list of chunks containing `count` elements each.\n///\n/// If the last chunk does not have `count` elements, it is instead\n/// a partial chunk, with less than `count` elements.\n///\n/// For any `count` less than 1 this function behaves as if it was set to 1.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3, 4, 5, 6] |> sized_chunk(into: 2)\n/// [[1, 2], [3, 4], [5, 6]]\n/// ```\n///\n/// ```gleam\n/// > [1, 2, 3, 4, 5, 6, 7, 8] |> sized_chunk(into: 3)\n/// [[1, 2, 3], [4, 5, 6], [7, 8]]\n/// ```\n///\npub fn sized_chunk(in list: List(a), into count: Int) -> List(List(a)) {\n  do_sized_chunk(list, count, count, [], [])\n}\n\n/// This function acts similar to fold, but does not take an initial state.\n/// Instead, it starts from the first element in the list\n/// and combines it with each subsequent element in turn using the given\n/// function. The function is called as `fun(accumulator, current_element)`.\n///\n/// Returns `Ok` to indicate a successful run, and `Error` if called on an\n/// empty list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [] |> reduce(fn(acc, x) { acc + x })\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > [1, 2, 3, 4, 5] |> reduce(fn(acc, x) { acc + x })\n/// Ok(15)\n/// ```\n///\npub fn reduce(over list: List(a), with fun: fn(a, a) -> a) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [first, ..rest] -> Ok(fold(rest, first, fun))\n  }\n}\n\nfn do_scan(\n  list: List(a),\n  accumulator: acc,\n  accumulated: List(acc),\n  fun: fn(acc, a) -> acc,\n) -> List(acc) {\n  case list {\n    [] -> reverse(accumulated)\n    [x, ..xs] -> {\n      let next = fun(accumulator, x)\n      do_scan(xs, next, [next, ..accumulated], fun)\n    }\n  }\n}\n\n/// Similar to `fold`, but yields the state of the accumulator at each stage.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > scan(over: [1, 2, 3], from: 100, with: fn(acc, i) { acc + i })\n/// [101, 103, 106]\n/// ```\n///\npub fn scan(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> List(acc) {\n  do_scan(list, initial, [], fun)\n}\n\n/// Returns the last element in the given list.\n///\n/// Returns `Error(Nil)` if the list is empty.\n///\n/// This function runs in linear time.\n/// For a collection oriented around performant access at either end,\n/// see `gleam/queue.Queue`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > last([])\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > last([1, 2, 3, 4, 5])\n/// Ok(5)\n/// ```\n///\npub fn last(list: List(a)) -> Result(a, Nil) {\n  list\n  |> reduce(fn(_, elem) { elem })\n}\n\n/// Return unique combinations of elements in the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > combinations([1, 2, 3], 2)\n/// [[1, 2], [1, 3], [2, 3]]\n/// ```\n///\n/// ```gleam\n/// > combinations([1, 2, 3, 4], 3)\n/// [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]\n/// ```\n///\npub fn combinations(items: List(a), by n: Int) -> List(List(a)) {\n  case n {\n    0 -> [[]]\n    _ ->\n      case items {\n        [] -> []\n        [x, ..xs] -> {\n          let first_combinations =\n            map(combinations(xs, n - 1), with: fn(com) { [x, ..com] })\n            |> reverse\n          fold(\n            first_combinations,\n            combinations(xs, n),\n            fn(acc, c) { [c, ..acc] },\n          )\n        }\n      }\n  }\n}\n\nfn do_combination_pairs(items: List(a)) -> List(List(#(a, a))) {\n  case items {\n    [] -> []\n    [x, ..xs] -> {\n      let first_combinations = map(xs, with: fn(other) { #(x, other) })\n      [first_combinations, ..do_combination_pairs(xs)]\n    }\n  }\n}\n\n/// Return unique pair combinations of elements in the list\n///\n/// ## Examples\n///\n/// ```gleam\n/// > combination_pairs([1, 2, 3])\n/// [#(1, 2), #(1, 3), #(2, 3)]\n/// ```\n///\npub fn combination_pairs(items: List(a)) -> List(#(a, a)) {\n  do_combination_pairs(items)\n  |> flatten\n}\n\n/// Make a list alternating the elements from the given lists\n///\n/// ## Examples\n///\n/// ```gleam\n/// > list.interleave([[1, 2], [101, 102], [201, 202]])\n/// [1, 101, 201, 2, 102, 202]\n/// ```\n///\npub fn interleave(list: List(List(a))) -> List(a) {\n  transpose(list)\n  |> flatten\n}\n\n/// Transpose rows and columns of the list of lists.\n///\n/// Notice: This function is not tail recursive,\n/// and thus may exceed stack size if called,\n/// with large lists (on target JavaScript).\n///\n/// ## Examples\n///\n/// ```gleam\n/// > transpose([[1, 2, 3], [101, 102, 103]])\n/// [[1, 101], [2, 102], [3, 103]]\n/// ```\n///\npub fn transpose(list_of_list: List(List(a))) -> List(List(a)) {\n  let take_first = fn(list) {\n    case list {\n      [] -> []\n      [f] -> [f]\n      [f, ..] -> [f]\n    }\n  }\n\n  case list_of_list {\n    [] -> []\n    [[], ..xss] -> transpose(xss)\n    rows -> {\n      let firsts =\n        rows\n        |> map(take_first)\n        |> flatten\n      let rest = transpose(map(rows, drop(_, 1)))\n      [firsts, ..rest]\n    }\n  }\n}\n\nfn do_shuffle_pair_unwrap(list: List(#(Float, a)), acc: List(a)) -> List(a) {\n  case list {\n    [] -> acc\n    _ -> {\n      let [elem_pair, ..enumerable] = list\n      do_shuffle_pair_unwrap(enumerable, [elem_pair.1, ..acc])\n    }\n  }\n}\n\nfn do_shuffle_by_pair_indexes(\n  list_of_pairs: List(#(Float, a)),\n) -> List(#(Float, a)) {\n  sort(\n    list_of_pairs,\n    fn(a_pair: #(Float, a), b_pair: #(Float, a)) -> Order {\n      float.compare(a_pair.0, b_pair.0)\n    },\n  )\n}\n\n/// Takes a list, randomly sorts all items and returns the shuffled list.\n///\n/// This function uses Erlang's `:rand` module or Javascript's\n/// `Math.random()` to calcuate the index shuffling.\n///\n/// ## Example\n///\n/// ```gleam\n/// > range(1, 10)\n/// > |> shuffle()\n/// [1, 6, 9, 10, 3, 8, 4, 2, 7, 5]\n/// ```\n///\npub fn shuffle(list: List(a)) -> List(a) {\n  list\n  |> fold(from: [], with: fn(acc, a) { [#(float.random(0.0, 1.0), a), ..acc] })\n  |> do_shuffle_by_pair_indexes()\n  |> do_shuffle_pair_unwrap([])\n}\n" (Durability(0))    
2023-08-04T09:30:46.269527Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.269537Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R124    
2023-08-04T09:30:46.269546Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(28)) = "import gleam/string\n\n/// Writes a string to standard output.\n///\n/// If you want your output to be printed on its own line see `println`.\n///\n/// ## Example\n///\n/// ```gleam\n/// > io.print(\"Hi mum\")\n/// // -> Hi mum\n/// Nil\n/// ```\n///\npub fn print(string: String) -> Nil {\n  do_print(string)\n}\n\nif erlang {\n  external fn do_print(string: String) -> Nil =\n    \"gleam_stdlib\" \"print\"\n}\n\nif javascript {\n  external fn do_print(String) -> Nil =\n    \"../gleam_stdlib.mjs\" \"print\"\n}\n\n/// Writes a string to standard error.\n///\n/// If you want your output to be printed on its own line see `eprintln`.\n///\n/// ## Example\n///\n/// ```\n/// > io.print_error(\"Hi pop\")\n/// // -> Hi pop\n/// Nil\n/// ```\n///\npub fn print_error(string: String) -> Nil {\n  do_print_error(string)\n}\n\nif erlang {\n  external fn do_print_error(string: String) -> Nil =\n    \"gleam_stdlib\" \"print_error\"\n}\n\nif javascript {\n  external fn do_print_error(String) -> Nil =\n    \"../gleam_stdlib.mjs\" \"print_error\"\n}\n\n/// Writes a string to standard output, appending a newline to the end.\n///\n/// ## Example\n///\n/// ```gleam\n/// > io.println(\"Hi mum\")\n/// // -> Hi mum\n/// Nil\n/// ```\n///\npub fn println(string: String) -> Nil {\n  do_println(string)\n}\n\nif erlang {\n  external fn do_println(string: String) -> Nil =\n    \"gleam_stdlib\" \"println\"\n}\n\nif javascript {\n  external fn do_println(String) -> Nil =\n    \"../gleam_stdlib.mjs\" \"console_log\"\n}\n\n/// Writes a string to standard error, appending a newline to the end.\n///\n/// ## Example\n///\n/// ```gleam\n/// > io.println_error(\"Hi pop\")\n/// // -> Hi mum\n/// Nil\n/// ```\n///\npub fn println_error(string: String) -> Nil {\n  do_println_error(string)\n}\n\nif erlang {\n  external fn do_println_error(string: String) -> Nil =\n    \"gleam_stdlib\" \"println_error\"\n}\n\nif javascript {\n  external fn do_println_error(String) -> Nil =\n    \"../gleam_stdlib.mjs\" \"console_error\"\n}\n\n/// Prints a value to standard error (stderr) yielding Gleam syntax.\n///\n/// The value is returned after being printed so it can be used in pipelines.\n///\n/// ## Example\n///\n/// ```gleam\n/// > debug(\"Hi mum\")\n/// // -> <<\"Hi mum\">>\n/// \"Hi mum\"\n/// ```\n///\n/// ```gleam\n/// > debug(Ok(1))\n/// // -> {ok, 1}\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > import list\n/// > [1, 2]\n/// > |> list.map(fn(x) { x + 1 })\n/// > |> debug\n/// > |> list.map(fn(x) { x * 2 })\n/// // -> [2, 3]\n/// [4, 6]\n/// ```\n///\npub fn debug(term: anything) -> anything {\n  term\n  |> string.inspect\n  |> do_debug_println\n\n  term\n}\n\nif erlang {\n  external fn do_debug_println(string: String) -> Nil =\n    \"gleam_stdlib\" \"println_error\"\n}\n\nif javascript {\n  external fn do_debug_println(String) -> Nil =\n    \"../gleam_stdlib.mjs\" \"print_debug\"\n}\n" (Durability(0))    
2023-08-04T09:30:46.269589Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.269597Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R125    
2023-08-04T09:30:46.269612Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(29)) = "import gleam/float\nimport gleam/order.{Order}\n\n/// Returns the absolute value of the input.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > absolute_value(-12)\n/// 12\n/// ```\n///\n/// ```gleam\n/// > absolute_value(10)\n/// 10\n/// ```\n///\npub fn absolute_value(x: Int) -> Int {\n  case x >= 0 {\n    True -> x\n    False -> x * -1\n  }\n}\n\n/// Returns the results of the base being raised to the power of the\n/// exponent, as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > power(2, -1.0)\n/// Ok(0.5)\n/// ```\n///\n/// ```gleam\n/// > power(2, 2.0)\n/// Ok(4.0)\n/// ```\n///\n/// ```gleam\n/// > power(8, 1.5)\n/// Ok(22.627416997969522)\n/// ```\n///\n/// ```gleam\n/// > 4 |> power(of: 2.0)\n/// Ok(16.0)\n/// ```\n///\n/// ```gleam\n/// > power(-1, 0.5)\n/// Error(Nil)\n/// ```\n///\npub fn power(base: Int, of exponent: Float) -> Result(Float, Nil) {\n  base\n  |> to_float()\n  |> float.power(exponent)\n}\n\n/// Returns the square root of the input as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > square_root(4)\n/// Ok(2.0)\n/// ```\n///\n/// ```gleam\n/// > square_root(-16)\n/// Error(Nil)\n/// ```\n///\npub fn square_root(x: Int) -> Result(Float, Nil) {\n  x\n  |> to_float()\n  |> float.square_root()\n}\n\n/// Parses a given string as an int if possible.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > parse(\"2\")\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > parse(\"ABC\")\n/// Error(Nil)\n/// ```\n///\npub fn parse(string: String) -> Result(Int, Nil) {\n  do_parse(string)\n}\n\nif erlang {\n  external fn do_parse(String) -> Result(Int, Nil) =\n    \"gleam_stdlib\" \"parse_int\"\n}\n\nif javascript {\n  external fn do_parse(String) -> Result(Int, Nil) =\n    \"../gleam_stdlib.mjs\" \"parse_int\"\n}\n\n/// Parses a given string as an int in a given base if possible.\n/// Supports only bases 2 to 36, for values outside of which this function returns an `Error(Nil)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > base_parse(\"10\", 2)\n/// Ok(2)\n///\n/// > base_parse(\"30\", 16)\n/// Ok(48)\n///\n/// > base_parse(\"1C\", 36)\n/// Ok(48)\n///\n/// > base_parse(\"48\", 1)\n/// Error(Nil)\n///\n/// > base_parse(\"48\", 37)\n/// Error(Nil)\n/// ```\n///\npub fn base_parse(string: String, base: Int) -> Result(Int, Nil) {\n  case base >= 2 && base <= 36 {\n    True -> do_base_parse(string, base)\n    False -> Error(Nil)\n  }\n}\n\nif erlang {\n  external fn do_base_parse(String, Int) -> Result(Int, Nil) =\n    \"gleam_stdlib\" \"int_from_base_string\"\n}\n\nif javascript {\n  external fn do_base_parse(String, Int) -> Result(Int, Nil) =\n    \"../gleam_stdlib.mjs\" \"int_from_base_string\"\n}\n\n/// Prints a given int to a string.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_string(2)\n/// \"2\"\n/// ```\n///\npub fn to_string(x: Int) {\n  do_to_string(x)\n}\n\nif erlang {\n  external fn do_to_string(Int) -> String =\n    \"erlang\" \"integer_to_binary\"\n}\n\nif javascript {\n  external fn do_to_string(Int) -> String =\n    \"../gleam_stdlib.mjs\" \"to_string\"\n}\n\n/// Error value when trying to operate with a base out of the allowed range.\n///\npub type InvalidBase {\n  InvalidBase\n}\n\n/// Prints a given int to a string using the base number provided.\n/// Supports only bases 2 to 36, for values outside of which this function returns an `Error(InvalidBase)`.\n/// For common bases (2, 8, 16, 36), use the `to_baseN` functions.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_base_string(2, 2)\n/// Ok(\"10\")\n/// ```\n///\n/// ```gleam\n/// > to_base_string(48, 16)\n/// Ok(\"30\")\n/// ```\n///\n/// ```gleam\n/// > to_base_string(48, 36)\n/// Ok(\"1C\")\n/// ```\n///\n/// ```gleam\n/// > to_base_string(48, 1)\n/// Error(InvalidBase)\n/// ```\n///\n/// ```gleam\n/// > to_base_string(48, 37)\n/// Error(InvalidBase)\n/// ```\n///\npub fn to_base_string(x: Int, base: Int) -> Result(String, InvalidBase) {\n  case base >= 2 && base <= 36 {\n    True -> Ok(do_to_base_string(x, base))\n    False -> Error(InvalidBase)\n  }\n}\n\nif erlang {\n  external fn do_to_base_string(Int, Int) -> String =\n    \"erlang\" \"integer_to_binary\"\n}\n\nif javascript {\n  external fn do_to_base_string(Int, Int) -> String =\n    \"../gleam_stdlib.mjs\" \"int_to_base_string\"\n}\n\n/// Prints a given int to a string using base-2.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_base2(2)\n/// \"10\"\n/// ```\n///\npub fn to_base2(x: Int) -> String {\n  do_to_base_string(x, 2)\n}\n\n/// Prints a given int to a string using base-8.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_base8(15)\n/// \"17\"\n/// ```\n///\npub fn to_base8(x: Int) -> String {\n  do_to_base_string(x, 8)\n}\n\n/// Prints a given int to a string using base-16.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_base16(48)\n/// \"30\"\n/// ```\n///\npub fn to_base16(x: Int) -> String {\n  do_to_base_string(x, 16)\n}\n\n/// Prints a given int to a string using base-36.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_base36(48)\n/// \"1C\"\n/// ```\n///\npub fn to_base36(x: Int) -> String {\n  do_to_base_string(x, 36)\n}\n\n/// Takes an int and returns its value as a float.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_float(5)\n/// 5.0\n/// ```\n///\n/// ```gleam\n/// > to_float(0)\n/// 0.0\n/// ```\n///\n/// ```gleam\n/// > to_float(-3)\n/// -3.0\n/// ```\n///\npub fn to_float(x: Int) -> Float {\n  do_to_float(x)\n}\n\nif erlang {\n  external fn do_to_float(Int) -> Float =\n    \"erlang\" \"float\"\n}\n\nif javascript {\n  external fn do_to_float(Int) -> Float =\n    \"../gleam_stdlib.mjs\" \"identity\"\n}\n\n/// Restricts an int between a lower and upper bound.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > clamp(40, min: 50, max: 60)\n/// 50\n/// ```\n///\npub fn clamp(x: Int, min min_bound: Int, max max_bound: Int) -> Int {\n  x\n  |> min(max_bound)\n  |> max(min_bound)\n}\n\n/// Compares two ints, returning an order.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > compare(2, 3)\n/// Lt\n/// ```\n///\n/// ```gleam\n/// > compare(4, 3)\n/// Gt\n/// ```\n///\n/// ```gleam\n/// > compare(3, 3)\n/// Eq\n/// ```\n///\npub fn compare(a: Int, with b: Int) -> Order {\n  case a == b {\n    True -> order.Eq\n    False ->\n      case a < b {\n        True -> order.Lt\n        False -> order.Gt\n      }\n  }\n}\n\n/// Compares two ints, returning the smaller of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > min(2, 3)\n/// 2\n/// ```\n///\npub fn min(a: Int, b: Int) -> Int {\n  case a < b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Compares two ints, returning the larger of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > max(2, 3)\n/// 3\n/// ```\n///\npub fn max(a: Int, b: Int) -> Int {\n  case a > b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Returns whether the value provided is even.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_even(2)\n/// True\n/// ```\n///\n/// ```gleam\n/// > is_even(3)\n/// False\n/// ```\n///\npub fn is_even(x: Int) -> Bool {\n  x % 2 == 0\n}\n\n/// Returns whether the value provided is odd.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_odd(3)\n/// True\n/// ```\n///\n/// ```gleam\n/// > is_odd(2)\n/// False\n/// ```\n///\npub fn is_odd(x: Int) -> Bool {\n  x % 2 != 0\n}\n\n/// Returns the negative of the value provided.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > negate(1)\n/// -1\n/// ```\n///\npub fn negate(x: Int) -> Int {\n  -1 * x\n}\n\n/// Sums a list of ints.\n///\n/// ## Example\n///\n/// ```gleam\n/// > sum([1, 2, 3])\n/// 6\n/// ```\n///\npub fn sum(numbers: List(Int)) -> Int {\n  numbers\n  |> do_sum(0)\n}\n\nfn do_sum(numbers: List(Int), initial: Int) -> Int {\n  case numbers {\n    [] -> initial\n    [x, ..rest] -> do_sum(rest, x + initial)\n  }\n}\n\n/// Multiplies a list of ints and returns the product.\n///\n/// ## Example\n///\n/// ```gleam\n/// > product([2, 3, 4])\n/// 24\n/// ```\n///\npub fn product(numbers: List(Int)) -> Int {\n  case numbers {\n    [] -> 1\n    _ -> do_product(numbers, 1)\n  }\n}\n\nfn do_product(numbers: List(Int), initial: Int) -> Int {\n  case numbers {\n    [] -> initial\n    [x, ..rest] -> do_product(rest, x * initial)\n  }\n}\n\n/// Splits an integer into its digit representation in the specified base\n///\n/// ## Examples\n///\n/// ```gleam\n/// > digits(234, 10)\n/// Ok([2,3,4])\n/// ```\n///\n/// ```gleam\n/// > digits(234, 1)\n/// Error(InvalidBase)\n/// ```\n///\npub fn digits(x: Int, base: Int) -> Result(List(Int), InvalidBase) {\n  case base < 2 {\n    True -> Error(InvalidBase)\n    False -> Ok(do_digits(x, base, []))\n  }\n}\n\nfn do_digits(x: Int, base: Int, acc: List(Int)) -> List(Int) {\n  case absolute_value(x) < base {\n    True -> [x, ..acc]\n    False -> do_digits(x / base, base, [x % base, ..acc])\n  }\n}\n\n/// Joins a list of digits into a single value.\n/// Returns an error if the base is less than 2 or if the list contains a digit greater than or equal to the specified base.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > undigits([2,3,4], 10)\n/// Ok(234)\n/// ```\n///\n/// ```gleam\n/// > undigits([2,3,4], 1)\n/// Error(InvalidBase)\n/// ```\n///\n/// ```gleam\n/// > undigits([2,3,4], 2)\n/// Error(InvalidBase)\n/// ```\n///\npub fn undigits(numbers: List(Int), base: Int) -> Result(Int, InvalidBase) {\n  case base < 2 {\n    True -> Error(InvalidBase)\n    False -> do_undigits(numbers, base, 0)\n  }\n}\n\nfn do_undigits(\n  numbers: List(Int),\n  base: Int,\n  acc: Int,\n) -> Result(Int, InvalidBase) {\n  case numbers {\n    [] -> Ok(acc)\n    [digit, ..] if digit >= base -> Error(InvalidBase)\n    [digit, ..rest] -> do_undigits(rest, base, acc * base + digit)\n  }\n}\n\n/// Returns `0` if `boundary_a` and `boundary_b` are equal,\n/// otherwise returns an `Int x` where `lower_boundary =< x < upper_boundary`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > random(1, 5)\n/// 2\n/// ```\n///\npub fn random(boundary_a: Int, boundary_b: Int) -> Int {\n  // Based on:\n  //\n  // ```javascript\n  // min = Math.ceil(min);\n  // max = Math.floor(max);\n  // return Math.floor(Math.random() * (max - min) + min); // The minimum is inclusive and the maximum is exclusive\n  // ```\n  //\n  // See: <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random#getting_a_random_integer_between_two_values>\n  let #(min, max) = case boundary_a, boundary_b {\n    a, b if a <= b -> #(a, b)\n    a, b if a > b -> #(b, a)\n  }\n\n  let min =\n    to_float(min)\n    |> float.ceiling()\n  let max =\n    to_float(max)\n    |> float.floor()\n\n  float.random(min, max)\n  |> float.floor()\n  |> float.round()\n}\n\n/// Performs a truncated integer division.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > divide(0, 1)\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > divide(1, 0)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > divide(5, 2)\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > divide(-99, 2)\n/// Ok(-49)\n/// ```\n///\npub fn divide(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    divisor -> Ok(dividend / divisor)\n  }\n}\n\n/// Computes the remainder of an integer division of inputs as a `Result`.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// Most the time you will want to use the `%` operator instead of this\n/// function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > remainder(3, 2)\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > remainder(1, 0)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > remainder(10, -1)\n/// Ok(0)\n/// ```\n///\n/// ```gleam\n/// > remainder(13, by: 3)\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > remainder(-13, by: 3)\n/// Ok(-1)\n/// ```\n///\n/// ```gleam\n/// > remainder(13, by: -3)\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > remainder(-13, by: -3)\n/// Ok(-1)\n/// ```\n///\npub fn remainder(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    divisor -> Ok(dividend % divisor)\n  }\n}\n\n/// Computes the modulo of an integer division of inputs as a `Result`.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// Most the time you will want to use the `%` operator instead of this\n/// function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > modulo(3, 2)\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > modulo(1, 0)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > modulo(10, -1)\n/// Ok(0)\n/// ```\n///\n/// ```gleam\n/// > modulo(13, by: 3)\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > modulo(-13, by: 3)\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > modulo(13, by: -3)\n/// Ok(-2)\n/// ```\n///\n/// ```gleam\n/// > modulo(-13, by: -3)\n/// Ok(-1)\n/// ```\n///\npub fn modulo(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    _ -> {\n      let remainder = dividend % divisor\n      case remainder * divisor < 0 {\n        True -> Ok(remainder + divisor)\n        False -> Ok(remainder)\n      }\n    }\n  }\n}\n\n/// Performs a *floored* integer division, which means that the result will\n/// always be rounded towards negative infinity.\n///\n/// If you want to perform truncated integer division (rounding towards zero),\n/// use `int.divide()` or the `/` operator instead.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > floor_divide(1, 0)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > floor_divide(5, 2)\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > floor_divide(6, -4)\n/// Ok(-2)\n/// ```\n///\n/// ```gleam\n/// > floor_divide(-99, 2)\n/// Ok(-50)\n/// ```\n///\npub fn floor_divide(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    divisor ->\n      case dividend * divisor < 0 && dividend % divisor != 0 {\n        True -> Ok(dividend / divisor - 1)\n        False -> Ok(dividend / divisor)\n      }\n  }\n}\n\n/// Adds two integers together.\n///\n/// It's the function equivalent of the `+` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > add(1, 2)\n/// 3\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n/// > list.fold([1, 2, 3], 0, add)\n/// 6\n/// ```\n///\n/// ```gleam\n/// > 3 |> add(2)\n/// 5\n/// ```\n///\npub fn add(a: Int, b: Int) -> Int {\n  a + b\n}\n\n/// Multiplies two integers together.\n///\n/// It's the function equivalent of the `*` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > multiply(2, 4)\n/// 8\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n/// > list.fold([2, 3, 4], 1, multiply)\n/// 24\n/// ```\n///\n/// ```gleam\n/// > 3 |> multiply(2)\n/// 6\n/// ```\n///\npub fn multiply(a: Int, b: Int) -> Int {\n  a * b\n}\n\n/// Subtracts one int from another.\n///\n/// It's the function equivalent of the `-` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > subtract(3, 1)\n/// 2.0\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n/// > list.fold([1, 2, 3], 10, subtract)\n/// 4\n/// ```\n///\n/// ```gleam\n/// > 3 |> subtract(2)\n/// 1\n/// ```\n///\n/// ```gleam\n/// > 3 |> subtract(2, _)\n/// -1\n/// ```\n///\npub fn subtract(a: Int, b: Int) -> Int {\n  a - b\n}\n" (Durability(0))    
2023-08-04T09:30:46.269819Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.269828Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R126    
2023-08-04T09:30:46.269837Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(30)) = "import gleam/list\n\n/// A queue is an ordered collection of elements. It is similar to a list, but\n/// unlike a list elements can be added to or removed from either the front or\n/// the back in a performant fashion.\n///\n/// The internal representation may be different for two queues with the same\n/// elements in the same order if the queues were constructed in different\n/// ways. This is the price paid for a queue's fast access at both the front\n/// and the back.\n///\n/// Because of unpredictable internal representation the equality operator `==`\n/// may return surprising results, and the `is_equal` and `is_logically_equal`\n/// functions are the recommended way to test queues for equality.\n///\npub opaque type Queue(element) {\n  Queue(in: List(element), out: List(element))\n}\n\n/// Creates a fresh queue that contains no values.\n///\npub fn new() -> Queue(a) {\n  Queue(in: [], out: [])\n}\n\n/// Converts a list of elements into a queue of the same elements in the same\n/// order. The first element in the list becomes the front element in the queue.\n///\n/// This function runs in constant time.\n///\n/// # Examples\n///\n/// ```gleam\n/// > [1, 2, 3] |> from_list |> length\n/// 3\n/// ```\n///\npub fn from_list(list: List(a)) -> Queue(a) {\n  Queue(in: [], out: list)\n}\n\n/// Converts a queue of elements into a list of the same elements in the same\n/// order. The front element in the queue becomes the first element in the list.\n///\n/// This function runs in linear time.\n///\n/// # Examples\n///\n/// ```gleam\n/// > new() |> push_back(1) |> push_back(2) |> to_list\n/// [1, 2]\n/// ```\n///\npub fn to_list(queue: Queue(a)) -> List(a) {\n  queue.out\n  |> list.append(list.reverse(queue.in))\n}\n\n/// Determines whether or not the queue is empty.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [] |> from_list |> is_empty\n/// True\n/// ```\n///\n/// ```gleam\n/// > [1] |> from_list |> is_empty\n/// False\n/// ```\n///\n/// ```gleam\n/// > [1, 2] |> from_list |> is_empty\n/// False\n/// ```\n///\npub fn is_empty(queue: Queue(a)) -> Bool {\n  queue.in == [] && queue.out == []\n}\n\n/// Counts the number of elements in a given queue.\n///\n/// This function has to traverse the queue to determine the number of elements,\n/// so it runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > length(from_list([]))\n/// 0\n/// ```\n///\n/// ```gleam\n/// > length(from_list([1]))\n/// 1\n/// ```\n///\n/// ```gleam\n/// > length(from_list([1, 2]))\n/// 2\n/// ```\n///\npub fn length(queue: Queue(a)) -> Int {\n  list.length(queue.in) + list.length(queue.out)\n}\n\n/// Pushes an element onto the back of the queue.\n///\n/// # Examples\n///\n/// ```gleam\n/// > [1, 2] |> from_list |> push_back(3) |> to_list\n/// [1, 2, 3]\n/// ```\n///\npub fn push_back(onto queue: Queue(a), this item: a) -> Queue(a) {\n  Queue(in: [item, ..queue.in], out: queue.out)\n}\n\n/// Pushes an element onto the front of the queue.\n///\n/// # Examples\n///\n/// ```gleam\n/// > [0, 0] |> from_list |> push_front(1) |> to_list\n/// [1, 0, 0]\n/// ```\n///\npub fn push_front(onto queue: Queue(a), this item: a) -> Queue(a) {\n  Queue(in: queue.in, out: [item, ..queue.out])\n}\n\n/// Gets the last element from the queue, returning the\n/// element and a new queue without that element.\n///\n/// This function typically runs in constant time, but will occasionally run in\n/// linear time.\n///\n/// # Examples\n///\n/// ```gleam\n/// > new()\n/// > |> push_back(0)\n/// > |> push_back(1)\n/// > |> pop_back()\n/// Ok(#(1, push_front(new(), 0)))\n/// ```\n///\n/// ```gleam\n/// > new()\n/// > |> push_front(0)\n/// > |> pop_back()\n/// Ok(#(0, new()))\n/// ```\n///\n/// ```gleam\n/// > new()\n/// > |> pop_back()\n/// Error(Nil)\n/// ```\n///\npub fn pop_back(from queue: Queue(a)) -> Result(#(a, Queue(a)), Nil) {\n  case queue {\n    Queue(in: [], out: []) -> Error(Nil)\n    Queue(in: [], out: out) -> pop_back(Queue(in: list.reverse(out), out: []))\n    Queue(in: [first, ..rest], out: out) -> {\n      let queue = Queue(in: rest, out: out)\n      Ok(#(first, queue))\n    }\n  }\n}\n\n/// Gets the first element from the queue, returning the\n/// element and a new queue without that element.\n///\n/// This function typically runs in constant time, but will occasionally run in\n/// linear time.\n///\n/// # Examples\n///\n/// ```gleam\n/// > queue.new()\n/// > |> queue.push_front(1)\n/// > |> queue.push_front(0)\n/// > |> queue.pop_front()\n/// Ok(#(0, queue.push_back(queue.new(), 1)))\n/// ```\n///\n/// ```gleam\n/// > queue.new()\n/// > |> queue.push_back(0)\n/// > |> queue.pop_front()\n/// Ok(#(0, queue.new()))\n/// ```\n///\n/// ```gleam\n/// > queue.new()\n/// > |> queue.pop_back()\n/// Error(Nil)\n/// ```\n///\npub fn pop_front(from queue: Queue(a)) -> Result(#(a, Queue(a)), Nil) {\n  case queue {\n    Queue(in: [], out: []) -> Error(Nil)\n    Queue(in: in, out: []) -> pop_front(Queue(in: [], out: list.reverse(in)))\n    Queue(in: in, out: [first, ..rest]) -> {\n      let queue = Queue(in: in, out: rest)\n      Ok(#(first, queue))\n    }\n  }\n}\n\n/// Creates a new queue from a given queue containing the same elements, but in\n/// the opposite order.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [] |> from_list |> reverse |> to_list\n/// []\n/// ```\n///\n/// ```gleam\n/// > [1] |> from_list |> reverse |> to_list\n/// [1]\n/// ```\n///\n/// ```gleam\n/// > [1, 2] |> from_list |> reverse |> to_list\n/// [2, 1]\n/// ```\n///\npub fn reverse(queue: Queue(a)) -> Queue(a) {\n  Queue(in: queue.out, out: queue.in)\n}\n\nfn check_equal(\n  xs: List(t),\n  x_tail: List(t),\n  ys: List(t),\n  y_tail: List(t),\n  eq: fn(t, t) -> Bool,\n) -> Bool {\n  case xs, x_tail, ys, y_tail {\n    [], [], [], [] -> True\n    [x, ..xs], _, [y, ..ys], _ ->\n      case eq(x, y) {\n        False -> False\n        True -> check_equal(xs, x_tail, ys, y_tail, eq)\n      }\n    [], [_, ..], _, _ -> check_equal(list.reverse(x_tail), [], ys, y_tail, eq)\n    _, _, [], [_, ..] -> check_equal(xs, x_tail, list.reverse(y_tail), [], eq)\n    _, _, _, _ -> False\n  }\n}\n\n/// Checks whether two queues have equal elements in the same order, where the\n/// equality of elements is determined by a given equality checking function.\n///\n/// This function is useful as the internal representation may be different for\n/// two queues with the same elements in the same order depending on how they\n/// were constructed, so the equality operator `==` may return surprising\n/// results.\n///\n/// This function runs in linear time multiplied by the time taken by the\n/// element equality checking function.\n///\npub fn is_logically_equal(\n  a: Queue(t),\n  to b: Queue(t),\n  checking element_is_equal: fn(t, t) -> Bool,\n) -> Bool {\n  check_equal(a.out, a.in, b.out, b.in, element_is_equal)\n}\n\n/// Checks whether two queues have the same elements in the same order.\n///\n/// This function is useful as the internal representation may be different for\n/// two queues with the same elements in the same order depending on how they\n/// were constructed, so the equality operator `==` may return surprising\n/// results.\n///\n/// This function runs in linear time.\n///\npub fn is_equal(a: Queue(t), to b: Queue(t)) -> Bool {\n  check_equal(a.out, a.in, b.out, b.in, fn(a, b) { a == b })\n}\n" (Durability(0))    
2023-08-04T09:30:46.269935Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.269943Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R127    
2023-08-04T09:30:46.269952Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(31)) = "//// BitBuilder is a type used for efficiently concatenating bits to create bit\n//// strings.\n////\n//// If we append one bit string to another the bit strings must be copied to a\n//// new location in memory so that they can sit together. This behaviour\n//// enables efficient reading of the string but copying can be expensive,\n//// especially if we want to join many bit strings together.\n////\n//// BitBuilder is different in that it can be joined together in constant\n//// time using minimal memory, and then can be efficiently converted to a\n//// bit string using the `to_bit_string` function.\n////\n//// On Erlang this type is compatible with Erlang's iolists.\n\nimport gleam/string_builder.{StringBuilder}\n\nif javascript {\n  import gleam/list\n  import gleam/bit_string\n}\n\nif erlang {\n  pub external type BitBuilder\n}\n\nif javascript {\n  pub opaque type BitBuilder {\n    Bits(BitString)\n    Text(StringBuilder)\n    Many(List(BitBuilder))\n  }\n}\n\n/// Create an empty `BitBuilder`. Useful as the start of a pipe chaning many\n/// builders together.\n///\npub fn new() -> BitBuilder {\n  do_concat([])\n}\n\n/// Prepends a bit string to the start of a builder.\n///\n/// Runs in constant time.\n///\npub fn prepend(to: BitBuilder, prefix: BitString) -> BitBuilder {\n  append_builder(from_bit_string(prefix), to)\n}\n\n/// Appends a bit string to the end of a builder.\n///\n/// Runs in constant time.\n///\npub fn append(to: BitBuilder, suffix: BitString) -> BitBuilder {\n  append_builder(to, from_bit_string(suffix))\n}\n\n/// Prepends a builder onto the start of another.\n///\n/// Runs in constant time.\n///\npub fn prepend_builder(to: BitBuilder, prefix: BitBuilder) -> BitBuilder {\n  append_builder(prefix, to)\n}\n\n/// Appends a builder onto the end of another.\n///\n/// Runs in constant time.\n///\npub fn append_builder(\n  to first: BitBuilder,\n  suffix second: BitBuilder,\n) -> BitBuilder {\n  do_append_builder(first, second)\n}\n\nif erlang {\n  external fn do_append_builder(\n    to: BitBuilder,\n    suffix: BitBuilder,\n  ) -> BitBuilder =\n    \"gleam_stdlib\" \"iodata_append\"\n}\n\nif javascript {\n  fn do_append_builder(first: BitBuilder, second: BitBuilder) -> BitBuilder {\n    case second {\n      Many(builders) -> Many([first, ..builders])\n      _ -> Many([first, second])\n    }\n  }\n}\n\n/// Prepends a string onto the start of a builder.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time with the length of the string otherwise.\n///\npub fn prepend_string(to: BitBuilder, prefix: String) -> BitBuilder {\n  append_builder(from_string(prefix), to)\n}\n\n/// Appends a string onto the end of a builder.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time with the length of the string otherwise.\n///\npub fn append_string(to: BitBuilder, suffix: String) -> BitBuilder {\n  append_builder(to, from_string(suffix))\n}\n\n/// Joins a list of builders into a single builder.\n///\n/// Runs in constant time.\n///\npub fn concat(builders: List(BitBuilder)) -> BitBuilder {\n  do_concat(builders)\n}\n\nif erlang {\n  external fn do_concat(List(BitBuilder)) -> BitBuilder =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  fn do_concat(builders: List(BitBuilder)) -> BitBuilder {\n    Many(builders)\n  }\n}\n\n/// Joins a list of bit strings into a single builder.\n///\n/// Runs in constant time.\n///\npub fn concat_bit_strings(bits: List(BitString)) -> BitBuilder {\n  do_concat_bit_strings(bits)\n}\n\nif erlang {\n  external fn do_concat_bit_strings(List(BitString)) -> BitBuilder =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  fn do_concat_bit_strings(bits: List(BitString)) -> BitBuilder {\n    bits\n    |> list.map(fn(b) { from_bit_string(b) })\n    |> concat()\n  }\n}\n\n/// Creates a new builder from a string.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time otherwise.\n///\npub fn from_string(string: String) -> BitBuilder {\n  do_from_string(string)\n}\n\nif erlang {\n  external fn do_from_string(String) -> BitBuilder =\n    \"gleam_stdlib\" \"wrap_list\"\n}\n\nif javascript {\n  fn do_from_string(string: String) -> BitBuilder {\n    Text(string_builder.from_string(string))\n  }\n}\n\n/// Creates a new builder from a string builder.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time otherwise.\n///\npub fn from_string_builder(builder: StringBuilder) -> BitBuilder {\n  do_from_string_builder(builder)\n}\n\nif erlang {\n  external fn do_from_string_builder(StringBuilder) -> BitBuilder =\n    \"gleam_stdlib\" \"wrap_list\"\n}\n\nif javascript {\n  fn do_from_string_builder(builder: StringBuilder) -> BitBuilder {\n    Text(builder)\n  }\n}\n\n/// Creates a new builder from a bit string.\n///\n/// Runs in constant time.\n///\npub fn from_bit_string(bits: BitString) -> BitBuilder {\n  do_from_bit_string(bits)\n}\n\nif erlang {\n  external fn do_from_bit_string(BitString) -> BitBuilder =\n    \"gleam_stdlib\" \"wrap_list\"\n}\n\nif javascript {\n  fn do_from_bit_string(bits: BitString) -> BitBuilder {\n    Bits(bits)\n  }\n}\n\n/// Turns an builder into a bit string.\n///\n/// Runs in linear time.\n///\n/// When running on Erlang this function is implemented natively by the\n/// virtual machine and is highly optimised.\n///\npub fn to_bit_string(builder: BitBuilder) -> BitString {\n  do_to_bit_string(builder)\n}\n\nif erlang {\n  external fn do_to_bit_string(BitBuilder) -> BitString =\n    \"erlang\" \"list_to_bitstring\"\n}\n\nif javascript {\n  fn do_to_bit_string(builder: BitBuilder) -> BitString {\n    [[builder]]\n    |> to_list([])\n    |> list.reverse\n    |> bit_string.concat\n  }\n\n  fn to_list(\n    stack: List(List(BitBuilder)),\n    acc: List(BitString),\n  ) -> List(BitString) {\n    case stack {\n      [] -> acc\n\n      [[], ..remaining_stack] -> to_list(remaining_stack, acc)\n\n      [[Bits(bits), ..rest], ..remaining_stack] ->\n        to_list([rest, ..remaining_stack], [bits, ..acc])\n\n      [[Text(builder), ..rest], ..remaining_stack] -> {\n        let bits = bit_string.from_string(string_builder.to_string(builder))\n        to_list([rest, ..remaining_stack], [bits, ..acc])\n      }\n\n      [[Many(builders), ..rest], ..remaining_stack] ->\n        to_list([builders, rest, ..remaining_stack], acc)\n    }\n  }\n}\n\n/// Returns the size of the builder's content in bytes.\n///\n/// Runs in linear time.\n///\npub fn byte_size(builder: BitBuilder) -> Int {\n  do_byte_size(builder)\n}\n\nif erlang {\n  external fn do_byte_size(BitBuilder) -> Int =\n    \"erlang\" \"iolist_size\"\n}\n\nif javascript {\n  fn do_byte_size(builder: BitBuilder) -> Int {\n    [[builder]]\n    |> to_list([])\n    |> list.fold(0, fn(acc, builder) { bit_string.byte_size(builder) + acc })\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.270044Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.270052Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R128    
2023-08-04T09:30:46.270061Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(32)) = "//// Strings in Gleam are UTF-8 binaries. They can be written in your code as\n//// text surrounded by `\"double quotes\"`.\n\nimport gleam/iterator.{Iterator}\nimport gleam/list\nimport gleam/option.{None, Option, Some}\nimport gleam/order\nimport gleam/string_builder.{StringBuilder}\n\nif erlang {\n  import gleam/bit_string\n  import gleam/dynamic.{Dynamic}\n  import gleam/result\n}\n\n/// Determines if a `String` is empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_empty(\"\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > is_empty(\"the world\")\n/// False\n/// ```\n///\npub fn is_empty(str: String) -> Bool {\n  str == \"\"\n}\n\n/// Gets the number of grapheme clusters in a given `String`.\n///\n/// This function has to iterate across the whole string to count the number of\n/// graphemes, so it runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > length(\"Gleam\")\n/// 5\n/// ```\n///\n/// ```gleam\n/// > length(\"ß↑e\u{30a}\")\n/// 3\n/// ```\n///\n/// ```gleam\n/// > length(\"\")\n/// 0\n/// ```\n///\npub fn length(string: String) -> Int {\n  do_length(string)\n}\n\nif erlang {\n  external fn do_length(String) -> Int =\n    \"string\" \"length\"\n}\n\nif javascript {\n  external fn do_length(String) -> Int =\n    \"../gleam_stdlib.mjs\" \"string_length\"\n}\n\n/// Reverses a `String`.\n///\n/// This function has to iterate across the whole `String` so it runs in linear\n/// time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > reverse(\"stressed\")\n/// \"desserts\"\n/// ```\n///\npub fn reverse(string: String) -> String {\n  do_reverse(string)\n}\n\nif erlang {\n  fn do_reverse(string: String) -> String {\n    string\n    |> string_builder.from_string\n    |> string_builder.reverse\n    |> string_builder.to_string\n  }\n}\n\nif javascript {\n  fn do_reverse(string: String) -> String {\n    string\n    |> to_graphemes\n    |> list.reverse\n    |> concat\n  }\n}\n\n/// Creates a new `String` by replacing all occurrences of a given substring.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > replace(\"www.example.com\", each: \".\", with: \"-\")\n/// \"www-example-com\"\n/// ```\n///\n/// ```gleam\n/// > replace(\"a,b,c,d,e\", each: \",\", with: \"/\")\n/// \"a/b/c/d/e\"\n/// ```\n///\npub fn replace(\n  in string: String,\n  each pattern: String,\n  with substitute: String,\n) -> String {\n  string\n  |> string_builder.from_string\n  |> string_builder.replace(each: pattern, with: substitute)\n  |> string_builder.to_string\n}\n\n/// Creates a new `String` with all the graphemes in the input `String` converted to\n/// lowercase.\n///\n/// Useful for case-insensitive comparisons.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > lowercase(\"X-FILES\")\n/// \"x-files\"\n/// ```\n///\npub fn lowercase(string: String) -> String {\n  do_lowercase(string)\n}\n\nif erlang {\n  external fn do_lowercase(String) -> String =\n    \"string\" \"lowercase\"\n}\n\nif javascript {\n  external fn do_lowercase(String) -> String =\n    \"../gleam_stdlib.mjs\" \"lowercase\"\n}\n\n/// Creates a new `String` with all the graphemes in the input `String` converted to\n/// uppercase.\n///\n/// Useful for case-insensitive comparisons and VIRTUAL YELLING.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > uppercase(\"skinner\")\n/// \"SKINNER\"\n/// ```\n///\npub fn uppercase(string: String) -> String {\n  do_uppercase(string)\n}\n\nif erlang {\n  external fn do_uppercase(String) -> String =\n    \"string\" \"uppercase\"\n}\n\nif javascript {\n  external fn do_uppercase(String) -> String =\n    \"../gleam_stdlib.mjs\" \"uppercase\"\n}\n\n/// Compares two `String`s to see which is \"larger\" by comparing their graphemes.\n///\n/// This does not compare the size or length of the given `String`s.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > compare(\"Anthony\", \"Anthony\")\n/// order.Eq\n/// ```\n///\n/// ```gleam\n/// > compare(\"A\", \"B\")\n/// order.Lt\n/// ```\n///\npub fn compare(a: String, b: String) -> order.Order {\n  case a == b {\n    True -> order.Eq\n    _ ->\n      case less_than(a, b) {\n        True -> order.Lt\n        _ -> order.Gt\n      }\n  }\n}\n\nif erlang {\n  external fn less_than(String, String) -> Bool =\n    \"gleam_stdlib\" \"less_than\"\n}\n\nif javascript {\n  external fn less_than(String, String) -> Bool =\n    \"../gleam_stdlib.mjs\" \"less_than\"\n}\n\n/// Takes a substring given a start and end grapheme indexes. Negative indexes\n/// are taken starting from the *end* of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > slice(from: \"gleam\", at_index: 1, length: 2)\n/// \"le\"\n/// ```\n///\n/// ```gleam\n/// > slice(from: \"gleam\", at_index: 1, length: 10)\n/// \"leam\"\n/// ```\n///\n/// ```gleam\n/// > slice(from: \"gleam\", at_index: 10, length: 3)\n/// \"\"\n/// ```\n///\n/// ```gleam\n/// > slice(from: \"gleam\", at_index: -2, length: 2)\n/// \"am\"\n/// ```\n///\n/// ```gleam\n/// > slice(from: \"gleam\", at_index: -12, length: 2)\n/// \"\"\n/// ```\n///\npub fn slice(from string: String, at_index idx: Int, length len: Int) -> String {\n  case len < 0 {\n    True -> \"\"\n    False ->\n      case idx < 0 {\n        True -> {\n          let translated_idx = length(string) + idx\n          case translated_idx < 0 {\n            True -> \"\"\n            False -> do_slice(string, translated_idx, len)\n          }\n        }\n        False -> do_slice(string, idx, len)\n      }\n  }\n}\n\nif erlang {\n  external fn do_slice(String, Int, Int) -> String =\n    \"string\" \"slice\"\n}\n\nif javascript {\n  fn do_slice(string: String, idx: Int, len: Int) -> String {\n    string\n    |> to_graphemes\n    |> list.drop(idx)\n    |> list.take(len)\n    |> concat\n  }\n}\n\n/// Drops contents of the first `String` that occur before the second `String`.\n/// If the `from` string does not contain the `before` string, `from` is returned unchanged.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > crop(from: \"The Lone Gunmen\", before: \"Lone\")\n/// \"Lone Gunmen\"\n/// ```\n///\npub fn crop(from string: String, before substring: String) -> String {\n  do_crop(string, substring)\n}\n\nif erlang {\n  fn do_crop(string: String, substring: String) -> String {\n    string\n    |> erl_contains(substring)\n    |> dynamic.string()\n    |> result.unwrap(string)\n  }\n\n  external fn erl_contains(String, String) -> Dynamic =\n    \"string\" \"find\"\n}\n\nif javascript {\n  external fn do_crop(String, String) -> String =\n    \"../gleam_stdlib.mjs\" \"crop_string\"\n}\n\n/// Drops *n* graphemes from the left side of a `String`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > drop_left(from: \"The Lone Gunmen\", up_to: 2)\n/// \"e Lone Gunmen\"\n/// ```\n///\npub fn drop_left(from string: String, up_to num_graphemes: Int) -> String {\n  case num_graphemes < 0 {\n    True -> string\n    False -> slice(string, num_graphemes, length(string) - num_graphemes)\n  }\n}\n\n/// Drops *n* graphemes from the right side of a `String`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > drop_right(from: \"Cigarette Smoking Man\", up_to: 2)\n/// \"Cigarette Smoking M\"\n/// ```\n///\npub fn drop_right(from string: String, up_to num_graphemes: Int) -> String {\n  case num_graphemes < 0 {\n    True -> string\n    False -> slice(string, 0, length(string) - num_graphemes)\n  }\n}\n\n/// Checks if the first `String` contains the second.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > contains(does: \"theory\", contain: \"ory\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > contains(does: \"theory\", contain: \"the\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > contains(does: \"theory\", contain: \"THE\")\n/// False\n/// ```\n///\npub fn contains(does haystack: String, contain needle: String) -> Bool {\n  do_contains(haystack, needle)\n}\n\nif erlang {\n  fn do_contains(haystack: String, needle: String) -> Bool {\n    haystack\n    |> erl_contains(needle)\n    |> dynamic.bit_string\n    |> result.is_ok\n  }\n}\n\nif javascript {\n  fn do_contains(haystack: String, needle: String) -> Bool {\n    index_of(haystack, needle) != -1\n  }\n\n  external fn index_of(String, String) -> Int =\n    \"../gleam_stdlib.mjs\" \"index_of\"\n}\n\n/// Checks whether the first `String` starts with the second one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > starts_with(\"theory\", \"ory\")\n/// False\n/// ```\n///\npub fn starts_with(string: String, prefix: String) -> Bool {\n  do_starts_with(string, prefix)\n}\n\nif erlang {\n  external fn do_starts_with(String, String) -> Bool =\n    \"gleam_stdlib\" \"string_starts_with\"\n}\n\nif javascript {\n  external fn do_starts_with(String, String) -> Bool =\n    \"../gleam_stdlib.mjs\" \"starts_with\"\n}\n\n/// Checks whether the first `String` ends with the second one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > ends_with(\"theory\", \"ory\")\n/// True\n/// ```\n///\npub fn ends_with(string: String, suffix: String) -> Bool {\n  do_ends_with(string, suffix)\n}\n\nif erlang {\n  external fn do_ends_with(String, String) -> Bool =\n    \"gleam_stdlib\" \"string_ends_with\"\n}\n\nif javascript {\n  external fn do_ends_with(String, String) -> Bool =\n    \"../gleam_stdlib.mjs\" \"ends_with\"\n}\n\n/// Creates a list of `String`s by splitting a given string on a given substring.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > split(\"home/gleam/desktop/\", on: \"/\")\n/// [\"home\", \"gleam\", \"desktop\", \"\"]\n/// ```\n///\npub fn split(x: String, on substring: String) -> List(String) {\n  case substring {\n    \"\" -> to_graphemes(x)\n    _ ->\n      x\n      |> string_builder.from_string\n      |> string_builder.split(on: substring)\n      |> list.map(with: string_builder.to_string)\n  }\n}\n\n/// Splits a `String` a single time on the given substring.\n///\n/// Returns an `Error` if substring not present.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > split_once(\"home/gleam/desktop/\", on: \"/\")\n/// Ok(#(\"home\", \"gleam/desktop/\"))\n/// ```\n///\n/// ```gleam\n/// > split_once(\"home/gleam/desktop/\", on: \"?\")\n/// Error(Nil)\n/// ```\n///\npub fn split_once(\n  x: String,\n  on substring: String,\n) -> Result(#(String, String), Nil) {\n  do_split_once(x, substring)\n}\n\nif erlang {\n  external fn erl_split(String, String) -> List(String) =\n    \"string\" \"split\"\n\n  fn do_split_once(\n    x: String,\n    substring: String,\n  ) -> Result(#(String, String), Nil) {\n    case erl_split(x, substring) {\n      [first, rest] -> Ok(#(first, rest))\n      _ -> Error(Nil)\n    }\n  }\n}\n\nif javascript {\n  external fn do_split_once(\n    x: String,\n    substring: String,\n  ) -> Result(#(String, String), Nil) =\n    \"../gleam_stdlib.mjs\" \"split_once\"\n}\n\n/// Creates a new `String` by joining two `String`s together.\n///\n/// This function copies both `String`s and runs in linear time. If you find\n/// yourself joining `String`s frequently consider using the [`string_builder`](../gleam/string_builder.html)\n/// module as it can append `String`s much faster!\n///\n/// ## Examples\n///\n/// ```gleam\n/// > append(to: \"butter\", suffix: \"fly\")\n/// \"butterfly\"\n/// ```\n///\npub fn append(to first: String, suffix second: String) -> String {\n  first\n  |> string_builder.from_string\n  |> string_builder.append(second)\n  |> string_builder.to_string\n}\n\n/// Creates a new `String` by joining many `String`s together.\n///\n/// This function copies both `String`s and runs in linear time. If you find\n/// yourself joining `String`s frequently consider using the [`string_builder`](../gleam/string_builder.html)\n/// module as it can append `String`s much faster!\n///\n/// ## Examples\n///\n/// ```gleam\n/// > concat([\"never\", \"the\", \"less\"])\n/// \"nevertheless\"\n/// ```\n///\npub fn concat(strings: List(String)) -> String {\n  strings\n  |> string_builder.from_strings\n  |> string_builder.to_string\n}\n\n/// Creates a new `String` by repeating a `String` a given number of times.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > repeat(\"ha\", times: 3)\n/// \"hahaha\"\n/// ```\n///\npub fn repeat(string: String, times times: Int) -> String {\n  iterator.repeat(string)\n  |> iterator.take(times)\n  |> iterator.to_list\n  |> concat\n}\n\n/// Joins many `String`s together with a given separator.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > join([\"home\",\"evan\",\"Desktop\"], with: \"/\")\n/// \"home/evan/Desktop\"\n/// ```\n///\npub fn join(strings: List(String), with separator: String) -> String {\n  strings\n  |> list.intersperse(with: separator)\n  |> concat\n}\n\n/// Pads a `String` on the left until it has at least given number of graphemes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > pad_left(\"121\", to: 5, with: \".\")\n/// \"..121\"\n/// ```\n///\n/// ```gleam\n/// > pad_left(\"121\", to: 3, with: \".\")\n/// \"121\"\n/// ```\n///\n/// ```gleam\n/// > pad_left(\"121\", to: 2, with: \".\")\n/// \"121\"\n/// ```\n///\npub fn pad_left(string: String, to desired_length: Int, with pad_string: String) {\n  let current_length = length(string)\n  let to_pad_length = desired_length - current_length\n  padding(to_pad_length, pad_string)\n  |> iterator.append(iterator.single(string))\n  |> iterator.to_list\n  |> concat\n}\n\n/// Pads a `String` on the right until it has a given length.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > pad_right(\"123\", to: 5, with: \".\")\n/// \"123..\"\n/// ```\n///\n/// ```gleam\n/// > pad_right(\"123\", to: 3, with: \".\")\n/// \"123\"\n/// ```\n///\n/// ```gleam\n/// > pad_right(\"123\", to: 2, with: \".\")\n/// \"123\"\n/// ```\n///\npub fn pad_right(\n  string: String,\n  to desired_length: Int,\n  with pad_string: String,\n) {\n  let current_length = length(string)\n  let to_pad_length = desired_length - current_length\n  iterator.single(string)\n  |> iterator.append(padding(to_pad_length, pad_string))\n  |> iterator.to_list\n  |> concat\n}\n\nfn padding(size: Int, pad_string: String) -> Iterator(String) {\n  let pad_length = length(pad_string)\n  let num_pads = size / pad_length\n  let extra = size % pad_length\n  iterator.repeat(pad_string)\n  |> iterator.take(num_pads)\n  |> iterator.append(iterator.single(slice(pad_string, 0, extra)))\n}\n\n/// Removes whitespace on both sides of a `String`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > trim(\"  hats  \\n\")\n/// \"hats\"\n/// ```\n///\npub fn trim(string: String) -> String {\n  do_trim(string)\n}\n\nif erlang {\n  fn do_trim(string: String) -> String {\n    erl_trim(string, Both)\n  }\n\n  type Direction {\n    Leading\n    Trailing\n    Both\n  }\n\n  external fn erl_trim(String, Direction) -> String =\n    \"string\" \"trim\"\n}\n\nif javascript {\n  external fn do_trim(string: String) -> String =\n    \"../gleam_stdlib.mjs\" \"trim\"\n}\n\n/// Removes whitespace on the left of a `String`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > trim_left(\"  hats  \\n\")\n/// \"hats  \\n\"\n/// ```\n///\npub fn trim_left(string: String) -> String {\n  do_trim_left(string)\n}\n\nif erlang {\n  fn do_trim_left(string: String) -> String {\n    erl_trim(string, Leading)\n  }\n}\n\nif javascript {\n  external fn do_trim_left(string: String) -> String =\n    \"../gleam_stdlib.mjs\" \"trim_left\"\n}\n\n/// Removes whitespace on the right of a `String`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > trim_right(\"  hats  \\n\")\n/// \"  hats\"\n/// ```\n///\npub fn trim_right(string: String) -> String {\n  do_trim_right(string)\n}\n\nif erlang {\n  fn do_trim_right(string: String) -> String {\n    erl_trim(string, Trailing)\n  }\n}\n\nif javascript {\n  external fn do_trim_right(string: String) -> String =\n    \"../gleam_stdlib.mjs\" \"trim_right\"\n}\n\n/// Splits a non-empty `String` into its head and tail. This lets you\n/// pattern match on `String`s exactly as you would with lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > pop_grapheme(\"gleam\")\n/// Ok(#(\"g\", \"leam\"))\n/// ```\n///\n/// ```gleam\n/// > pop_grapheme(\"\")\n/// Error(Nil)\n/// ```\n///\npub fn pop_grapheme(string: String) -> Result(#(String, String), Nil) {\n  do_pop_grapheme(string)\n}\n\nif erlang {\n  external fn do_pop_grapheme(string: String) -> Result(#(String, String), Nil) =\n    \"gleam_stdlib\" \"string_pop_grapheme\"\n}\n\nif javascript {\n  external fn do_pop_grapheme(string: String) -> Result(#(String, String), Nil) =\n    \"../gleam_stdlib.mjs\" \"pop_grapheme\"\n}\n\n/// Converts a `String` to a list of\n/// [graphemes](https://en.wikipedia.org/wiki/Grapheme).\n///\n/// ```gleam\n/// > to_graphemes(\"abc\")\n/// [\"a\", \"b\", \"c\"]\n/// ```\n///\npub fn to_graphemes(string: String) -> List(String) {\n  do_to_graphemes(string, [])\n  |> list.reverse\n}\n\nfn do_to_graphemes(string: String, acc: List(String)) -> List(String) {\n  case pop_grapheme(string) {\n    Ok(#(grapheme, rest)) -> do_to_graphemes(rest, [grapheme, ..acc])\n    _ -> acc\n  }\n}\n\nif erlang {\n  external fn unsafe_int_to_utf_codepoint(Int) -> UtfCodepoint =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn unsafe_int_to_utf_codepoint(Int) -> UtfCodepoint =\n    \"../gleam_stdlib.mjs\" \"codepoint\"\n}\n\n/// Converts a `String` to a `List` of `UtfCodepoint`.\n///\n/// See <https://en.wikipedia.org/wiki/Code_point> and\n/// <https://en.wikipedia.org/wiki/Unicode#Codespace_and_Code_Points> for an\n/// explanation on code points.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > \"a\" |> to_utf_codepoints\n/// [UtfCodepoint(97)]\n/// ```\n///\n/// ```gleam\n/// // Semantically the same as:\n/// // [\"🏳\", \"\u{fe0f}\", \"\u{200d}\", \"🌈\"] or:\n/// // [waving_white_flag, variant_selector_16, zero_width_joiner, rainbow]\n/// > \"🏳\u{fe0f}\u{200d}🌈\" |> to_utf_codepoints\n/// [UtfCodepoint(127987), UtfCodepoint(65039), UtfCodepoint(8205), UtfCodepoint(127752)]\n/// ```\n///\npub fn to_utf_codepoints(string: String) -> List(UtfCodepoint) {\n  do_to_utf_codepoints(string)\n}\n\nif erlang {\n  fn do_to_utf_codepoints(string: String) -> List(UtfCodepoint) {\n    do_to_utf_codepoints_impl(bit_string.from_string(string), [])\n    |> list.reverse\n  }\n\n  fn do_to_utf_codepoints_impl(\n    bit_string: BitString,\n    acc: List(UtfCodepoint),\n  ) -> List(UtfCodepoint) {\n    case bit_string {\n      <<first:utf8_codepoint, rest:binary>> ->\n        do_to_utf_codepoints_impl(rest, [first, ..acc])\n      <<>> -> acc\n    }\n  }\n}\n\nif javascript {\n  fn do_to_utf_codepoints(string: String) -> List(UtfCodepoint) {\n    string\n    |> string_to_codepoint_integer_list\n    |> list.map(unsafe_int_to_utf_codepoint)\n  }\n\n  external fn string_to_codepoint_integer_list(String) -> List(Int) =\n    \"../gleam_stdlib.mjs\" \"string_to_codepoint_integer_list\"\n}\n\n/// Converts a `List` of `UtfCodepoint`s to a `String`.\n///\n/// See <https://en.wikipedia.org/wiki/Code_point> and\n/// <https://en.wikipedia.org/wiki/Unicode#Codespace_and_Code_Points> for an\n/// explanation on code points.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > {\n/// >   let assert #(Ok(a), Ok(b), Ok(c)) = #(\n/// >     utf_codepoint(97),\n/// >     utf_codepoint(98),\n/// >     utf_codepoint(99),\n/// >   )\n/// >   [a, b, c]\n/// > }\n/// > |> from_utf_codepoints\n/// \"abc\"\n/// ```\n///\npub fn from_utf_codepoints(utf_codepoints: List(UtfCodepoint)) -> String {\n  do_from_utf_codepoints(utf_codepoints)\n}\n\nif erlang {\n  fn do_from_utf_codepoints(utf_codepoints: List(UtfCodepoint)) -> String {\n    let assert Ok(string) =\n      do_from_utf_codepoints_impl(utf_codepoints, bit_string.from_string(\"\"))\n      |> bit_string.to_string\n    string\n  }\n\n  fn do_from_utf_codepoints_impl(\n    utf_codepoints: List(UtfCodepoint),\n    acc: BitString,\n  ) -> BitString {\n    case utf_codepoints {\n      [first, ..rest] ->\n        do_from_utf_codepoints_impl(\n          rest,\n          <<acc:bit_string, first:utf8_codepoint>>,\n        )\n      [] -> acc\n    }\n  }\n}\n\nif javascript {\n  fn do_from_utf_codepoints(utf_codepoints: List(UtfCodepoint)) -> String {\n    utf_codepoint_list_to_string(utf_codepoints)\n  }\n\n  external fn utf_codepoint_list_to_string(List(UtfCodepoint)) -> String =\n    \"../gleam_stdlib.mjs\" \"utf_codepoint_list_to_string\"\n}\n\n/// Converts an integer to a `UtfCodepoint`.\n///\n/// Returns an `Error` if the integer does not represent a valid UTF codepoint.\n///\npub fn utf_codepoint(value: Int) -> Result(UtfCodepoint, Nil) {\n  case value {\n    i if i > 1_114_111 -> Error(Nil)\n    65_534 | 65_535 -> Error(Nil)\n    i if i >= 55_296 && i <= 57_343 -> Error(Nil)\n    i -> Ok(unsafe_int_to_utf_codepoint(i))\n  }\n}\n\n/// Converts an UtfCodepoint to its ordinal code point value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > utf_codepoint_to_int(128013) |> to_utf_codepoint_int\n/// 128013\n/// ```\n///\npub fn utf_codepoint_to_int(cp: UtfCodepoint) -> Int {\n  do_utf_codepoint_to_int(cp)\n}\n\nif erlang {\n  external fn do_utf_codepoint_to_int(cp: UtfCodepoint) -> Int =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn do_utf_codepoint_to_int(cp: UtfCodepoint) -> Int =\n    \"../gleam_stdlib.mjs\" \"utf_codepoint_to_int\"\n}\n\n/// Converts a `String` into `Option(String)` where an empty `String` becomes\n/// `None`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_option(\"\")\n/// None\n/// ```\n///\n/// ```gleam\n/// > to_option(\"hats\")\n/// Some(\"hats\")\n/// ```\n///\npub fn to_option(s: String) -> Option(String) {\n  case s {\n    \"\" -> None\n    _ -> Some(s)\n  }\n}\n\n/// Returns the first grapheme cluster in a given `String` and wraps it in a\n/// `Result(String, Nil)`. If the `String` is empty, it returns `Error(Nil)`.\n/// Otherwise, it returns `Ok(String)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > first(\"\")\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > first(\"icecream\")\n/// Ok(\"i\")\n/// ```\n///\npub fn first(s: String) -> Result(String, Nil) {\n  case pop_grapheme(s) {\n    Ok(#(first, _)) -> Ok(first)\n    Error(e) -> Error(e)\n  }\n}\n\n/// Returns the last grapheme cluster in a given `String` and wraps it in a\n/// `Result(String, Nil)`. If the `String` is empty, it returns `Error(Nil)`.\n/// Otherwise, it returns `Ok(String)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > last(\"\")\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > last(\"icecream\")\n/// Ok(\"m\")\n/// ```\n///\npub fn last(s: String) -> Result(String, Nil) {\n  case pop_grapheme(s) {\n    Ok(#(first, \"\")) -> Ok(first)\n    Ok(#(_, rest)) -> Ok(slice(rest, -1, 1))\n    Error(e) -> Error(e)\n  }\n}\n\n/// Creates a new `String` with the first grapheme in the input `String`\n/// converted to uppercase and the remaining graphemes to lowercase.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > capitalise(\"mamouna\")\n/// \"Mamouna\"\n/// ```\n///\npub fn capitalise(s: String) -> String {\n  case pop_grapheme(s) {\n    Ok(#(first, rest)) -> append(to: uppercase(first), suffix: lowercase(rest))\n    _ -> \"\"\n  }\n}\n\n/// Returns a `String` representation of a term in Gleam syntax.\n///\npub fn inspect(term: anything) -> String {\n  do_inspect(term)\n  |> string_builder.to_string\n}\n\nif javascript {\n  external fn do_inspect(term: anything) -> StringBuilder =\n    \"../gleam.mjs\" \"inspect\"\n}\n\nif erlang {\n  external fn do_inspect(term: anything) -> StringBuilder =\n    \"gleam_stdlib\" \"inspect\"\n}\n" (Durability(0))    
2023-08-04T09:30:46.270345Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.270354Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R129    
2023-08-04T09:30:46.270362Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(33)) = "import gleam/bit_string\nimport gleam/string\n\n/// Encodes a BitString into a base 64 encoded string.\n///\npub fn encode64(input: BitString, padding: Bool) -> String {\n  let encoded = do_encode64(input)\n  case padding {\n    True -> encoded\n    False -> string.replace(encoded, \"=\", \"\")\n  }\n}\n\nif erlang {\n  external fn do_encode64(BitString) -> String =\n    \"base64\" \"encode\"\n}\n\nif javascript {\n  external fn do_encode64(BitString) -> String =\n    \"../gleam_stdlib.mjs\" \"encode64\"\n}\n\n/// Decodes a base 64 encoded string into a `BitString`.\n///\npub fn decode64(encoded: String) -> Result(BitString, Nil) {\n  let padded = case bit_string.byte_size(bit_string.from_string(encoded)) % 4 {\n    0 -> encoded\n    n -> string.append(encoded, string.repeat(\"=\", 4 - n))\n  }\n  do_decode64(padded)\n}\n\nif erlang {\n  external fn do_decode64(String) -> Result(BitString, Nil) =\n    \"gleam_stdlib\" \"base_decode64\"\n}\n\nif javascript {\n  external fn do_decode64(String) -> Result(BitString, Nil) =\n    \"../gleam_stdlib.mjs\" \"decode64\"\n}\n\n/// Encodes a `BitString` into a base 64 encoded string with URL and filename safe alphabet.\n///\npub fn url_encode64(input: BitString, padding: Bool) -> String {\n  encode64(input, padding)\n  |> string.replace(\"+\", \"-\")\n  |> string.replace(\"/\", \"_\")\n}\n\n/// Decodes a base 64 encoded string with URL and filename safe alphabet into a `BitString`.\n///\npub fn url_decode64(encoded: String) -> Result(BitString, Nil) {\n  encoded\n  |> string.replace(\"-\", \"+\")\n  |> string.replace(\"_\", \"/\")\n  |> decode64()\n}\n" (Durability(0))    
2023-08-04T09:30:46.270388Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.270395Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R130    
2023-08-04T09:30:46.270404Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(34)) = "//// This module contains regular expression matching functions for strings.\n//// The matching algorithms of the library are based on the PCRE library, but not\n//// all of the PCRE library is interfaced and some parts of the library go beyond\n//// what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used.\n\nimport gleam/option.{Option}\n\npub external type Regex\n\n/// The details about a particular match:\n///\npub type Match {\n  Match(\n    /// The full string of the match.\n    content: String,\n    /// A `Regex` can have subpatterns, sup-parts that are in parentheses.\n    submatches: List(Option(String)),\n  )\n}\n\n/// When a regular expression fails to compile:\n///\npub type CompileError {\n  CompileError(\n    /// The problem encountered that caused the compilation to fail\n    error: String,\n    /// The byte index into the string to where the problem was found\n    /// This value may not be correct in JavaScript environments.\n    byte_index: Int,\n  )\n}\n\npub type Options {\n  Options(case_insensitive: Bool, multi_line: Bool)\n}\n\n/// Creates a `Regex` with some additional options.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let options = Options(case_insensitive: False, multi_line: True)\n/// > let assert Ok(re) = compile(\"^[0-9]\", with: options)\n/// > check(re, \"abc\\n123\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > let options = Options(case_insensitive: True, multi_line: False)\n/// > let assert Ok(re) = compile(\"[A-Z]\", with: options)\n/// > check(re, \"abc123\")\n/// True\n/// ```\n///\npub fn compile(\n  pattern: String,\n  with options: Options,\n) -> Result(Regex, CompileError) {\n  do_compile(pattern, options)\n}\n\nif erlang {\n  external fn do_compile(String, with: Options) -> Result(Regex, CompileError) =\n    \"gleam_stdlib\" \"compile_regex\"\n}\n\nif javascript {\n  external fn do_compile(String, with: Options) -> Result(Regex, CompileError) =\n    \"../gleam_stdlib.mjs\" \"compile_regex\"\n}\n\n/// Creates a new `Regex`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let assert Ok(re) = from_string(\"[0-9]\")\n/// > check(re, \"abc123\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > check(re, \"abcxyz\")\n/// False\n/// ```\n///\n/// ```gleam\n/// > from_string(\"[0-9\")\n/// Error(\n///   CompileError(\n///     error: \"missing terminating ] for character class\",\n///     byte_index: 4\n///   )\n/// )\n/// ```\n///\npub fn from_string(pattern: String) -> Result(Regex, CompileError) {\n  compile(pattern, Options(case_insensitive: False, multi_line: False))\n}\n\n/// Returns a boolean indicating whether there was a match or not.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let assert Ok(re) = from_string(\"^f.o.?\")\n/// > check(with: re, content: \"foo\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > check(with: re, content: \"boo\")\n/// False\n/// ```\n///\npub fn check(with regex: Regex, content content: String) -> Bool {\n  do_check(regex, content)\n}\n\nif erlang {\n  external fn do_check(Regex, String) -> Bool =\n    \"gleam_stdlib\" \"regex_check\"\n}\n\nif javascript {\n  external fn do_check(Regex, String) -> Bool =\n    \"../gleam_stdlib.mjs\" \"regex_check\"\n}\n\n/// Splits a string.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let assert Ok(re) = from_string(\" *, *\")\n/// > split(with: re, content: \"foo,32, 4, 9  ,0\")\n/// [\"foo\", \"32\", \"4\", \"9\", \"0\"]\n/// ```\n///\npub fn split(with regex: Regex, content string: String) -> List(String) {\n  do_split(regex, string)\n}\n\nif erlang {\n  external fn do_split(Regex, String) -> List(String) =\n    \"gleam_stdlib\" \"regex_split\"\n}\n\nif javascript {\n  fn do_split(regex, string) -> List(String) {\n    js_split(string, regex)\n  }\n\n  external fn js_split(String, Regex) -> List(String) =\n    \"../gleam_stdlib.mjs\" \"split\"\n}\n\n/// Collects all matches of the regular expression.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let assert Ok(re) = from_string(\"[oi]n a (\\\\w+)\")\n/// > scan(with: re, content: \"I am on a boat in a lake.\")\n/// [\n///   Match(\n///     content: \"on a boat\",\n///     submatches: [Some(\"boat\")]\n///   ),\n///   Match(\n///     content: \"in a lake\",\n///     submatches: [Some(\"lake\")]\n///   )\n/// ]\n/// ```\n///\n/// ```gleam\n/// > let assert Ok(re) = regex.from_string(\"([+|\\\\-])?(\\\\d+)(\\\\w+)?\")\n/// > scan(with: re, content: \"-36\")\n/// [\n///   Match(\n///     content: \"-36\",\n///     submatches: [Some(\"-\"), Some(\"36\")]\n///   )\n/// ]\n///\n/// > scan(with: re, content: \"36\")\n/// [\n///   Match(\n///     content: \"36\",\n///     submatches: [None, Some(\"36\")]\n///   )\n/// ]\n/// ```\n///\n/// ```gleam\n/// > let assert Ok(re) = regex.from_string(\"var\\\\s*(\\\\w+)\\\\s*(int|string)?\\\\s*=\\\\s*(.*)\")\n/// > scan(with: re, content: \"var age = 32\")\n/// [\n///   Match(\n///     content: \"var age = 32\",\n///     submatches: [Some(\"age\"), None, Some(\"32\")]\n///   )\n/// ]\n/// ```\n///\n/// ```gleam\n/// > let assert Ok(re) = regex.from_string(\"let (\\\\w+) = (\\\\w+)\")\n/// > scan(with: re, content: \"let age = 32\")\n/// [\n///   Match(\n///     content: \"let age = 32\",\n///     submatches: [Some(\"age\"), Some(\"32\")]\n///   )\n/// ]\n///\n/// > scan(with: re, content: \"const age = 32\")\n/// []\n/// ```\n///\npub fn scan(with regex: Regex, content string: String) -> List(Match) {\n  do_scan(regex, string)\n}\n\nif erlang {\n  external fn do_scan(Regex, String) -> List(Match) =\n    \"gleam_stdlib\" \"regex_scan\"\n}\n\nif javascript {\n  external fn do_scan(Regex, String) -> List(Match) =\n    \"../gleam_stdlib.mjs\" \"regex_scan\"\n}\n" (Durability(0))    
2023-08-04T09:30:46.270487Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.270495Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R131    
2023-08-04T09:30:46.270504Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(35)) = "import gleam/list\n\n/// `StringBuilder` is a type used for efficiently building strings.\n///\n/// When we append one string to another the strings must be copied to a\n/// new location in memory so that they can sit together. This behaviour\n/// enables efficient reading of the string but copying can be expensive,\n/// especially if we want to join many strings together.\n///\n/// `StringBuilder` is different in that it can be joined together in constant time\n/// using minimal memory, and then can be efficiently converted to a string\n/// using the `to_string` function.\n///\n/// On Erlang this type is compatible with Erlang's iodata. On JavaScript this\n/// type is compatible with normal strings.\n///\npub external type StringBuilder\n\n/// Create an empty `StringBuilder`. Useful as the start of a pipe chaining many\n/// builders together.\n///\npub fn new() -> StringBuilder {\n  do_from_strings([])\n}\n\n/// Prepends a `String` onto the start of some `StringBuilder`.\n///\n/// Runs in constant time.\n///\npub fn prepend(\n  to builder: StringBuilder,\n  prefix prefix: String,\n) -> StringBuilder {\n  append_builder(from_string(prefix), builder)\n}\n\n/// Appends a `String` onto the end of some `StringBuilder`.\n///\n/// Runs in constant time.\n///\npub fn append(to builder: StringBuilder, suffix second: String) -> StringBuilder {\n  append_builder(builder, from_string(second))\n}\n\n/// Prepends some `StringBuilder` onto the start of another.\n///\n/// Runs in constant time.\n///\npub fn prepend_builder(\n  to builder: StringBuilder,\n  prefix prefix: StringBuilder,\n) -> StringBuilder {\n  do_append(prefix, builder)\n}\n\n/// Appends some `StringBuilder` onto the end of another.\n///\n/// Runs in constant time.\n///\npub fn append_builder(\n  to builder: StringBuilder,\n  suffix suffix: StringBuilder,\n) -> StringBuilder {\n  do_append(builder, suffix)\n}\n\nif erlang {\n  external fn do_append(StringBuilder, StringBuilder) -> StringBuilder =\n    \"gleam_stdlib\" \"iodata_append\"\n}\n\nif javascript {\n  external fn do_append(StringBuilder, StringBuilder) -> StringBuilder =\n    \"../gleam_stdlib.mjs\" \"add\"\n}\n\n/// Converts a list of strings into a builder.\n///\n/// Runs in constant time.\n///\npub fn from_strings(strings: List(String)) -> StringBuilder {\n  do_from_strings(strings)\n}\n\nif erlang {\n  external fn do_from_strings(List(String)) -> StringBuilder =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn do_from_strings(List(String)) -> StringBuilder =\n    \"../gleam_stdlib.mjs\" \"join\"\n}\n\n/// Joins a list of builders into a single builder.\n///\n/// Runs in constant time.\n///\npub fn concat(builders: List(StringBuilder)) -> StringBuilder {\n  do_concat(builders)\n}\n\nif erlang {\n  external fn do_concat(List(StringBuilder)) -> StringBuilder =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn do_concat(List(StringBuilder)) -> StringBuilder =\n    \"../gleam_stdlib.mjs\" \"join\"\n}\n\n/// Converts a string into a builder.\n///\n/// Runs in constant time.\n///\npub fn from_string(string: String) -> StringBuilder {\n  do_from_string(string)\n}\n\nif erlang {\n  external fn do_from_string(String) -> StringBuilder =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn do_from_string(String) -> StringBuilder =\n    \"../gleam_stdlib.mjs\" \"identity\"\n}\n\n/// Turns an `StringBuilder` into a `String`\n///\n/// This function is implemented natively by the virtual machine and is highly\n/// optimised.\n///\npub fn to_string(builder: StringBuilder) -> String {\n  do_to_string(builder)\n}\n\nif erlang {\n  external fn do_to_string(StringBuilder) -> String =\n    \"unicode\" \"characters_to_binary\"\n}\n\nif javascript {\n  external fn do_to_string(StringBuilder) -> String =\n    \"../gleam_stdlib.mjs\" \"identity\"\n}\n\n/// Returns the size of the `StringBuilder` in bytes.\n///\npub fn byte_size(builder: StringBuilder) -> Int {\n  do_byte_size(builder)\n}\n\nif erlang {\n  external fn do_byte_size(StringBuilder) -> Int =\n    \"erlang\" \"iolist_size\"\n}\n\nif javascript {\n  external fn do_byte_size(StringBuilder) -> Int =\n    \"../gleam_stdlib.mjs\" \"length\"\n}\n\n/// Joins the given builders into a new builder separated with the given string\n///\npub fn join(builders: List(StringBuilder), with sep: String) -> StringBuilder {\n  builders\n  |> list.intersperse(from_string(sep))\n  |> concat\n}\n\n/// Converts a builder to a new builder where the contents have been\n/// lowercased.\n///\npub fn lowercase(builder: StringBuilder) -> StringBuilder {\n  do_lowercase(builder)\n}\n\nif erlang {\n  external fn do_lowercase(StringBuilder) -> StringBuilder =\n    \"string\" \"lowercase\"\n}\n\nif javascript {\n  external fn do_lowercase(StringBuilder) -> StringBuilder =\n    \"../gleam_stdlib.mjs\" \"lowercase\"\n}\n\n/// Converts a builder to a new builder where the contents have been\n/// uppercased.\n///\npub fn uppercase(builder: StringBuilder) -> StringBuilder {\n  do_uppercase(builder)\n}\n\nif erlang {\n  external fn do_uppercase(StringBuilder) -> StringBuilder =\n    \"string\" \"uppercase\"\n}\n\nif javascript {\n  external fn do_uppercase(StringBuilder) -> StringBuilder =\n    \"../gleam_stdlib.mjs\" \"uppercase\"\n}\n\n/// Converts a builder to a new builder with the contents reversed.\n///\npub fn reverse(builder: StringBuilder) -> StringBuilder {\n  do_reverse(builder)\n}\n\nif erlang {\n  external fn do_reverse(StringBuilder) -> StringBuilder =\n    \"string\" \"reverse\"\n}\n\nif javascript {\n  fn do_reverse(builder: StringBuilder) -> StringBuilder {\n    builder\n    |> to_string\n    |> do_to_graphemes\n    |> list.reverse\n    |> from_strings\n  }\n\n  external fn do_to_graphemes(string: String) -> List(String) =\n    \"../gleam_stdlib.mjs\" \"graphemes\"\n}\n\n/// Splits a builder on a given pattern into a list of builders.\n///\npub fn split(iodata: StringBuilder, on pattern: String) -> List(StringBuilder) {\n  do_split(iodata, pattern)\n}\n\nif erlang {\n  type Direction {\n    All\n  }\n\n  external fn erl_split(StringBuilder, String, Direction) -> List(StringBuilder) =\n    \"string\" \"split\"\n\n  fn do_split(iodata: StringBuilder, pattern: String) -> List(StringBuilder) {\n    erl_split(iodata, pattern, All)\n  }\n}\n\nif javascript {\n  external fn do_split(\n    builder: StringBuilder,\n    pattern: String,\n  ) -> List(StringBuilder) =\n    \"../gleam_stdlib.mjs\" \"split\"\n}\n\n/// Replaces all instances of a pattern with a given string substitute.\n///\npub fn replace(\n  in builder: StringBuilder,\n  each pattern: String,\n  with substitute: String,\n) -> StringBuilder {\n  do_replace(builder, pattern, substitute)\n}\n\nif erlang {\n  fn do_replace(\n    iodata: StringBuilder,\n    pattern: String,\n    substitute: String,\n  ) -> StringBuilder {\n    erl_replace(iodata, pattern, substitute, All)\n  }\n\n  external fn erl_replace(\n    StringBuilder,\n    String,\n    String,\n    Direction,\n  ) -> StringBuilder =\n    \"string\" \"replace\"\n}\n\nif javascript {\n  external fn do_replace(StringBuilder, String, String) -> StringBuilder =\n    \"../gleam_stdlib.mjs\" \"string_replace\"\n}\n\n/// Compares two builders to determine if they have the same textual content.\n///\n/// Comparing two iodata using the `==` operator may return `False` even if they\n/// have the same content as they may have been build in different ways, so\n/// using this function is often preferred.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_strings([\"a\", \"b\"]) == from_string(\"ab\")\n/// False\n/// ```\n///\n/// ```gleam\n/// > is_equal(from_strings([\"a\", \"b\"]), from_string(\"ab\"))\n/// True\n/// ```\n///\npub fn is_equal(a: StringBuilder, b: StringBuilder) -> Bool {\n  do_is_equal(a, b)\n}\n\nif erlang {\n  external fn do_is_equal(StringBuilder, StringBuilder) -> Bool =\n    \"string\" \"equal\"\n}\n\nif javascript {\n  external fn do_is_equal(StringBuilder, StringBuilder) -> Bool =\n    \"../gleam_stdlib.mjs\" \"equal\"\n}\n\n/// Inspects a builder to determine if it is equivalent to an empty string.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_string(\"ok\") |> is_empty\n/// False\n/// ```\n///\n/// ```gleam\n/// > from_string(\"\") |> is_empty\n/// True\n/// ```\n///\n/// ```gleam\n/// > from_strings([]) |> is_empty\n/// True\n/// ```\n///\npub fn is_empty(builder: StringBuilder) -> Bool {\n  do_is_empty(builder)\n}\n\nif erlang {\n  external fn do_is_empty(StringBuilder) -> Bool =\n    \"string\" \"is_empty\"\n}\n\nif javascript {\n  fn do_is_empty(builder: StringBuilder) -> Bool {\n    from_string(\"\") == builder\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.270613Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.270621Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R132    
2023-08-04T09:30:46.270629Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(36)) = "/// Takes two functions and chains them together to form one function that\n/// takes the input from the first and returns the output of the second.\n///\npub fn compose(fun1: fn(a) -> b, fun2: fn(b) -> c) -> fn(a) -> c {\n  fn(a) { fun2(fun1(a)) }\n}\n\n/// Takes a function with `2` arguments (an arity of `2`), and returns the\n/// curried equivalent.\n///\n/// `fn(a, b) -> c` becomes `fn(a) -> fn(b) -> c`.\n///\n/// ## Examples\n///\n/// *Currying* creates a new function that is identical to the given function\n/// except that arguments must now be supplied one by one over several function\n/// calls. It thus is the process of taking a function with `n` arguments\n/// and producing a sequence of `n` single-argument functions. Given:\n///\n/// ```gleam\n/// > fn my_fun(i: Int, s: String) -> String { ... }\n/// ```\n///\n/// …calling `curry2(my_fun)` would return the curried equivalent, like so:\n///\n/// ```gleam\n/// > curry2(my_fun)\n/// fn(Int) -> fn(String) -> String\n/// ```\n///\n/// Currying is useful when you want to partially apply a function with\n/// some arguments and then pass it somewhere else, for example:\n///\n/// ```gleam\n/// > import gleam/list\n/// > let multiply = curry2(fn(x, y) { x * y })\n/// > let doubles = list.map([1, 2, 3], multiply(2))\n/// [2, 4, 6]\n/// ```\n///\npub fn curry2(fun: fn(a, b) -> value) {\n  fn(a) { fn(b) { fun(a, b) } }\n}\n\n/// Takes a function with `3` arguments (an arity of `3`), and returns the\n/// curried equivalent.\n///\n/// `fn(a, b, c) -> d` becomes `fn(a) -> fn(b) -> fn(c) -> d`.\n///\n/// See [`curry2`](#curry2) for a detailed explanation.\n///\npub fn curry3(fun: fn(a, b, c) -> value) {\n  fn(a) { fn(b) { fn(c) { fun(a, b, c) } } }\n}\n\n/// Takes a function with `4` arguments (an arity of `4`), and returns the\n/// curried equivalent.\n///\n/// `fn(a, b, c, d) -> e` becomes `fn(a) -> fn(b) -> fn(c) -> fn(d) -> e`.\n///\n/// See [`curry2`](#curry2) for a detailed explanation.\n///\npub fn curry4(fun: fn(a, b, c, d) -> value) {\n  fn(a) { fn(b) { fn(c) { fn(d) { fun(a, b, c, d) } } } }\n}\n\n/// Takes a function with `5` arguments (an arity of `5`), and returns the\n/// curried equivalent.\n///\n/// `fn(a, b, c, d, e) -> f` becomes\n/// `fn(a) -> fn(b) -> fn(c) -> fn(d) -> fn(e) -> f`.\n///\n/// See [`curry2`](#curry2) for a detailed explanation.\n///\npub fn curry5(fun: fn(a, b, c, d, e) -> value) {\n  fn(a) { fn(b) { fn(c) { fn(d) { fn(e) { fun(a, b, c, d, e) } } } } }\n}\n\n/// Takes a function with `6` arguments (an arity of `6`), and returns the\n/// curried equivalent.\n///\n/// `fn(a, b, c, d, e, f) -> g` becomes\n/// `fn(a) -> fn(b) -> fn(c) -> fn(d) -> fn(e) -> fn(f) -> g`.\n///\n/// See [`curry2`](#curry2) for a detailed explanation.\n///\npub fn curry6(fun: fn(a, b, c, d, e, f) -> value) {\n  fn(a) {\n    fn(b) { fn(c) { fn(d) { fn(e) { fn(f) { fun(a, b, c, d, e, f) } } } } }\n  }\n}\n\n/// Takes a function that takes two arguments and returns a new function that\n/// takes the same two arguments, but in reverse order.\n///\npub fn flip(fun: fn(a, b) -> c) -> fn(b, a) -> c {\n  fn(b, a) { fun(a, b) }\n}\n\n/// Takes a single argument and always returns its input value.\n///\npub fn identity(x: a) -> a {\n  x\n}\n\n/// Takes a single argument and returns a new function that\n/// ignores its argument and always returns the input value.\n///\npub fn constant(value: a) -> fn(b) -> a {\n  fn(_) { value }\n}\n\n/// Takes an argument and a single function,\n/// calls that function with that argument\n/// and returns that argument instead of the function return value.\n/// Useful for running synchronous side effects in a pipeline.\n///\npub fn tap(arg: a, effect: fn(a) -> b) -> a {\n  effect(arg)\n  arg\n}\n\n/// Takes a function with arity one and an argument,\n/// calls that function with the argument and returns the function return value.\n///\n/// Useful for concisely calling functions returned as a part of a pipeline.\n///\n/// ## Example\n///\n/// ```gleam\n/// > let doubler = fn() {\n/// >  fn(x: Int) { x * 2 }\n/// > }\n/// >\n/// > doubler()\n/// > |> apply1(2)\n/// 4\n/// ```\n///\npub fn apply1(fun: fn(a) -> value, arg1: a) -> value {\n  fun(arg1)\n}\n\n/// Takes a function with arity two and two arguments,\n/// calls that function with the arguments\n/// and returns the function return value.\n///\n/// See [`apply1`](#apply1) for more details.\n///\npub fn apply2(fun: fn(a, b) -> value, arg1: a, arg2: b) -> value {\n  fun(arg1, arg2)\n}\n\n/// Takes a function with arity three and three arguments,\n/// calls that function with the arguments\n/// and returns the function return value.\n///\n/// See [`apply1`](#apply1) for more details.\n///\npub fn apply3(fun: fn(a, b, c) -> value, arg1: a, arg2: b, arg3: c) -> value {\n  fun(arg1, arg2, arg3)\n}\n" (Durability(0))    
2023-08-04T09:30:46.270696Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.270704Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R133    
2023-08-04T09:30:46.270713Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(37)) = "//// A type with two possible values, `True` and `False`. Used to indicate whether\n//// things are... true or false!\n////\n//// Often is it clearer and offers more type safety to define a custom type\n//// than to use `Bool`. For example, rather than having a `is_teacher: Bool`\n//// field consider having a `role: SchoolRole` field where `SchoolRole` is a custom\n//// type that can be either `Student` or `Teacher`.\n\nimport gleam/order.{Order}\n\n/// Returns the and of two bools, but it evaluates both arguments.\n///\n/// It's the function equivalent of the `&&` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > and(True, True)\n/// True\n/// ```\n///\n/// ```gleam\n/// > and(False, True)\n/// False\n/// ```\n///\n/// ```gleam\n/// > False |> and(True)\n/// False\n/// ```\n///\npub fn and(a: Bool, b: Bool) -> Bool {\n  a && b\n}\n\n/// Returns the or of two bools, but it evaluates both arguments.\n///\n/// It's the function equivalent of the `||` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > or(True, True)\n/// True\n/// ```\n///\n/// ```gleam\n/// > or(False, True)\n/// True\n/// ```\n///\n/// ```gleam\n/// > False |> or(True)\n/// True\n/// ```\n///\npub fn or(a: Bool, b: Bool) -> Bool {\n  a || b\n}\n\n/// Returns the opposite bool value.\n///\n/// This is the same as the `!` or `not` operators in some other languages.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > negate(True)\n/// False\n/// ```\n///\n/// ```gleam\n/// > negate(False)\n/// True\n/// ```\n///\npub fn negate(bool: Bool) -> Bool {\n  case bool {\n    True -> False\n    False -> True\n  }\n}\n\n/// Returns the nor of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > nor(False, False)\n/// True\n/// ```\n///\n/// ```gleam\n/// > nor(False, True)\n/// False\n/// ```\n///\n/// ```gleam\n/// > nor(True, False)\n/// False\n/// ```\n///\n/// ```gleam\n/// > nor(True, True)\n/// False\n/// ```\n///\npub fn nor(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> True\n    False, True -> False\n    True, False -> False\n    True, True -> False\n  }\n}\n\n/// Returns the nand of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > nand(False, False)\n/// True\n/// ```\n///\n/// ```gleam\n/// > nand(False, True)\n/// True\n/// ```\n///\n/// ```gleam\n/// > nand(True, False)\n/// True\n/// ```\n///\n/// ```gleam\n/// > nand(True, True)\n/// False\n/// ```\n///\npub fn nand(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> True\n    False, True -> True\n    True, False -> True\n    True, True -> False\n  }\n}\n\n/// Returns the exclusive or of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > exclusive_or(False, False)\n/// False\n/// ```\n///\n/// ```gleam\n/// > exclusive_or(False, True)\n/// True\n/// ```\n///\n/// ```gleam\n/// > exclusive_or(True, False)\n/// True\n/// ```\n///\n/// ```gleam\n/// > exclusive_or(True, True)\n/// False\n/// ```\n///\npub fn exclusive_or(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> False\n    False, True -> True\n    True, False -> True\n    True, True -> False\n  }\n}\n\n/// Returns the exclusive nor of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > exclusive_nor(False, False)\n/// True\n/// ```\n///\n/// ```gleam\n/// > exclusive_nor(False, True)\n/// False\n/// ```\n///\n/// ```gleam\n/// > exclusive_nor(True, False)\n/// False\n/// ```\n///\n/// ```gleam\n/// > exclusive_nor(True, True)\n/// True\n/// ```\n///\npub fn exclusive_nor(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> True\n    False, True -> False\n    True, False -> False\n    True, True -> True\n  }\n}\n\n/// Compares two bools and returns the first value's `Order` to the second.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/order\n/// > compare(True, False)\n/// order.Gt\n/// ```\n///\npub fn compare(a: Bool, with b: Bool) -> Order {\n  case a, b {\n    True, True -> order.Eq\n    True, False -> order.Gt\n    False, False -> order.Eq\n    False, True -> order.Lt\n  }\n}\n\n/// Returns `True` if either argument's value is `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > max(True, False)\n/// True\n/// ```\n///\n/// ```gleam\n/// > max(False, True)\n/// True\n/// ```\n///\n/// ```gleam\n/// > max(False, False)\n/// False\n/// ```\n///\npub fn max(a: Bool, b: Bool) -> Bool {\n  case a {\n    True -> True\n    False -> b\n  }\n}\n\n/// Returns `False` if either bool value is `False`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > min(True, False)\n/// False\n/// ```\n///\n/// ```gleam\n/// > min(False, True)\n/// False\n///\n/// > min(False, False)\n/// False\n/// ```\n///\npub fn min(a: Bool, b: Bool) -> Bool {\n  case a {\n    False -> False\n    True -> b\n  }\n}\n\n/// Returns a numeric representation of the given bool.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_int(True)\n/// 1\n///\n/// > to_int(False)\n/// 0\n/// ```\n///\npub fn to_int(bool: Bool) -> Int {\n  case bool {\n    False -> 0\n    True -> 1\n  }\n}\n\n/// Returns a string representation of the given bool.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_string(True)\n/// \"True\"\n/// ```\n///\n/// ```gleam\n/// > to_string(False)\n/// \"False\"\n/// ```\n///\npub fn to_string(bool: Bool) -> String {\n  case bool {\n    False -> \"False\"\n    True -> \"True\"\n  }\n}\n\n/// Run a callback function if the given bool is `False`, otherwise return a\n/// default value.\n///\n/// With a `use` expression this function can simulate the early-return pattern\n/// found in some other programming languages.\n///\n/// In a procedural language:\n///\n/// ```js\n/// if (predicate) return value;\n/// // ...\n/// ```\n///\n/// In Gleam with a `use` expression:\n///\n/// ```gleam\n/// use <- guard(when: predicate, return: value)\n/// // ...\n/// ```\n///\n/// Like everything in Gleam `use` is an expression, so it short circuits the\n/// current block, not the entire function. As a result you can assign the value\n/// to a variable:\n///\n/// ```gleam\n/// let x = {\n///   use <- guard(when: predicate, return: value)\n///   // ...\n/// }\n/// ```\n///\n/// Note that unlike in procedural languages the `return` value is evaluated\n/// even when the predicate is `False`, so it is advisable not to perform\n/// expensive computation there.\n///\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let name = \"\"\n/// > use <- guard(when: name == \"\", return: \"Welcome!\")\n/// > \"Hello, \" <> name\n/// \"Welcome!\"\n/// ```\n///\n/// ```gleam\n/// > let name = \"Kamaka\"\n/// > use <- guard(when: name == \"\", return: \"Welcome!\")\n/// > \"Hello, \" <> name\n/// \"Hello, Kamaka\"\n/// ```\n///\npub fn guard(\n  when requirement: Bool,\n  return consequence: t,\n  otherwise alternative: fn() -> t,\n) -> t {\n  case requirement {\n    True -> consequence\n    False -> alternative()\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.270809Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.270817Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R134    
2023-08-04T09:30:46.270825Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(38)) = "import gleam/option.{Option}\n\n/// A dictionary of keys and values.\n///\n/// Any type can be used for the keys and values of a map, but all the keys\n/// must be of the same type and all the values must be of the same type.\n///\n/// Each key can only be present in a map once.\n///\n/// Maps are not ordered in any way, and any unintentional ordering is not to\n/// be relied upon in your code as it may change in future versions of Erlang\n/// or Gleam.\n///\n/// See [the Erlang map module](https://erlang.org/doc/man/maps.html) for more\n/// information.\n///\npub external type Map(key, value)\n\n/// Determines the number of key-value pairs in the map.\n/// This function runs in constant time and does not need to iterate the map.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new() |> size()\n/// 0\n/// ```\n///\n/// ```gleam\n/// > new() |> insert(\"key\", \"value\") |> size()\n/// 1\n/// ```\n///\npub fn size(map: Map(k, v)) -> Int {\n  do_size(map)\n}\n\nif erlang {\n  external fn do_size(Map(k, v)) -> Int =\n    \"maps\" \"size\"\n}\n\nif javascript {\n  external fn do_size(Map(k, v)) -> Int =\n    \"../gleam_stdlib.mjs\" \"map_size\"\n}\n\n/// Converts the map to a list of 2-element tuples `#(key, value)`, one for\n/// each key-value pair in the map.\n///\n/// The tuples in the list have no specific order.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new() |> to_list()\n/// []\n/// ```\n///\n/// ```gleam\n/// > new() |> insert(\"key\", 0) |> to_list()\n/// [#(\"key\", 0)]\n/// ```\n///\npub fn to_list(map: Map(key, value)) -> List(#(key, value)) {\n  do_to_list(map)\n}\n\nif erlang {\n  external fn do_to_list(Map(key, value)) -> List(#(key, value)) =\n    \"maps\" \"to_list\"\n}\n\nif javascript {\n  external fn do_to_list(Map(key, value)) -> List(#(key, value)) =\n    \"../gleam_stdlib.mjs\" \"map_to_list\"\n}\n\n/// Converts a list of 2-element tuples `#(key, value)` to a map.\n///\n/// If two tuples have the same key the last one in the list will be the one\n/// that is present in the map.\n///\npub fn from_list(list: List(#(k, v))) -> Map(k, v) {\n  do_from_list(list)\n}\n\nif erlang {\n  external fn do_from_list(List(#(key, value))) -> Map(key, value) =\n    \"maps\" \"from_list\"\n}\n\nif javascript {\n  fn fold_list_of_pair(\n    over list: List(#(k, v)),\n    from initial: Map(k, v),\n  ) -> Map(k, v) {\n    case list {\n      [] -> initial\n      [x, ..rest] -> fold_list_of_pair(rest, insert(initial, x.0, x.1))\n    }\n  }\n\n  fn do_from_list(list: List(#(k, v))) -> Map(k, v) {\n    fold_list_of_pair(list, new())\n  }\n}\n\n/// Determines whether or not a value present in the map for a given key.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new() |> insert(\"a\", 0) |> has_key(\"a\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > new() |> insert(\"a\", 0) |> has_key(\"b\")\n/// False\n/// ```\n///\npub fn has_key(map: Map(k, v), key: k) -> Bool {\n  do_has_key(key, map)\n}\n\nif erlang {\n  external fn do_has_key(key, Map(key, v)) -> Bool =\n    \"maps\" \"is_key\"\n}\n\nif javascript {\n  fn do_has_key(key: k, map: Map(k, v)) -> Bool {\n    get(map, key) != Error(Nil)\n  }\n}\n\n/// Creates a fresh map that contains no values.\n///\npub fn new() -> Map(key, value) {\n  do_new()\n}\n\nif erlang {\n  external fn do_new() -> Map(key, value) =\n    \"maps\" \"new\"\n}\n\nif javascript {\n  external fn do_new() -> Map(key, value) =\n    \"../gleam_stdlib.mjs\" \"new_map\"\n}\n\n/// Fetches a value from a map for a given key.\n///\n/// The map may not have a value for the key, so the value is wrapped in a\n/// `Result`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new() |> insert(\"a\", 0) |> get(\"a\")\n/// Ok(0)\n/// ```\n///\n/// ```gleam\n/// > new() |> insert(\"a\", 0) |> get(\"b\")\n/// Error(Nil)\n/// ```\n///\npub fn get(from: Map(key, value), get: key) -> Result(value, Nil) {\n  do_get(from, get)\n}\n\nif erlang {\n  external fn do_get(Map(key, value), key) -> Result(value, Nil) =\n    \"gleam_stdlib\" \"map_get\"\n}\n\nif javascript {\n  external fn do_get(Map(key, value), key) -> Result(value, Nil) =\n    \"../gleam_stdlib.mjs\" \"map_get\"\n}\n\n/// Inserts a value into the map with the given key.\n///\n/// If the map already has a value for the given key then the value is\n/// replaced with the new value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new() |> insert(\"a\", 0) |> to_list\n/// [#(\"a\", 0)]\n/// ```\n///\n/// ```gleam\n/// > new() |> insert(\"a\", 0) |> insert(\"a\", 5) |> to_list\n/// [#(\"a\", 5)]\n/// ```\n///\npub fn insert(into map: Map(k, v), for key: k, insert value: v) -> Map(k, v) {\n  do_insert(key, value, map)\n}\n\nif erlang {\n  external fn do_insert(key, value, Map(key, value)) -> Map(key, value) =\n    \"maps\" \"put\"\n}\n\nif javascript {\n  external fn do_insert(key, value, Map(key, value)) -> Map(key, value) =\n    \"../gleam_stdlib.mjs\" \"map_insert\"\n}\n\n/// Updates all values in a given map by calling a given function on each key\n/// and value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [#(3, 3), #(2, 4)]\n/// > |> from_list\n/// > |> map_values(fn(key, value) { key * value })\n/// [#(3, 9), #(2, 8)]\n/// ```\n///\npub fn map_values(in map: Map(k, v), with fun: fn(k, v) -> w) -> Map(k, w) {\n  do_map_values(fun, map)\n}\n\nif erlang {\n  external fn do_map_values(fn(key, value) -> b, Map(key, value)) -> Map(key, b) =\n    \"maps\" \"map\"\n}\n\nif javascript {\n  fn do_map_values(f: fn(key, value) -> b, map: Map(key, value)) -> Map(key, b) {\n    let f = fn(map, k, v) { insert(map, k, f(k, v)) }\n    map\n    |> fold(from: new(), with: f)\n  }\n}\n\n/// Gets a list of all keys in a given map.\n///\n/// Maps are not ordered so the keys are not returned in any specific order. Do\n/// not write code that relies on the order keys are returned by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > keys([#(\"a\", 0), #(\"b\", 1)])\n/// [\"a\", \"b\"]\n/// ```\n///\npub fn keys(map: Map(keys, v)) -> List(keys) {\n  do_keys(map)\n}\n\nif erlang {\n  external fn do_keys(Map(keys, v)) -> List(keys) =\n    \"maps\" \"keys\"\n}\n\nif javascript {\n  fn reverse_and_concat(remaining, accumulator) {\n    case remaining {\n      [] -> accumulator\n      [item, ..rest] -> reverse_and_concat(rest, [item, ..accumulator])\n    }\n  }\n\n  fn do_keys_acc(list: List(#(k, v)), acc: List(k)) -> List(k) {\n    case list {\n      [] -> reverse_and_concat(acc, [])\n      [x, ..xs] -> do_keys_acc(xs, [x.0, ..acc])\n    }\n  }\n\n  fn do_keys(map: Map(k, v)) -> List(k) {\n    let list_of_pairs =\n      map\n      |> to_list\n    do_keys_acc(list_of_pairs, [])\n  }\n}\n\n/// Gets a list of all values in a given map.\n///\n/// Maps are not ordered so the values are not returned in any specific order. Do\n/// not write code that relies on the order values are returned by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > values(from_list([#(\"a\", 0), #(\"b\", 1)]))\n/// [0, 1]\n/// ```\n///\npub fn values(map: Map(k, values)) -> List(values) {\n  do_values(map)\n}\n\nif erlang {\n  external fn do_values(Map(k, values)) -> List(values) =\n    \"maps\" \"values\"\n}\n\nif javascript {\n  fn do_values_acc(list: List(#(k, v)), acc: List(v)) -> List(v) {\n    case list {\n      [] -> reverse_and_concat(acc, [])\n      [x, ..xs] -> do_values_acc(xs, [x.1, ..acc])\n    }\n  }\n\n  fn do_values(map: Map(k, v)) -> List(v) {\n    let list_of_pairs =\n      map\n      |> to_list\n    do_values_acc(list_of_pairs, [])\n  }\n}\n\n/// Creates a new map from a given map, minus any entries that a given function\n/// returns `False` for.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([#(\"a\", 0), #(\"b\", 1)])\n/// > |> filter(fn(key, value) { value != 0 })\n/// from_list([#(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// > from_list([#(\"a\", 0), #(\"b\", 1)])\n/// > |> filter(fn(key, value) { True })\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\npub fn filter(in map: Map(k, v), for property: fn(k, v) -> Bool) -> Map(k, v) {\n  do_filter(property, map)\n}\n\nif erlang {\n  external fn do_filter(\n    fn(key, value) -> Bool,\n    Map(key, value),\n  ) -> Map(key, value) =\n    \"maps\" \"filter\"\n}\n\nif javascript {\n  fn do_filter(\n    f: fn(key, value) -> Bool,\n    map: Map(key, value),\n  ) -> Map(key, value) {\n    let insert = fn(map, k, v) {\n      case f(k, v) {\n        True -> insert(map, k, v)\n        _ -> map\n      }\n    }\n    map\n    |> fold(from: new(), with: insert)\n  }\n}\n\n/// Creates a new map from a given map, only including any entries for which the\n/// keys are in a given list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([#(\"a\", 0), #(\"b\", 1)])\n/// > |> take([\"b\"])\n/// from_list([#(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// > from_list([#(\"a\", 0), #(\"b\", 1)])\n/// > |> take([\"a\", \"b\", \"c\"])\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\npub fn take(from map: Map(k, v), keeping desired_keys: List(k)) -> Map(k, v) {\n  do_take(desired_keys, map)\n}\n\nif erlang {\n  external fn do_take(List(k), Map(k, v)) -> Map(k, v) =\n    \"maps\" \"with\"\n}\n\nif javascript {\n  fn insert_taken(\n    map: Map(k, v),\n    desired_keys: List(k),\n    acc: Map(k, v),\n  ) -> Map(k, v) {\n    let insert = fn(taken, key) {\n      case get(map, key) {\n        Ok(value) -> insert(taken, key, value)\n        _ -> taken\n      }\n    }\n    case desired_keys {\n      [] -> acc\n      [x, ..xs] -> insert_taken(map, xs, insert(acc, x))\n    }\n  }\n\n  fn do_take(desired_keys: List(k), map: Map(k, v)) -> Map(k, v) {\n    insert_taken(map, desired_keys, new())\n  }\n}\n\n/// Creates a new map from a pair of given maps by combining their entries.\n///\n/// If there are entries with the same keys in both maps the entry from the\n/// second map takes precedence.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let a = from_list([#(\"a\", 0), #(\"b\", 1)])\n/// > let b = from_list([#(\"b\", 2), #(\"c\", 3)])\n/// > merge(a, b)\n/// from_list([#(\"a\", 0), #(\"b\", 2), #(\"c\", 3)])\n/// ```\n///\npub fn merge(into map: Map(k, v), from new_entries: Map(k, v)) -> Map(k, v) {\n  do_merge(map, new_entries)\n}\n\nif erlang {\n  external fn do_merge(Map(k, v), Map(k, v)) -> Map(k, v) =\n    \"maps\" \"merge\"\n}\n\nif javascript {\n  fn insert_pair(map: Map(k, v), pair: #(k, v)) -> Map(k, v) {\n    insert(map, pair.0, pair.1)\n  }\n\n  fn fold_inserts(new_entries: List(#(k, v)), map: Map(k, v)) -> Map(k, v) {\n    case new_entries {\n      [] -> map\n      [x, ..xs] -> fold_inserts(xs, insert_pair(map, x))\n    }\n  }\n\n  fn do_merge(map: Map(k, v), new_entries: Map(k, v)) -> Map(k, v) {\n    new_entries\n    |> to_list\n    |> fold_inserts(map)\n  }\n}\n\n/// Creates a new map from a given map with all the same entries except for the\n/// one with a given key, if it exists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > delete([#(\"a\", 0), #(\"b\", 1)], \"a\")\n/// from_list([#(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// > delete([#(\"a\", 0), #(\"b\", 1)], \"c\")\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\npub fn delete(from map: Map(k, v), delete key: k) -> Map(k, v) {\n  do_delete(key, map)\n}\n\nif erlang {\n  external fn do_delete(k, Map(k, v)) -> Map(k, v) =\n    \"maps\" \"remove\"\n}\n\nif javascript {\n  external fn do_delete(k, Map(k, v)) -> Map(k, v) =\n    \"../gleam_stdlib.mjs\" \"map_remove\"\n}\n\n/// Creates a new map from a given map with all the same entries except any with\n/// keys found in a given list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > drop([#(\"a\", 0), #(\"b\", 1)], [\"a\"])\n/// from_list([#(\"b\", 2)])\n/// ```\n///\n/// ```gleam\n/// > delete([#(\"a\", 0), #(\"b\", 1)], [\"c\"])\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// > drop([#(\"a\", 0), #(\"b\", 1)], [\"a\", \"b\", \"c\"])\n/// from_list([])\n/// ```\n///\npub fn drop(from map: Map(k, v), drop disallowed_keys: List(k)) -> Map(k, v) {\n  case disallowed_keys {\n    [] -> map\n    [x, ..xs] -> drop(delete(map, x), xs)\n  }\n}\n\n/// Creates a new map with one entry updated using a given function.\n///\n/// If there was not an entry in the map for the given key then the function\n/// gets `None` as its argument, otherwise it gets `Some(value)`.\n///\n/// ## Example\n///\n/// ```gleam\n/// > let increment = fn(x) {\n/// >   case x {\n/// >     Some(i) -> i + 1\n/// >     None -> 0\n/// >   }\n/// > }\n/// > let map = from_list([#(\"a\", 0)])\n/// >\n/// > update(map, \"a\", increment)\n/// from_list([#(\"a\", 1)])\n/// ```\n///\n/// ```gleam\n/// > update(map, \"b\", increment)\n/// from_list([#(\"a\", 0), #(\"b\", 0)])\n/// ```\n///\npub fn update(\n  in map: Map(k, v),\n  update key: k,\n  with fun: fn(Option(v)) -> v,\n) -> Map(k, v) {\n  map\n  |> get(key)\n  |> option.from_result\n  |> fun\n  |> insert(map, key, _)\n}\n\nfn do_fold(list: List(#(k, v)), initial: acc, fun: fn(acc, k, v) -> acc) -> acc {\n  case list {\n    [] -> initial\n    [#(k, v), ..rest] -> do_fold(rest, fun(initial, k, v), fun)\n  }\n}\n\n/// Combines all entries into a single value by calling a given function on each\n/// one.\n///\n/// Maps are not ordered so the values are not returned in any specific order. Do\n/// not write code that relies on the order entries are used by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// # Examples\n///\n/// ```gleam\n/// > let map = from_list([#(\"a\", 1), #(\"b\", 3), #(\"c\", 9)])\n/// > fold(map, 0, fn(accumulator, key, value) { accumulator + value })\n/// 13\n/// ```\n///\n/// ```gleam\n/// > import gleam/string.{append}\n/// > fold(map, \"\", fn(accumulator, key, value) { append(accumulator, key) })\n/// \"abc\"\n/// ```\n///\npub fn fold(\n  over map: Map(k, v),\n  from initial: acc,\n  with fun: fn(acc, k, v) -> acc,\n) -> acc {\n  map\n  |> to_list\n  |> do_fold(initial, fun)\n}\n" (Durability(0))    
2023-08-04T09:30:46.271003Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.271011Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R135    
2023-08-04T09:30:46.271020Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(39)) = "//// Utilities for working with URIs\n////\n//// This module provides functions for working with URIs (for example, parsing\n//// URIs or encoding query strings). The functions in this module are implemented\n//// according to [RFC 3986](https://tools.ietf.org/html/rfc3986).\n////\n//// Query encoding (Form encoding) is defined in the\n//// [W3C specification](https://www.w3.org/TR/html52/sec-forms.html#urlencoded-form-data).\n\nimport gleam/int\nimport gleam/list\nimport gleam/option.{None, Option, Some}\nimport gleam/string\nimport gleam/string_builder.{StringBuilder}\n\nif javascript {\n  import gleam/pair\n  import gleam/regex\n  import gleam/result\n}\n\n/// Type representing holding the parsed components of an URI.\n/// All components of a URI are optional, except the path.\n///\npub type Uri {\n  Uri(\n    scheme: Option(String),\n    userinfo: Option(String),\n    host: Option(String),\n    port: Option(Int),\n    path: String,\n    query: Option(String),\n    fragment: Option(String),\n  )\n}\n\n/// Parses a compliant URI string into the `Uri` Type.\n/// If the string is not a valid URI string then an error is returned.\n///\n/// The opposite operation is `uri.to_string`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > parse(\"https://example.com:1234/a/b?query=true#fragment\")\n/// Ok(\n///   Uri(\n///     scheme: Some(\"https\"),\n///     userinfo: None,\n///     host: Some(\"example.com\"),\n///     port: Some(1234),\n///     path: \"/a/b\",\n///     query: Some(\"query=true\"),\n///     fragment: Some(\"fragment\")\n///   )\n/// )\n/// ```\n///\npub fn parse(uri_string: String) -> Result(Uri, Nil) {\n  do_parse(uri_string)\n}\n\nif erlang {\n  external fn do_parse(String) -> Result(Uri, Nil) =\n    \"gleam_stdlib\" \"uri_parse\"\n}\n\nif javascript {\n  fn do_parse(uri_string: String) -> Result(Uri, Nil) {\n    // From https://tools.ietf.org/html/rfc3986#appendix-B\n    let pattern =\n      //    12                        3  4          5       6  7        8\n      \"^(([a-z][a-z0-9\\\\+\\\\-\\\\.]*):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#.*)?\"\n    let matches =\n      pattern\n      |> regex_submatches(uri_string)\n      |> pad_list(8)\n\n    let #(scheme, authority, path, query, fragment) = case matches {\n      [\n        _scheme_with_colon,\n        scheme,\n        authority_with_slashes,\n        _authority,\n        path,\n        query_with_question_mark,\n        _query,\n        fragment,\n      ] -> #(\n        scheme,\n        authority_with_slashes,\n        path,\n        query_with_question_mark,\n        fragment,\n      )\n      _ -> #(None, None, None, None, None)\n    }\n\n    let scheme = noneify_empty_string(scheme)\n    let path = option.unwrap(path, \"\")\n    let query = noneify_query(query)\n    let #(userinfo, host, port) = split_authority(authority)\n    let fragment =\n      fragment\n      |> option.to_result(Nil)\n      |> result.try(string.pop_grapheme)\n      |> result.map(pair.second)\n      |> option.from_result\n    let scheme =\n      scheme\n      |> noneify_empty_string\n      |> option.map(string.lowercase)\n    Ok(Uri(\n      scheme: scheme,\n      userinfo: userinfo,\n      host: host,\n      port: port,\n      path: path,\n      query: query,\n      fragment: fragment,\n    ))\n  }\n\n  fn regex_submatches(pattern: String, string: String) -> List(Option(String)) {\n    pattern\n    |> regex.compile(regex.Options(case_insensitive: True, multi_line: False))\n    |> result.nil_error\n    |> result.map(regex.scan(_, string))\n    |> result.try(list.first)\n    |> result.map(fn(m: regex.Match) { m.submatches })\n    |> result.unwrap([])\n  }\n\n  fn noneify_query(x: Option(String)) -> Option(String) {\n    case x {\n      None -> None\n      Some(x) ->\n        case string.pop_grapheme(x) {\n          Ok(#(\"?\", query)) -> Some(query)\n          _ -> None\n        }\n    }\n  }\n\n  fn noneify_empty_string(x: Option(String)) -> Option(String) {\n    case x {\n      Some(\"\") | None -> None\n      Some(_) -> x\n    }\n  }\n\n  // Split an authority into its userinfo, host and port parts.\n  fn split_authority(\n    authority: Option(String),\n  ) -> #(Option(String), Option(String), Option(Int)) {\n    case option.unwrap(authority, \"\") {\n      \"\" -> #(None, None, None)\n      \"//\" -> #(None, Some(\"\"), None)\n      authority -> {\n        let matches =\n          \"^(//)?((.*)@)?(\\\\[[a-zA-Z0-9:.]*\\\\]|[^:]*)(:(\\\\d*))?\"\n          |> regex_submatches(authority)\n          |> pad_list(6)\n        case matches {\n          [_, _, userinfo, host, _, port] -> {\n            let userinfo = noneify_empty_string(userinfo)\n            let host = noneify_empty_string(host)\n            let port =\n              port\n              |> option.unwrap(\"\")\n              |> int.parse\n              |> option.from_result\n            #(userinfo, host, port)\n          }\n          _ -> #(None, None, None)\n        }\n      }\n    }\n  }\n\n  fn pad_list(list: List(Option(a)), size: Int) -> List(Option(a)) {\n    list\n    |> list.append(list.repeat(None, extra_required(list, size)))\n  }\n\n  fn extra_required(list: List(a), remaining: Int) -> Int {\n    case list {\n      _ if remaining == 0 -> 0\n      [] -> remaining\n      [_, ..xs] -> extra_required(xs, remaining - 1)\n    }\n  }\n}\n\n/// Parses an urlencoded query string into a list of key value pairs.\n/// Returns an error for invalid encoding.\n///\n/// The opposite operation is `uri.query_to_string`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > parse_query(\"a=1&b=2\")\n/// Ok([#(\"a\", \"1\"), #(\"b\", \"2\")])\n/// ```\n///\npub fn parse_query(query: String) -> Result(List(#(String, String)), Nil) {\n  do_parse_query(query)\n}\n\nif erlang {\n  external fn do_parse_query(String) -> Result(List(#(String, String)), Nil) =\n    \"gleam_stdlib\" \"parse_query\"\n}\n\nif javascript {\n  external fn do_parse_query(String) -> Result(List(#(String, String)), Nil) =\n    \"../gleam_stdlib.mjs\" \"parse_query\"\n}\n\n/// Encodes a list of key value pairs as a URI query string.\n///\n/// The opposite operation is `uri.parse_query`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > query_to_string([#(\"a\", \"1\"), #(\"b\", \"2\")])\n/// \"a=1&b=2\"\n/// ```\n///\npub fn query_to_string(query: List(#(String, String))) -> String {\n  query\n  |> list.map(query_pair)\n  |> list.intersperse(string_builder.from_string(\"&\"))\n  |> string_builder.concat\n  |> string_builder.to_string\n}\n\nfn query_pair(pair: #(String, String)) -> StringBuilder {\n  string_builder.from_strings([\n    percent_encode(pair.0),\n    \"=\",\n    percent_encode(pair.1),\n  ])\n}\n\n/// Encodes a string into a percent encoded representation.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > percent_encode(\"100% great\")\n/// \"100%25%20great\"\n/// ```\n///\npub fn percent_encode(value: String) -> String {\n  do_percent_encode(value)\n}\n\nif erlang {\n  external fn do_percent_encode(String) -> String =\n    \"gleam_stdlib\" \"percent_encode\"\n}\n\nif javascript {\n  external fn do_percent_encode(String) -> String =\n    \"../gleam_stdlib.mjs\" \"percent_encode\"\n}\n\n/// Decodes a percent encoded string.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > percent_decode(\"100%25+great\")\n/// Ok(\"100% great\")\n/// ```\n///\npub fn percent_decode(value: String) -> Result(String, Nil) {\n  do_percent_decode(value)\n}\n\nif erlang {\n  external fn do_percent_decode(String) -> Result(String, Nil) =\n    \"gleam_stdlib\" \"percent_decode\"\n}\n\nif javascript {\n  external fn do_percent_decode(String) -> Result(String, Nil) =\n    \"../gleam_stdlib.mjs\" \"percent_decode\"\n}\n\nfn do_remove_dot_segments(\n  input: List(String),\n  accumulator: List(String),\n) -> List(String) {\n  case input {\n    [] -> list.reverse(accumulator)\n    [segment, ..rest] -> {\n      let accumulator = case segment, accumulator {\n        \"\", accumulator -> accumulator\n        \".\", accumulator -> accumulator\n        \"..\", [] -> []\n        \"..\", [_, ..accumulator] -> accumulator\n        segment, accumulator -> [segment, ..accumulator]\n      }\n      do_remove_dot_segments(rest, accumulator)\n    }\n  }\n}\n\nfn remove_dot_segments(input: List(String)) -> List(String) {\n  do_remove_dot_segments(input, [])\n}\n\n/// Splits the path section of a URI into it's constituent segments.\n///\n/// Removes empty segments and resolves dot-segments as specified in\n/// [section 5.2](https://www.ietf.org/rfc/rfc3986.html#section-5.2) of the RFC.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > path_segments(\"/users/1\")\n/// [\"users\" ,\"1\"]\n/// ```\n///\npub fn path_segments(path: String) -> List(String) {\n  remove_dot_segments(string.split(path, \"/\"))\n}\n\n/// Encodes a `Uri` value as a URI string.\n///\n/// The opposite operation is `uri.parse`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let uri = Uri(Some(\"http\"), None, Some(\"example.com\"), ...)\n/// > to_string(uri)\n/// \"http://example.com\"\n/// ```\n///\npub fn to_string(uri: Uri) -> String {\n  let parts = case uri.fragment {\n    Some(fragment) -> [\"#\", fragment]\n    _ -> []\n  }\n  let parts = case uri.query {\n    Some(query) -> [\"?\", query, ..parts]\n    _ -> parts\n  }\n  let parts = [uri.path, ..parts]\n  let parts = case uri.host, string.starts_with(uri.path, \"/\") {\n    Some(host), False if host != \"\" -> [\"/\", ..parts]\n    _, _ -> parts\n  }\n  let parts = case uri.host, uri.port {\n    Some(_), Some(port) -> [\":\", int.to_string(port), ..parts]\n    _, _ -> parts\n  }\n  let parts = case uri.scheme, uri.userinfo, uri.host {\n    Some(s), Some(u), Some(h) -> [s, \"://\", u, \"@\", h, ..parts]\n    Some(s), None, Some(h) -> [s, \"://\", h, ..parts]\n    Some(s), Some(_), None | Some(s), None, None -> [s, \":\", ..parts]\n    None, None, Some(h) -> [\"//\", h, ..parts]\n    None, Some(_), None | None, None, None -> parts\n  }\n  string.concat(parts)\n}\n\n/// Fetches the origin of a URI.\n///\n/// Returns the origin of a uri as defined in\n/// [RFC 6454](https://tools.ietf.org/html/rfc6454)\n///\n/// The supported URI schemes are `http` and `https`.\n/// URLs without a scheme will return `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let assert Ok(uri) = parse(\"http://example.com/path?foo#bar\")\n/// > origin(uri)\n/// Ok(\"http://example.com\")\n/// ```\n///\npub fn origin(uri: Uri) -> Result(String, Nil) {\n  let Uri(scheme: scheme, host: host, port: port, ..) = uri\n  case scheme {\n    Some(\"https\") if port == Some(443) -> {\n      let origin = Uri(scheme, None, host, None, \"\", None, None)\n      Ok(to_string(origin))\n    }\n    Some(\"http\") if port == Some(80) -> {\n      let origin = Uri(scheme, None, host, None, \"\", None, None)\n      Ok(to_string(origin))\n    }\n    Some(s) if s == \"http\" || s == \"https\" -> {\n      let origin = Uri(scheme, None, host, port, \"\", None, None)\n      Ok(to_string(origin))\n    }\n    _ -> Error(Nil)\n  }\n}\n\nfn drop_last(elements: List(a)) -> List(a) {\n  list.take(from: elements, up_to: list.length(elements) - 1)\n}\n\nfn join_segments(segments: List(String)) -> String {\n  string.join([\"\", ..segments], \"/\")\n}\n\n/// Resolves a URI with respect to the given base URI.\n///\n/// The base URI must be an absolute URI or this function will return an error.\n/// The algorithm for merging uris is described in\n/// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-5.2).\n///\npub fn merge(base: Uri, relative: Uri) -> Result(Uri, Nil) {\n  case base {\n    Uri(scheme: Some(_), host: Some(_), ..) ->\n      case relative {\n        Uri(host: Some(_), ..) -> {\n          let path =\n            string.split(relative.path, \"/\")\n            |> remove_dot_segments()\n            |> join_segments()\n          let resolved =\n            Uri(\n              option.or(relative.scheme, base.scheme),\n              None,\n              relative.host,\n              option.or(relative.port, base.port),\n              path,\n              relative.query,\n              relative.fragment,\n            )\n          Ok(resolved)\n        }\n        Uri(scheme: None, host: None, ..) -> {\n          let #(new_path, new_query) = case relative.path {\n            \"\" -> #(base.path, option.or(relative.query, base.query))\n            _ -> {\n              let path_segments = case string.starts_with(relative.path, \"/\") {\n                True -> string.split(relative.path, \"/\")\n                False ->\n                  string.split(base.path, \"/\")\n                  |> drop_last()\n                  |> list.append(string.split(relative.path, \"/\"))\n              }\n              let path =\n                path_segments\n                |> remove_dot_segments()\n                |> join_segments()\n              #(path, relative.query)\n            }\n          }\n          let resolved =\n            Uri(\n              base.scheme,\n              None,\n              base.host,\n              base.port,\n              new_path,\n              new_query,\n              relative.fragment,\n            )\n          Ok(resolved)\n        }\n      }\n    _ -> Error(Nil)\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.271185Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.271193Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R136    
2023-08-04T09:30:46.271201Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(40)) = "import gleam/order.{Order}\n\n/// Attempts to parse a string as a `Float`, returning `Error(Nil)` if it was\n/// not possible.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > parse(\"2.3\")\n/// Ok(2.3)\n/// ```\n///\n/// ```gleam\n/// > parse(\"ABC\")\n/// Error(Nil)\n/// ```\n///\npub fn parse(string: String) -> Result(Float, Nil) {\n  do_parse(string)\n}\n\nif erlang {\n  external fn do_parse(String) -> Result(Float, Nil) =\n    \"gleam_stdlib\" \"parse_float\"\n}\n\nif javascript {\n  external fn do_parse(String) -> Result(Float, Nil) =\n    \"../gleam_stdlib.mjs\" \"parse_float\"\n}\n\n/// Returns the string representation of the provided `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_string(2.3)\n/// \"2.3\"\n/// ```\n///\npub fn to_string(x: Float) -> String {\n  do_to_string(x)\n}\n\nif erlang {\n  external fn do_to_string(Float) -> String =\n    \"gleam_stdlib\" \"float_to_string\"\n}\n\nif javascript {\n  external fn do_to_string(Float) -> String =\n    \"../gleam_stdlib.mjs\" \"float_to_string\"\n}\n\n/// Restricts a `Float` between a lower and upper bound.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > clamp(1.2, min: 1.4, max: 1.6)\n/// 1.4\n/// ```\n///\npub fn clamp(x: Float, min min_bound: Float, max max_bound: Float) -> Float {\n  x\n  |> min(max_bound)\n  |> max(min_bound)\n}\n\n/// Compares two `Float`s, returning an `Order`:\n/// `Lt` for lower than, `Eq` for equals, or `Gt` for greater than.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > compare(2.0, 2.3)\n/// Lt\n/// ```\n///\n/// To handle\n/// [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems)\n/// you may use [`loosely_compare`](#loosely_compare) instead.\n///\npub fn compare(a: Float, with b: Float) -> Order {\n  case a == b {\n    True -> order.Eq\n    False ->\n      case a <. b {\n        True -> order.Lt\n        False -> order.Gt\n      }\n  }\n}\n\n/// Compares two `Float`s within a tolerance, returning an `Order`:\n/// `Lt` for lower than, `Eq` for equals, or `Gt` for greater than.\n///\n/// This function allows Float comparison while handling\n/// [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems).\n///\n/// Notice: For `Float`s the tolerance won't be exact:\n/// `5.3 - 5.0` is not exactly `0.3`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > loosely_compare(5.0, with: 5.3, tolerating: 0.5)\n/// Eq\n/// ```\n///\n/// If you want to check only for equality you may use\n/// [`loosely_equals`](#loosely_equals) instead.\n///\npub fn loosely_compare(\n  a: Float,\n  with b: Float,\n  tolerating tolerance: Float,\n) -> Order {\n  let difference = absolute_value(a -. b)\n  case difference <=. tolerance {\n    True -> order.Eq\n    False -> compare(a, b)\n  }\n}\n\n/// Checks for equality of two `Float`s within a tolerance,\n/// returning an `Bool`.\n///\n/// This function allows Float comparison while handling\n/// [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems).\n///\n/// Notice: For `Float`s the tolerance won't be exact:\n/// `5.3 - 5.0` is not exactly `0.3`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > loosely_equals(5.0, with: 5.3, tolerating: 0.5)\n/// True\n/// ```\n///\n/// ```gleam\n/// > loosely_equals(5.0, with: 5.1, tolerating: 0.1)\n/// False\n/// ```\n///\npub fn loosely_equals(\n  a: Float,\n  with b: Float,\n  tolerating tolerance: Float,\n) -> Bool {\n  let difference = absolute_value(a -. b)\n  difference <=. tolerance\n}\n\n/// Compares two `Float`s, returning the smaller of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > min(2.0, 2.3)\n/// 2.0\n/// ```\n///\npub fn min(a: Float, b: Float) -> Float {\n  case a <. b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Compares two `Float`s, returning the larger of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > max(2.0, 2.3)\n/// 2.3\n/// ```\n///\npub fn max(a: Float, b: Float) -> Float {\n  case a >. b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Rounds the value to the next highest whole number as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > ceiling(2.3)\n/// 3.0\n/// ```\n///\npub fn ceiling(x: Float) -> Float {\n  do_ceiling(x)\n}\n\nif erlang {\n  external fn do_ceiling(Float) -> Float =\n    \"math\" \"ceil\"\n}\n\nif javascript {\n  external fn do_ceiling(Float) -> Float =\n    \"../gleam_stdlib.mjs\" \"ceiling\"\n}\n\n/// Rounds the value to the next lowest whole number as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > floor(2.3)\n/// 2.0\n/// ```\n///\npub fn floor(x: Float) -> Float {\n  do_floor(x)\n}\n\nif erlang {\n  external fn do_floor(Float) -> Float =\n    \"math\" \"floor\"\n}\n\nif javascript {\n  external fn do_floor(Float) -> Float =\n    \"../gleam_stdlib.mjs\" \"floor\"\n}\n\n/// Rounds the value to the nearest whole number as an `Int`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > round(2.3)\n/// 2\n/// ```\n///\n/// ```gleam\n/// > round(2.5)\n/// 3\n/// ```\n///\npub fn round(x: Float) -> Int {\n  do_round(x)\n}\n\nif erlang {\n  external fn do_round(Float) -> Int =\n    \"erlang\" \"round\"\n}\n\nif javascript {\n  fn do_round(x: Float) -> Int {\n    case x >=. 0.0 {\n      True -> js_round(x)\n      _ -> 0 - js_round(negate(x))\n    }\n  }\n\n  external fn js_round(Float) -> Int =\n    \"../gleam_stdlib.mjs\" \"round\"\n}\n\n/// Returns the value as an `Int`, truncating all decimal digits.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > truncate(2.4343434847383438)\n/// 2\n/// ```\n///\npub fn truncate(x: Float) -> Int {\n  do_truncate(x)\n}\n\nif erlang {\n  external fn do_truncate(Float) -> Int =\n    \"erlang\" \"trunc\"\n}\n\nif javascript {\n  external fn do_truncate(Float) -> Int =\n    \"../gleam_stdlib.mjs\" \"truncate\"\n}\n\n/// Returns the absolute value of the input as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > absolute_value(-12.5)\n/// 12.5\n/// ```\n///\n/// ```gleam\n/// > absolute_value(10.2)\n/// 10.2\n/// ```\n///\npub fn absolute_value(x: Float) -> Float {\n  case x >=. 0.0 {\n    True -> x\n    _ -> 0.0 -. x\n  }\n}\n\n/// Returns the results of the base being raised to the power of the\n/// exponent, as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > power(2.0, -1.0)\n/// Ok(0.5)\n/// ```\n///\n/// ```gleam\n/// > power(2.0, 2.0)\n/// Ok(4.0)\n/// ```\n///\n/// ```gleam\n/// > power(8.0, 1.5)\n/// Ok(22.627416997969522)\n/// ```\n///\n/// ```gleam\n/// > 4.0 |> power(of: 2.0)\n/// Ok(16.0)\n/// ```\n///\n/// ```gleam\n/// > power(-1.0, 0.5)\n/// Error(Nil)\n/// ```\n///\npub fn power(base: Float, of exponent: Float) -> Result(Float, Nil) {\n  let fractional: Bool = ceiling(exponent) -. exponent >. 0.0\n  // In the following check:\n  // 1. If the base is negative and the exponent is fractional then\n  //    return an error as it will otherwise be an imaginary number\n  // 2. If the base is 0 and the exponent is negative then the expression\n  //    is equivalent to the exponent divided by 0 and an error should be\n  //    returned\n  case base <. 0.0 && fractional || base == 0.0 && exponent <. 0.0 {\n    True -> Error(Nil)\n    False -> Ok(do_power(base, exponent))\n  }\n}\n\nif erlang {\n  external fn do_power(Float, Float) -> Float =\n    \"math\" \"pow\"\n}\n\nif javascript {\n  external fn do_power(Float, Float) -> Float =\n    \"../gleam_stdlib.mjs\" \"power\"\n}\n\n/// Returns the square root of the input as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > square_root(4.0)\n/// Ok(2.0)\n/// ```\n///\n/// ```gleam\n/// > square_root(-16.0)\n/// Error(Nil)\n/// ```\n///\npub fn square_root(x: Float) -> Result(Float, Nil) {\n  power(x, 0.5)\n}\n\n/// Returns the negative of the value provided.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > negate(1.0)\n/// -1.0\n/// ```\n///\npub fn negate(x: Float) -> Float {\n  -1.0 *. x\n}\n\n/// Sums a list of `Float`s.\n///\n/// ## Example\n///\n/// ```gleam\n/// > sum([1.0, 2.2, 3.3])\n/// 6.5\n/// ```\n///\npub fn sum(numbers: List(Float)) -> Float {\n  numbers\n  |> do_sum(0.0)\n}\n\nfn do_sum(numbers: List(Float), initial: Float) -> Float {\n  case numbers {\n    [] -> initial\n    [x, ..rest] -> do_sum(rest, x +. initial)\n  }\n}\n\n/// Multiplies a list of `Float`s and returns the product.\n///\n/// ## Example\n///\n/// ```gleam\n/// > product([2.5, 3.2, 4.2])\n/// 33.6\n/// ```\n///\npub fn product(numbers: List(Float)) -> Float {\n  case numbers {\n    [] -> 1.0\n    _ -> do_product(numbers, 1.0)\n  }\n}\n\nfn do_product(numbers: List(Float), initial: Float) -> Float {\n  case numbers {\n    [] -> initial\n    [x, ..rest] -> do_product(rest, x *. initial)\n  }\n}\n\n/// Returns `0.0` if `boundary_a` and `boundary_b` are equal,\n/// otherwise returns a `Float x` where `lower_boundary =< x < upper_boundary`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > random(1.0, 5.0)\n/// 2.646355926896028\n/// ```\n///\npub fn random(boundary_a: Float, boundary_b: Float) -> Float {\n  // Based on:\n  //\n  // ```javascript\n  // return Math.random() * (max - min) + min; // The minimum is inclusive and the maximum is exclusive\n  // ```\n  //\n  // See: <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random#getting_a_random_number_between_two_values>\n  let #(min, max) = case boundary_a, boundary_b {\n    a, b if a <=. b -> #(a, b)\n    a, b if a >. b -> #(b, a)\n  }\n  case min, max {\n    min, _max if min == max -> min\n    min, max -> do_random_uniform() *. { max -. min } +. min\n  }\n}\n\nif erlang {\n  /// Returns a random float uniformly distributed in the value range\n  /// 0.0 =< X < 1.0 and updates the state in the process dictionary.\n  /// See: <https://www.erlang.org/doc/man/rand.html#uniform-0>\n  ///\n  external fn do_random_uniform() -> Float =\n    \"rand\" \"uniform\"\n}\n\nif javascript {\n  external fn do_random_uniform() -> Float =\n    \"../gleam_stdlib.mjs\" \"random_uniform\"\n}\n\n/// Returns division of the inputs as a `Result`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > divide(0.0, 1.0)\n/// Ok(1.0)\n/// ```\n///\n/// ```gleam\n/// > divide(1.0, 0.0)\n/// Error(Nil)\n/// ```\n///\npub fn divide(a: Float, by b: Float) -> Result(Float, Nil) {\n  case b {\n    0.0 -> Error(Nil)\n    b -> Ok(a /. b)\n  }\n}\n\n/// Adds two floats together.\n///\n/// It's the function equivalent of the `+.` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > add(1.0, 2.0)\n/// 3.0\n/// ```\n///\n/// ```gleam\n/// > import gleam/list\n/// > list.fold([1.0, 2.0, 3.0], 0.0, add)\n/// 6.0\n/// ```\n///\n/// ```gleam\n/// > 3.0 |> add(2.0)\n/// 5.0\n/// ```\n///\npub fn add(a: Float, b: Float) -> Float {\n  a +. b\n}\n\n/// Multiplies two floats together.\n///\n/// It's the function equivalent of the `*.` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > multiply(2.0, 4.0)\n/// 8.0\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n/// > list.fold([2.0, 3.0, 4.0], 1.0, multiply)\n/// 24.0\n/// ```\n///\n/// ```gleam\n/// > 3.0 |> multiply(2.0)\n/// 6.0\n/// ```\n///\npub fn multiply(a: Float, b: Float) -> Float {\n  a *. b\n}\n\n/// Subtracts one float from another.\n///\n/// It's the function equivalent of the `-.` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > subtract(3.0, 1.0)\n/// 2.0\n/// ```\n///\n/// ```gleam\n/// > import gleam/list\n/// > list.fold([1.0, 2.0, 3.0], 10.0, subtract)\n/// 4.0\n/// ```\n///\n/// ```gleam\n/// > 3.0 |> subtract(_, 2.0)\n/// 1.0\n/// ```\n///\n/// ```gleam\n/// > 3.0 |> subtract(2.0, _)\n/// -1.0\n/// ```\n///\npub fn subtract(a: Float, b: Float) -> Float {\n  a -. b\n}\n" (Durability(0))    
2023-08-04T09:30:46.271348Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.271356Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R137    
2023-08-04T09:30:46.271364Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(41)) = "import gleam/list\nimport gleam/map.{Map}\nimport gleam/result\n\nif erlang {\n  // A list is used as the map value as an empty list has the smallest\n  // representation in Erlang's binary format\n  type Token =\n    List(Nil)\n\n  const token = []\n}\n\nif javascript {\n  type Token =\n    Nil\n\n  const token = Nil\n}\n\n/// A set is a collection of unique members of the same type.\n///\n/// It is implemented using the `gleam/map` module, so inserts and lookups have\n/// logarithmic time complexity.\n///\npub opaque type Set(member) {\n  Set(map: Map(member, Token))\n}\n\n/// Creates a new empty set.\n///\npub fn new() -> Set(member) {\n  Set(map.new())\n}\n\n/// Gets the number of members in a set.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new()\n/// > |> insert(1)\n/// > |> insert(2)\n/// > |> size\n/// 2\n/// ```\n///\npub fn size(set: Set(member)) -> Int {\n  map.size(set.map)\n}\n\n/// Inserts an member into the set.\n///\n/// This function runs in logarithmic time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new()\n/// > |> insert(1)\n/// > |> insert(2)\n/// > |> size\n/// 2\n/// ```\n///\npub fn insert(into set: Set(member), this member: member) -> Set(member) {\n  Set(map: map.insert(set.map, member, token))\n}\n\n/// Checks whether a set contains a given member.\n///\n/// This function runs in logarithmic time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new()\n/// > |> insert(2)\n/// > |> contains(2)\n/// True\n/// ```\n///\n/// ```gleam\n/// > new()\n/// > |> insert(2)\n/// > |> contains(1)\n/// False\n/// ```\n///\npub fn contains(in set: Set(member), this member: member) -> Bool {\n  set.map\n  |> map.get(member)\n  |> result.is_ok\n}\n\n/// Removes a member from a set. If the set does not contain the member then\n/// the set is returned unchanged.\n///\n/// This function runs in logarithmic time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new()\n/// > |> insert(2)\n/// > |> delete(2)\n/// > |> contains(1)\n/// False\n/// ```\n///\npub fn delete(from set: Set(member), this member: member) -> Set(member) {\n  Set(map: map.delete(set.map, member))\n}\n\n/// Converts the set into a list of the contained members.\n///\n/// The list has no specific ordering, any unintentional ordering may change in\n/// future versions of Gleam or Erlang.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > new() |> insert(2) |> to_list\n/// [2]\n/// ```\n///\npub fn to_list(set: Set(member)) -> List(member) {\n  map.keys(set.map)\n}\n\n/// Creates a new set of the members in a given list.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/list\n/// > [1, 1, 2, 4, 3, 2] |> from_list |> to_list |> list.sort\n/// [1, 3, 3, 4]\n/// ```\n///\npub fn from_list(members: List(member)) -> Set(member) {\n  let map =\n    list.fold(\n      over: members,\n      from: map.new(),\n      with: fn(m, k) { map.insert(m, k, token) },\n    )\n  Set(map)\n}\n\n/// Combines all entries into a single value by calling a given function on each\n/// one.\n///\n/// Sets are not ordered so the values are not returned in any specific order.\n/// Do not write code that relies on the order entries are used by this\n/// function as it may change in later versions of Gleam or Erlang.\n///\n/// # Examples\n///\n/// ```gleam\n/// > from_list([1, 3, 9])\n/// > |> fold(0, fn(member, accumulator) { accumulator + member })\n/// 13\n/// ```\n///\npub fn fold(\n  over set: Set(member),\n  from initial: acc,\n  with reducer: fn(acc, member) -> acc,\n) -> acc {\n  map.fold(over: set.map, from: initial, with: fn(a, k, _) { reducer(a, k) })\n}\n\n/// Creates a new set from an existing set, minus any members that a given\n/// function returns `False` for.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/int\n/// > from_list([1, 4, 6, 3, 675, 44, 67])\n/// > |> filter(for: int.is_even)\n/// > |> to_list\n/// [4, 6, 44]\n/// ```\n///\npub fn filter(\n  in set: Set(member),\n  for property: fn(member) -> Bool,\n) -> Set(member) {\n  Set(map.filter(in: set.map, for: fn(m, _) { property(m) }))\n}\n\npub fn drop(from set: Set(member), drop disallowed: List(member)) -> Set(member) {\n  list.fold(over: disallowed, from: set, with: delete)\n}\n\n/// Creates a new map from a given map, only including any members which are in\n/// a given list.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3])\n/// > |> take([1, 3, 5])\n/// > |> to_list\n/// [1, 3]\n/// ```\n///\npub fn take(from set: Set(member), keeping desired: List(member)) -> Set(member) {\n  Set(map.take(from: set.map, keeping: desired))\n}\n\nfn order(first: Set(member), second: Set(member)) -> #(Set(member), Set(member)) {\n  case map.size(first.map) > map.size(second.map) {\n    True -> #(first, second)\n    False -> #(second, first)\n  }\n}\n\n/// Creates a new set that contains all members of both given sets.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > union(from_list([1, 2]), from_list([2, 3])) |> to_list\n/// [1, 2, 3]\n/// ```\n///\npub fn union(of first: Set(member), and second: Set(member)) -> Set(member) {\n  let #(larger, smaller) = order(first, second)\n  fold(over: smaller, from: larger, with: insert)\n}\n\n/// Creates a new set that contains members that are present in both given sets.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > intersection(from_list([1, 2]), from_list([2, 3])) |> to_list\n/// [2]\n/// ```\n///\npub fn intersection(\n  of first: Set(member),\n  and second: Set(member),\n) -> Set(member) {\n  let #(larger, smaller) = order(first, second)\n  take(from: larger, keeping: to_list(smaller))\n}\n" (Durability(0))    
2023-08-04T09:30:46.271445Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.271453Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R138    
2023-08-04T09:30:46.271462Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(42)) = "import gleam/result\nimport gleam/int\nimport gleam/list\nimport gleam/map.{Map}\nimport gleam/option.{None, Option, Some}\nimport gleam/order\n\n// Internal private representation of an Iterator\ntype Action(element) {\n  // Dedicated to Electric Six\n  // https://youtu.be/_30t2dzEgiw?t=162\n  Stop\n  Continue(element, fn() -> Action(element))\n}\n\n/// An iterator is a lazily evaluated sequence of element.\n///\n/// Iterators are useful when working with collections that are too large to\n/// fit in memory (or those that are infinite in size) as they only require the\n/// elements currently being processed to be in memory.\n///\n/// As a lazy data structure no work is done when an iterator is filters,\n/// mapped, etc, instead a new iterator is returned with these transformations\n/// applied to the stream. Once the stream has all the required transformations\n/// applied it can be evaluated using functions such as `fold` and `to_list`.\n///\npub opaque type Iterator(element) {\n  Iterator(continuation: fn() -> Action(element))\n}\n\n// Public API for iteration\npub type Step(element, accumulator) {\n  Next(element: element, accumulator: accumulator)\n  Done\n}\n\n// Shortcut for an empty iterator.\nfn stop() -> Action(element) {\n  Stop\n}\n\n// Creating Iterators\nfn do_unfold(\n  initial: acc,\n  f: fn(acc) -> Step(element, acc),\n) -> fn() -> Action(element) {\n  fn() {\n    case f(initial) {\n      Next(x, acc) -> Continue(x, do_unfold(acc, f))\n      Done -> Stop\n    }\n  }\n}\n\n/// Creates an iterator from a given function and accumulator.\n///\n/// The function is called on the accumulator and returns either `Done`,\n/// indicating the iterator has no more elements, or `Next` which contains a\n/// new element and accumulator. The element is yielded by the iterator and the\n/// new accumulator is used with the function to compute the next element in\n/// the sequence.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > unfold(from: 5, with: fn(n) {\n/// >  case n {\n/// >    0 -> Done\n/// >    n -> Next(element: n, accumulator: n - 1)\n/// >  }\n/// > })\n/// > |> to_list\n/// [5, 4, 3, 2, 1]\n/// ```\n///\npub fn unfold(\n  from initial: acc,\n  with f: fn(acc) -> Step(element, acc),\n) -> Iterator(element) {\n  initial\n  |> do_unfold(f)\n  |> Iterator\n}\n\n// TODO: test\n/// Creates an iterator that yields values created by calling a given function\n/// repeatedly.\n///\npub fn repeatedly(f: fn() -> element) -> Iterator(element) {\n  unfold(Nil, fn(_) { Next(f(), Nil) })\n}\n\n/// Creates an iterator that returns the same value infinitely.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > repeat(10)\n/// > |> take(4)\n/// > |> to_list\n/// [10, 10, 10, 10]\n/// ```\n///\npub fn repeat(x: element) -> Iterator(element) {\n  repeatedly(fn() { x })\n}\n\n/// Creates an iterator that yields each element from the given list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4])\n/// > |> to_list\n/// [1, 2, 3, 4]\n/// ```\n///\npub fn from_list(list: List(element)) -> Iterator(element) {\n  let yield = fn(acc) {\n    case acc {\n      [] -> Done\n      [head, ..tail] -> Next(head, tail)\n    }\n  }\n  unfold(list, yield)\n}\n\n// Consuming Iterators\nfn do_transform(\n  continuation: fn() -> Action(a),\n  state: acc,\n  f: fn(acc, a) -> Step(b, acc),\n) -> fn() -> Action(b) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(el, next) ->\n        case f(state, el) {\n          Done -> Stop\n          Next(yield, next_state) ->\n            Continue(yield, do_transform(next, next_state, f))\n        }\n    }\n  }\n}\n\n/// Creates an iterator from an existing iterator\n/// and a stateful function that may short-circuit.\n///\n/// `f` takes arguments `acc` for current state and `el` for current element from underlying iterator,\n/// and returns either `Next` with yielded element and new state value, or `Done` to halt the iterator.\n///\n/// ## Examples\n///\n/// Approximate implementation of `index` in terms of `transform`:\n///\n/// ```gleam\n/// > from_list([\"a\", \"b\", \"c\"])\n/// > |> transform(0, fn(i, el) { Next(#(i, el), i + 1) })\n/// > |> to_list\n/// [#(0, \"a\"), #(1, \"b\"), #(2, \"c\")]\n/// ```\npub fn transform(\n  over iterator: Iterator(a),\n  from initial: acc,\n  with f: fn(acc, a) -> Step(b, acc),\n) -> Iterator(b) {\n  do_transform(iterator.continuation, initial, f)\n  |> Iterator\n}\n\nfn do_fold(\n  continuation: fn() -> Action(e),\n  f: fn(acc, e) -> acc,\n  accumulator: acc,\n) -> acc {\n  case continuation() {\n    Continue(elem, next) -> do_fold(next, f, f(accumulator, elem))\n    Stop -> accumulator\n  }\n}\n\n/// Reduces an iterator of elements into a single value by calling a given\n/// function on each element in turn.\n///\n/// If called on an iterator of infinite length then this function will never\n/// return.\n///\n/// If you do not care about the end value and only wish to evaluate the\n/// iterator for side effects consider using the `run` function instead.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3, 4]\n/// > |> from_list\n/// > |> fold(from: 0, with: fn(acc, element) { element + acc })\n/// 10\n/// ```\n///\npub fn fold(\n  over iterator: Iterator(e),\n  from initial: acc,\n  with f: fn(acc, e) -> acc,\n) -> acc {\n  iterator.continuation\n  |> do_fold(f, initial)\n}\n\n// TODO: test\n/// Evaluates all elements emitted by the given iterator. This function is useful for when\n/// you wish to trigger any side effects that would occur when evaluating\n/// the iterator.\n///\npub fn run(iterator: Iterator(e)) -> Nil {\n  fold(iterator, Nil, fn(_, _) { Nil })\n}\n\n/// Evaluates an iterator and returns all the elements as a list.\n///\n/// If called on an iterator of infinite length then this function will never\n/// return.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3]\n/// > |> from_list\n/// > |> map(fn(x) { x * 2 })\n/// > |> to_list\n/// [2, 4, 6]\n/// ```\n///\npub fn to_list(iterator: Iterator(element)) -> List(element) {\n  iterator\n  |> fold([], fn(acc, e) { [e, ..acc] })\n  |> list.reverse\n}\n\n/// Eagerly accesses the first value of an iterator, returning a `Next`\n/// that contains the first value and the rest of the iterator.\n///\n/// If called on an empty iterator, `Done` is returned.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > let assert Next(first, rest) = [1, 2, 3, 4]\n/// >   |> from_list\n/// >   |> step\n/// > first\n/// 1\n/// ```\n///\n/// ```gleam\n/// > rest |> to_list\n/// [2, 3, 4]\n/// ```\n///\n/// ```gleam\n/// > empty() |> step\n/// Done\n/// ```\n///\npub fn step(iterator: Iterator(e)) -> Step(e, Iterator(e)) {\n  case iterator.continuation() {\n    Stop -> Done\n    Continue(e, a) -> Next(e, Iterator(a))\n  }\n}\n\nfn do_take(continuation: fn() -> Action(e), desired: Int) -> fn() -> Action(e) {\n  fn() {\n    case desired > 0 {\n      False -> Stop\n      True ->\n        case continuation() {\n          Stop -> Stop\n          Continue(e, next) -> Continue(e, do_take(next, desired - 1))\n        }\n    }\n  }\n}\n\n/// Creates an iterator that only yields the first `desired` elements.\n///\n/// If the iterator does not have enough elements all of them are yielded.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3, 4, 5]\n/// > |> from_list\n/// > |> take(up_to: 3)\n/// > |> to_list\n/// [1, 2, 3]\n/// ```\n///\n/// ```gleam\n/// > [1, 2]\n/// > |> from_list\n/// > |> take(up_to: 3)\n/// > |> to_list\n/// [1, 2]\n/// ```\n///\npub fn take(from iterator: Iterator(e), up_to desired: Int) -> Iterator(e) {\n  iterator.continuation\n  |> do_take(desired)\n  |> Iterator\n}\n\nfn do_drop(continuation: fn() -> Action(e), desired: Int) -> Action(e) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, next) ->\n      case desired > 0 {\n        True -> do_drop(next, desired - 1)\n        False -> Continue(e, next)\n      }\n  }\n}\n\n/// Evaluates and discards the first N elements in an iterator, returning a new\n/// iterator.\n///\n/// If the iterator does not have enough elements an empty iterator is\n/// returned.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3, 4, 5]\n/// > |> from_list\n/// > |> drop(up_to: 3)\n/// > |> to_list\n/// [4, 5]\n/// ```\n///\n/// ```gleam\n/// > [1, 2]\n/// > |> from_list\n/// > |> drop(up_to: 3)\n/// > |> to_list\n/// []\n/// ```\n///\npub fn drop(from iterator: Iterator(e), up_to desired: Int) -> Iterator(e) {\n  fn() { do_drop(iterator.continuation, desired) }\n  |> Iterator\n}\n\nfn do_map(continuation: fn() -> Action(a), f: fn(a) -> b) -> fn() -> Action(b) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(e, continuation) -> Continue(f(e), do_map(continuation, f))\n    }\n  }\n}\n\n/// Creates an iterator from an existing iterator and a transformation function.\n///\n/// Each element in the new iterator will be the result of calling the given\n/// function on the elements in the given iterator.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3]\n/// > |> from_list\n/// > |> map(fn(x) { x * 2 })\n/// > |> to_list\n/// [2, 4, 6]\n/// ```\n///\npub fn map(over iterator: Iterator(a), with f: fn(a) -> b) -> Iterator(b) {\n  iterator.continuation\n  |> do_map(f)\n  |> Iterator\n}\n\nfn do_append(first: fn() -> Action(a), second: fn() -> Action(a)) -> Action(a) {\n  case first() {\n    Continue(e, first) -> Continue(e, fn() { do_append(first, second) })\n    Stop -> second()\n  }\n}\n\n/// Appends two iterators, producing a new iterator.\n///\n/// This function does not evaluate the elements of the iterators, the\n/// computation is performed when the resulting iterator is later run.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2]\n/// > |> from_list\n/// > |> append([3, 4] |> from_list)\n/// > |> to_list\n/// [1, 2, 3, 4]\n/// ```\n///\npub fn append(to first: Iterator(a), suffix second: Iterator(a)) -> Iterator(a) {\n  fn() { do_append(first.continuation, second.continuation) }\n  |> Iterator\n}\n\nfn do_flatten(flattened: fn() -> Action(Iterator(a))) -> Action(a) {\n  case flattened() {\n    Stop -> Stop\n    Continue(it, next_iterator) ->\n      do_append(it.continuation, fn() { do_flatten(next_iterator) })\n  }\n}\n\n/// Flattens an iterator of iterators, creating a new iterator.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([[1, 2], [3, 4]])\n/// > |> map(from_list)\n/// > |> flatten\n/// > |> to_list\n/// [1, 2, 3, 4]\n/// ```\n///\npub fn flatten(iterator: Iterator(Iterator(a))) -> Iterator(a) {\n  fn() { do_flatten(iterator.continuation) }\n  |> Iterator\n}\n\n/// Creates an iterator from an existing iterator and a transformation function.\n///\n/// Each element in the new iterator will be the result of calling the given\n/// function on the elements in the given iterator and then flattening the\n/// results.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2]\n/// > |> from_list\n/// > |> flat_map(fn(x) { from_list([x, x + 1]) })\n/// > |> to_list\n/// [1, 2, 2, 3]\n/// ```\n///\npub fn flat_map(\n  over iterator: Iterator(a),\n  with f: fn(a) -> Iterator(b),\n) -> Iterator(b) {\n  iterator\n  |> map(f)\n  |> flatten\n}\n\nfn do_filter(\n  continuation: fn() -> Action(e),\n  predicate: fn(e) -> Bool,\n) -> Action(e) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, iterator) ->\n      case predicate(e) {\n        True -> Continue(e, fn() { do_filter(iterator, predicate) })\n        False -> do_filter(iterator, predicate)\n      }\n  }\n}\n\n/// Creates an iterator from an existing iterator and a predicate function.\n///\n/// The new iterator will contain elements from the first iterator for which\n/// the given function returns `True`.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/int\n/// > [1, 2, 3, 4]\n/// > |> from_list\n/// > |> filter(int.is_even)\n/// > |> to_list\n/// [2, 4]\n/// ```\n///\npub fn filter(\n  iterator: Iterator(a),\n  for predicate: fn(a) -> Bool,\n) -> Iterator(a) {\n  fn() { do_filter(iterator.continuation, predicate) }\n  |> Iterator\n}\n\n/// Creates an iterator that repeats a given iterator infinitely.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2]\n/// > |> from_list\n/// > |> cycle\n/// > |> take(6)\n/// > |> to_list\n/// [1, 2, 1, 2, 1, 2]\n/// ```\n///\npub fn cycle(iterator: Iterator(a)) -> Iterator(a) {\n  repeat(iterator)\n  |> flatten\n}\n\n/// Creates an iterator of ints, starting at a given start int and stepping by\n/// one to a given end int.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > range(from: 1, to: 5) |> to_list\n/// [1, 2, 3, 4, 5]\n/// ```\n///\n/// ```gleam\n/// > range(from: 1, to: -2) |> to_list\n/// [1, 0, -1, -2]\n/// ```\n///\n/// ```gleam\n/// > range(from: 0, to: 0) |> to_list\n/// [0]\n/// ```\n///\npub fn range(from start: Int, to stop: Int) -> Iterator(Int) {\n  case int.compare(start, stop) {\n    order.Eq -> once(fn() { start })\n    order.Gt ->\n      unfold(\n        from: start,\n        with: fn(current) {\n          case current < stop {\n            False -> Next(current, current - 1)\n            True -> Done\n          }\n        },\n      )\n\n    order.Lt ->\n      unfold(\n        from: start,\n        with: fn(current) {\n          case current > stop {\n            False -> Next(current, current + 1)\n            True -> Done\n          }\n        },\n      )\n  }\n}\n\nfn do_find(continuation: fn() -> Action(a), f: fn(a) -> Bool) -> Result(a, Nil) {\n  case continuation() {\n    Stop -> Error(Nil)\n    Continue(e, next) ->\n      case f(e) {\n        True -> Ok(e)\n        False -> do_find(next, f)\n      }\n  }\n}\n\n/// Finds the first element in a given iterator for which the given function returns\n/// `True`.\n///\n/// Returns `Error(Nil)` if the function does not return `True` for any of the\n/// elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > find(from_list([1, 2, 3]), fn(x) { x > 2 })\n/// Ok(3)\n/// ```\n///\n/// ```gleam\n/// > find(from_list([1, 2, 3]), fn(x) { x > 4 })\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > find(empty(), fn(_) { True })\n/// Error(Nil)\n/// ```\n///\npub fn find(\n  in haystack: Iterator(a),\n  one_that is_desired: fn(a) -> Bool,\n) -> Result(a, Nil) {\n  haystack.continuation\n  |> do_find(is_desired)\n}\n\nfn do_index(\n  continuation: fn() -> Action(element),\n  next: Int,\n) -> fn() -> Action(#(Int, element)) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(e, continuation) ->\n        Continue(#(next, e), do_index(continuation, next + 1))\n    }\n  }\n}\n\n/// Wraps values yielded from an iterator with indices, starting from 0.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([\"a\", \"b\", \"c\"]) |> index |> to_list\n/// [#(0, \"a\"), #(1, \"b\"), #(2, \"c\")]\n/// ```\n///\npub fn index(over iterator: Iterator(element)) -> Iterator(#(Int, element)) {\n  iterator.continuation\n  |> do_index(0)\n  |> Iterator\n}\n\n/// Creates an iterator that inifinitely applies a function to a value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > iterate(1, fn(n) { n * 3 }) |> take(5) |> to_list\n/// [1, 3, 9, 27, 81]\n/// ```\n///\npub fn iterate(\n  from initial: element,\n  with f: fn(element) -> element,\n) -> Iterator(element) {\n  unfold(initial, fn(element) { Next(element, f(element)) })\n}\n\nfn do_take_while(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> fn() -> Action(element) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(e, next) ->\n        case predicate(e) {\n          False -> Stop\n          True -> Continue(e, do_take_while(next, predicate))\n        }\n    }\n  }\n}\n\n/// Creates an iterator that yields elements while the predicate returns `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 2, 4])\n/// > |> take_while(satisfying: fn(x) { x < 3 })\n/// > |> to_list\n/// [1, 2]\n/// ```\n///\npub fn take_while(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Iterator(element) {\n  iterator.continuation\n  |> do_take_while(predicate)\n  |> Iterator\n}\n\nfn do_drop_while(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> Action(element) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, next) ->\n      case predicate(e) {\n        False -> Continue(e, next)\n        True -> do_drop_while(next, predicate)\n      }\n  }\n}\n\n/// Creates an iterator that drops elements while the predicate returns `True`,\n/// and then yields the remaining elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4, 2, 5])\n/// > |> drop_while(satisfying: fn(x) { x < 4 })\n/// > |> to_list\n/// [4, 2, 5]\n/// ```\n///\npub fn drop_while(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Iterator(element) {\n  fn() { do_drop_while(iterator.continuation, predicate) }\n  |> Iterator\n}\n\nfn do_scan(\n  continuation: fn() -> Action(element),\n  f: fn(acc, element) -> acc,\n  accumulator: acc,\n) -> fn() -> Action(acc) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(el, next) -> {\n        let accumulated = f(accumulator, el)\n        Continue(accumulated, do_scan(next, f, accumulated))\n      }\n    }\n  }\n}\n\n/// Creates an iterator from an existing iterator and a stateful function.\n///\n/// Specifically, this behaves like `fold`, but yields intermediate results.\n///\n/// ## Examples\n///\n/// ```gleam\n/// // Generate a sequence of partial sums\n/// > from_list([1, 2, 3, 4, 5])\n/// > |> scan(from: 0, with: fn(acc, el) { acc + el })\n/// > |> to_list\n/// [1, 3, 6, 10, 15]\n/// ```\n///\npub fn scan(\n  over iterator: Iterator(element),\n  from initial: acc,\n  with f: fn(acc, element) -> acc,\n) -> Iterator(acc) {\n  iterator.continuation\n  |> do_scan(f, initial)\n  |> Iterator\n}\n\nfn do_zip(\n  left: fn() -> Action(a),\n  right: fn() -> Action(b),\n) -> fn() -> Action(#(a, b)) {\n  fn() {\n    case left() {\n      Stop -> Stop\n      Continue(el_left, next_left) ->\n        case right() {\n          Stop -> Stop\n          Continue(el_right, next_right) ->\n            Continue(#(el_left, el_right), do_zip(next_left, next_right))\n        }\n    }\n  }\n}\n\n/// Zips two iterators together, emitting values from both\n/// until the shorter one runs out.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([\"a\", \"b\", \"c\"])\n/// > |> zip(range(20, 30))\n/// > |> to_list\n/// [#(\"a\", 20), #(\"b\", 21), #(\"c\", 22)]\n/// ```\n///\npub fn zip(left: Iterator(a), right: Iterator(b)) -> Iterator(#(a, b)) {\n  do_zip(left.continuation, right.continuation)\n  |> Iterator\n}\n\n// Result of collecting a single chunk by key\ntype Chunk(element, key) {\n  AnotherBy(List(element), key, element, fn() -> Action(element))\n  LastBy(List(element))\n}\n\nfn next_chunk(\n  continuation: fn() -> Action(element),\n  f: fn(element) -> key,\n  previous_key: key,\n  current_chunk: List(element),\n) -> Chunk(element, key) {\n  case continuation() {\n    Stop -> LastBy(list.reverse(current_chunk))\n    Continue(e, next) -> {\n      let key = f(e)\n      case key == previous_key {\n        True -> next_chunk(next, f, key, [e, ..current_chunk])\n        False -> AnotherBy(list.reverse(current_chunk), key, e, next)\n      }\n    }\n  }\n}\n\nfn do_chunk(\n  continuation: fn() -> Action(element),\n  f: fn(element) -> key,\n  previous_key: key,\n  previous_element: element,\n) -> Action(List(element)) {\n  case next_chunk(continuation, f, previous_key, [previous_element]) {\n    LastBy(chunk) -> Continue(chunk, stop)\n    AnotherBy(chunk, key, el, next) ->\n      Continue(chunk, fn() { do_chunk(next, f, key, el) })\n  }\n}\n\n/// Creates an iterator that emits chunks of elements\n/// for which `f` returns the same value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 2, 3, 4, 4, 6, 7, 7])\n/// > |> chunk(by: fn(n) { n % 2 })\n/// > |> to_list\n/// [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n/// ```\n///\npub fn chunk(\n  over iterator: Iterator(element),\n  by f: fn(element) -> key,\n) -> Iterator(List(element)) {\n  fn() {\n    case iterator.continuation() {\n      Stop -> Stop\n      Continue(e, next) -> do_chunk(next, f, f(e), e)\n    }\n  }\n  |> Iterator\n}\n\n// Result of collecting a single sized chunk\ntype SizedChunk(element) {\n  Another(List(element), fn() -> Action(element))\n  Last(List(element))\n  NoMore\n}\n\nfn next_sized_chunk(\n  continuation: fn() -> Action(element),\n  left: Int,\n  current_chunk: List(element),\n) -> SizedChunk(element) {\n  case continuation() {\n    Stop ->\n      case current_chunk {\n        [] -> NoMore\n        remaining -> Last(list.reverse(remaining))\n      }\n    Continue(e, next) -> {\n      let chunk = [e, ..current_chunk]\n      case left > 1 {\n        False -> Another(list.reverse(chunk), next)\n        True -> next_sized_chunk(next, left - 1, chunk)\n      }\n    }\n  }\n}\n\nfn do_sized_chunk(\n  continuation: fn() -> Action(element),\n  count: Int,\n) -> fn() -> Action(List(element)) {\n  fn() {\n    case next_sized_chunk(continuation, count, []) {\n      NoMore -> Stop\n      Last(chunk) -> Continue(chunk, stop)\n      Another(chunk, next_element) ->\n        Continue(chunk, do_sized_chunk(next_element, count))\n    }\n  }\n}\n\n/// Creates an iterator that emits chunks of given size.\n///\n/// If the last chunk does not have `count` elements, it is yielded\n/// as a partial chunk, with less than `count` elements.\n///\n/// For any `count` less than 1 this function behaves as if it was set to 1.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4, 5, 6])\n/// > |> sized_chunk(into: 2)\n/// > |> to_list\n/// [[1, 2], [3, 4], [5, 6]]\n/// ```\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4, 5, 6, 7, 8])\n/// > |> sized_chunk(into: 3)\n/// > |> to_list\n/// [[1, 2, 3], [4, 5, 6], [7, 8]]\n/// ```\n///\npub fn sized_chunk(\n  over iterator: Iterator(element),\n  into count: Int,\n) -> Iterator(List(element)) {\n  iterator.continuation\n  |> do_sized_chunk(count)\n  |> Iterator\n}\n\nfn do_intersperse(\n  continuation: fn() -> Action(element),\n  separator: element,\n) -> Action(element) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, next) -> {\n      let next_interspersed = fn() { do_intersperse(next, separator) }\n      Continue(separator, fn() { Continue(e, next_interspersed) })\n    }\n  }\n}\n\n/// Creates an iterator that yields the given `elem` element\n/// between elements emitted by the underlying iterator.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > empty()\n/// > |> intersperse(with: 0)\n/// > |> to_list\n/// []\n///\n/// > from_list([1])\n/// > |> intersperse(with: 0)\n/// > |> to_list\n/// [1]\n///\n/// > from_list([1, 2, 3, 4, 5])\n/// > |> intersperse(with: 0)\n/// > |> to_list\n/// [1, 0, 2, 0, 3, 0, 4, 0, 5]\n/// ```\n///\npub fn intersperse(\n  over iterator: Iterator(element),\n  with elem: element,\n) -> Iterator(element) {\n  fn() {\n    case iterator.continuation() {\n      Stop -> Stop\n      Continue(e, next) -> Continue(e, fn() { do_intersperse(next, elem) })\n    }\n  }\n  |> Iterator\n}\n\nfn do_any(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> Bool {\n  case continuation() {\n    Stop -> False\n    Continue(e, next) ->\n      case predicate(e) {\n        True -> True\n        False -> do_any(next, predicate)\n      }\n  }\n}\n\n/// Returns `True` if any element emitted by the iterator satisfies the given predicate,\n/// `False` otherwise.\n///\n/// This function short-circuits once it finds a satisfying element.\n///\n/// An empty iterator results in `False`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > empty() |> any(fn(n) { n % 2 == 0 })\n/// False\n/// ```\n///\n/// ```gleam\n/// > from_list([1, 2, 5, 7, 9]) |> any(fn(n) { n % 2 == 0 })\n/// True\n/// ```\n///\n/// ```gleam\n/// > from_list([1, 3, 5, 7, 9]) |> any(fn(n) { n % 2 == 0 })\n/// False\n/// ```\n///\npub fn any(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Bool {\n  iterator.continuation\n  |> do_any(predicate)\n}\n\nfn do_all(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> Bool {\n  case continuation() {\n    Stop -> True\n    Continue(e, next) ->\n      case predicate(e) {\n        True -> do_all(next, predicate)\n        False -> False\n      }\n  }\n}\n\n/// Returns `True` if all elements emitted by the iterator satisfy the given predicate,\n/// `False` otherwise.\n///\n/// This function short-circuits once it finds a non-satisfying element.\n///\n/// An empty iterator results in `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > empty() |> all(fn(n) { n % 2 == 0 })\n/// True\n/// ```\n///\n/// ```gleam\n/// > from_list([2, 4, 6, 8]) |> all(fn(n) { n % 2 == 0 })\n/// True\n/// ```\n///\n/// ```gleam\n/// > from_list([2, 4, 5, 8]) |> all(fn(n) { n % 2 == 0 })\n/// False\n/// ```\n///\npub fn all(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Bool {\n  iterator.continuation\n  |> do_all(predicate)\n}\n\nfn update_group_with(el: element) -> fn(Option(List(element))) -> List(element) {\n  fn(maybe_group) {\n    case maybe_group {\n      Some(group) -> [el, ..group]\n      None -> [el]\n    }\n  }\n}\n\nfn group_updater(\n  f: fn(element) -> key,\n) -> fn(Map(key, List(element)), element) -> Map(key, List(element)) {\n  fn(groups, elem) {\n    groups\n    |> map.update(f(elem), update_group_with(elem))\n  }\n}\n\n/// Returns a `Map(k, List(element))` of elements from the given iterator\n/// grouped with the given key function.\n///\n/// The order within each group is preserved from the iterator.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4, 5, 6]) |> group(by: fn(n) { n % 3 })\n/// map.from_list([#(0, [3, 6]), #(1, [1, 4]), #(2, [2, 5])])\n/// ```\n///\npub fn group(\n  in iterator: Iterator(element),\n  by key: fn(element) -> key,\n) -> Map(key, List(element)) {\n  iterator\n  |> fold(map.new(), group_updater(key))\n  |> map.map_values(fn(_, group) { list.reverse(group) })\n}\n\n/// This function acts similar to fold, but does not take an initial state.\n/// Instead, it starts from the first yielded element\n/// and combines it with each subsequent element in turn using the given function.\n/// The function is called as `f(accumulator, current_element)`.\n///\n/// Returns `Ok` to indicate a successful run, and `Error` if called on an empty iterator.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([]) |> reduce(fn(acc, x) { acc + x })\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4, 5]) |> reduce(fn(acc, x) { acc + x })\n/// Ok(15)\n/// ```\n///\npub fn reduce(\n  over iterator: Iterator(e),\n  with f: fn(e, e) -> e,\n) -> Result(e, Nil) {\n  case iterator.continuation() {\n    Stop -> Error(Nil)\n    Continue(e, next) ->\n      do_fold(next, f, e)\n      |> Ok\n  }\n}\n\n/// Returns the last element in the given iterator.\n///\n/// Returns `Error(Nil)` if the iterator is empty.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > empty() |> last\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > range(1, 10) |> last\n/// Ok(9)\n/// ```\n///\npub fn last(iterator: Iterator(element)) -> Result(element, Nil) {\n  iterator\n  |> reduce(fn(_, elem) { elem })\n}\n\n/// Creates an iterator that yields no elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > empty() |> to_list\n/// []\n/// ```\n///\npub fn empty() -> Iterator(element) {\n  Iterator(stop)\n}\n\n/// Creates an iterator that yields exactly one element provided by calling the given function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > once(fn() { 1 }) |> to_list\n/// [1]\n/// ```\n///\npub fn once(f: fn() -> element) -> Iterator(element) {\n  fn() { Continue(f(), stop) }\n  |> Iterator\n}\n\n/// Creates an iterator that yields the given element exactly once.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > single(1) |> to_list\n/// [1]\n/// ```\n///\npub fn single(elem: element) -> Iterator(element) {\n  once(fn() { elem })\n}\n\nfn do_interleave(\n  current: fn() -> Action(element),\n  next: fn() -> Action(element),\n) -> Action(element) {\n  case current() {\n    Stop -> next()\n    Continue(e, next_other) ->\n      Continue(e, fn() { do_interleave(next, next_other) })\n  }\n}\n\n/// Creates an iterator that alternates between the two given iterators\n/// until both have run out.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4]) |> interleave(from_list([11, 12, 13, 14])) |> to_list\n/// [1, 11, 2, 12, 3, 13, 4, 14]\n/// ```\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4]) |> interleave(from_list([100])) |> to_list\n/// [1, 100, 2, 3, 4]\n/// ```\n///\npub fn interleave(\n  left: Iterator(element),\n  with right: Iterator(element),\n) -> Iterator(element) {\n  fn() { do_interleave(left.continuation, right.continuation) }\n  |> Iterator\n}\n\nfn do_fold_until(\n  continuation: fn() -> Action(e),\n  f: fn(acc, e) -> list.ContinueOrStop(acc),\n  accumulator: acc,\n) -> acc {\n  case continuation() {\n    Stop -> accumulator\n    Continue(elem, next) ->\n      case f(accumulator, elem) {\n        list.Continue(accumulator) -> do_fold_until(next, f, accumulator)\n        list.Stop(accumulator) -> accumulator\n      }\n  }\n}\n\n/// Like `fold`, `fold_until` reduces an iterator of elements into a single value by calling a given\n/// function on each element in turn, but uses `list.ContinueOrStop` to determine\n/// whether or not to keep iterating.\n///\n/// If called on an iterator of infinite length then this function will only ever\n/// return if the function returns `list.Stop`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/list\n/// > let f = fn(acc, e) {\n/// >   case e {\n/// >     _ if e < 4 -> list.Continue(e + acc)\n/// >     _ -> list.Stop(acc)\n/// >   }\n/// > }\n/// >\n/// > [1, 2, 3, 4]\n/// > |> from_list\n/// > |> fold_until(from: acc, with: f)\n/// 6\n/// ```\n///\npub fn fold_until(\n  over iterator: Iterator(e),\n  from initial: acc,\n  with f: fn(acc, e) -> list.ContinueOrStop(acc),\n) -> acc {\n  iterator.continuation\n  |> do_fold_until(f, initial)\n}\n\nfn do_try_fold(\n  over continuation: fn() -> Action(a),\n  with f: fn(acc, a) -> Result(acc, err),\n  from accumulator: acc,\n) -> Result(acc, err) {\n  case continuation() {\n    Stop -> Ok(accumulator)\n    Continue(elem, next) -> {\n      use accumulator <- result.try(f(accumulator, elem))\n      do_try_fold(next, f, accumulator)\n    }\n  }\n}\n\n/// A variant of fold that might fail.\n///\n/// The folding function should return `Result(accumulator, error)`.\n/// If the returned value is `Ok(accumulator)` try_fold will try the next value in the iterator.\n/// If the returned value is `Error(error)` try_fold will stop and return that error.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > [1, 2, 3, 4]\n/// > |> iterator.from_list()\n/// > |> try_fold(0, fn(acc, i) {\n/// >   case i < 3 {\n/// >     True -> Ok(acc + i)\n/// >     False -> Error(Nil)\n/// >   }\n/// > })\n/// Error(Nil)\n/// ```\n///\npub fn try_fold(\n  over iterator: Iterator(e),\n  from initial: acc,\n  with f: fn(acc, e) -> Result(acc, err),\n) -> Result(acc, err) {\n  iterator.continuation\n  |> do_try_fold(f, initial)\n}\n\n/// Returns the first element yielded by the given iterator, if it exists,\n/// or `Error(Nil)` otherwise.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3]) |> first\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > empty() |> first\n/// Error(Nil)\n/// ```\npub fn first(from iterator: Iterator(e)) -> Result(e, Nil) {\n  case iterator.continuation() {\n    Stop -> Error(Nil)\n    Continue(e, _) -> Ok(e)\n  }\n}\n\n/// Returns nth element yielded by the given iterator, where `0` means the first element.\n///\n/// If there are not enough elements in the iterator, `Error(Nil)` is returned.\n///\n/// For any `index` less than `0` this function behaves as if it was set to `0`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4]) |> at(2)\n/// Ok(3)\n/// ```\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4]) |> at(4)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > empty() |> at(0)\n/// Error(Nil)\n/// ```\n///\npub fn at(in iterator: Iterator(e), get index: Int) -> Result(e, Nil) {\n  iterator\n  |> drop(index)\n  |> first\n}\n\nfn do_length(over continuation: fn() -> Action(e), with length: Int) -> Int {\n  case continuation() {\n    Stop -> length\n    Continue(_, next) -> do_length(next, length + 1)\n  }\n}\n\n/// Counts the number of elements in the given iterator.\n///\n/// This function has to traverse the entire iterator to count its elements,\n/// so it runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > empty() |> length\n/// 0\n/// ```\n///\n/// ```gleam\n/// > from_list([1, 2, 3, 4]) |> length\n/// 4\n/// ```\n///\npub fn length(over iterator: Iterator(e)) -> Int {\n  iterator.continuation\n  |> do_length(0)\n}\n\n/// Traverse an iterator, calling a function on each element.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > empty() |> each(io.println)\n/// Nil\n/// ```\n///\n/// ```gleam\n/// > from_list([\"Tom\", \"Malory\", \"Louis\"]) |> each(io.println)\n/// // -> Tom\n/// // -> Malory\n/// // -> Louis\n/// Nil\n/// ```\n///\npub fn each(over iterator: Iterator(a), with f: fn(a) -> b) -> Nil {\n  iterator\n  |> map(f)\n  |> run\n}\n" (Durability(0))    
2023-08-04T09:30:46.271841Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.271849Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R139    
2023-08-04T09:30:46.271858Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(43)) = "/// `Option` represents a value that may be present or not. `Some` means the value is\n/// present, `None` means the value is not.\n///\n/// This is Gleam's alternative to having a value that could be Null, as is\n/// possible in some other languages.\n///\npub type Option(a) {\n  Some(a)\n  None\n}\n\nfn do_all(list: List(Option(a)), acc: List(a)) -> Option(List(a)) {\n  case list {\n    [] -> Some(acc)\n    [x, ..rest] -> {\n      let accumulate = fn(acc, item) {\n        case acc, item {\n          Some(values), Some(value) -> Some([value, ..values])\n          _, _ -> None\n        }\n      }\n      accumulate(do_all(rest, acc), x)\n    }\n  }\n}\n\n/// Combines a list of `Option`s into a single `Option`.\n/// If all elements in the list are `Some` then returns a `Some` holding the list of values.\n/// If any element is `None` then returns`None`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > all([Some(1), Some(2)])\n/// Some([1, 2])\n/// ```\n///\n/// ```gleam\n/// > all([Some(1), None])\n/// None\n/// ```\n///\npub fn all(list: List(Option(a))) -> Option(List(a)) {\n  do_all(list, [])\n}\n\n/// Checks whether the `Option` is a `Some` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_some(Some(1))\n/// True\n/// ```\n///\n/// ```gleam\n/// > is_some(None)\n/// False\n/// ```\n///\npub fn is_some(option: Option(a)) -> Bool {\n  option != None\n}\n\n/// Checks whether the `Option` is a `None` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_none(Some(1))\n/// False\n/// ```\n///\n/// ```gleam\n/// > is_none(None)\n/// True\n/// ```\n///\npub fn is_none(option: Option(a)) -> Bool {\n  option == None\n}\n\n/// Converts an `Option` type to a `Result` type.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_result(Some(1), \"some_error\")\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > to_result(None, \"some_error\")\n/// Error(\"some_error\")\n/// ```\n///\npub fn to_result(option: Option(a), e) -> Result(a, e) {\n  case option {\n    Some(a) -> Ok(a)\n    _ -> Error(e)\n  }\n}\n\n/// Converts a `Result` type to an `Option` type.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from_result(Ok(1))\n/// Some(1)\n/// ```\n///\n/// ```gleam\n/// > from_result(Error(\"some_error\"))\n/// None\n/// ```\n///\npub fn from_result(result: Result(a, e)) -> Option(a) {\n  case result {\n    Ok(a) -> Some(a)\n    _ -> None\n  }\n}\n\n/// Extracts the value from an `Option`, returning a default value if there is none.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > unwrap(Some(1), 0)\n/// 1\n/// ```\n///\n/// ```gleam\n/// > unwrap(None, 0)\n/// 0\n/// ```\n///\npub fn unwrap(option: Option(a), or default: a) -> a {\n  case option {\n    Some(x) -> x\n    None -> default\n  }\n}\n\n/// Extracts the value from an `Option`, evaluating the default function if the option is `None`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > lazy_unwrap(Some(1), fn() { 0 })\n/// 1\n/// ```\n///\n/// ```gleam\n/// > lazy_unwrap(None, fn() { 0 })\n/// 0\n/// ```\n///\npub fn lazy_unwrap(option: Option(a), or default: fn() -> a) -> a {\n  case option {\n    Some(x) -> x\n    None -> default()\n  }\n}\n\n/// Updates a value held within the `Some` of an `Option` by calling a given function\n/// on it.\n///\n/// If the `Option` is a `None` rather than `Some`, the function is not called and the\n/// `Option` stays the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > map(over: Some(1), with: fn(x) { x + 1 })\n/// Some(2)\n/// ```\n///\n/// ```gleam\n/// > map(over: None, with: fn(x) { x + 1 })\n/// None\n/// ```\n///\npub fn map(over option: Option(a), with fun: fn(a) -> b) -> Option(b) {\n  case option {\n    Some(x) -> Some(fun(x))\n    None -> None\n  }\n}\n\n/// Merges a nested `Option` into a single layer.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > flatten(Some(Some(1)))\n/// Some(1)\n/// ```\n///\n/// ```gleam\n/// > flatten(Some(None))\n/// None\n/// ```\n///\n/// ```gleam\n/// > flatten(None)\n/// None\n/// ```\n///\npub fn flatten(option: Option(Option(a))) -> Option(a) {\n  case option {\n    Some(x) -> x\n    None -> None\n  }\n}\n\n/// Updates a value held within the `Some` of an `Option` by calling a given function\n/// on it, where the given function also returns an `Option`. The two options are\n/// then merged together into one `Option`.\n///\n/// If the `Option` is a `None` rather than `Some` the function is not called and the\n/// option stays the same.\n///\n/// This function is the equivalent of calling `map` followed by `flatten`, and\n/// it is useful for chaining together multiple functions that return `Option`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > then(Some(1), fn(x) { Some(x + 1) })\n/// Some(2)\n/// ```\n///\n/// ```gleam\n/// > then(Some(1), fn(x) { Some(#(\"a\", x)) })\n/// Some(#(\"a\", 1))\n/// ```\n///\n/// ```gleam\n/// > then(Some(1), fn(_) { None })\n/// None\n/// ```\n///\n/// ```gleam\n/// > then(None, fn(x) { Some(x + 1) })\n/// None\n/// ```\n///\npub fn then(option: Option(a), apply fun: fn(a) -> Option(b)) -> Option(b) {\n  case option {\n    Some(x) -> fun(x)\n    None -> None\n  }\n}\n\n/// Returns the first value if it is `Some`, otherwise returns the second value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > or(Some(1), Some(2))\n/// Some(1)\n/// ```\n///\n/// ```gleam\n/// > or(Some(1), None)\n/// Some(1)\n/// ```\n///\n/// ```gleam\n/// > or(None, Some(2))\n/// Some(2)\n/// ```\n///\n/// ```gleam\n/// > or(None, None)\n/// None\n/// ```\n///\npub fn or(first: Option(a), second: Option(a)) -> Option(a) {\n  case first {\n    Some(_) -> first\n    None -> second\n  }\n}\n\n/// Returns the first value if it is `Some`, otherwise evaluates the given function for a fallback value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > lazy_or(Some(1), fn() { Some(2) })\n/// Some(1)\n/// ```\n///\n/// ```gleam\n/// > lazy_or(Some(1), fn() { None })\n/// Some(1)\n/// ```\n///\n/// ```gleam\n/// > lazy_or(None, fn() { Some(2) })\n/// Some(2)\n/// ```\n///\n/// ```gleam\n/// > lazy_or(None, fn() { None })\n/// None\n/// ```\n///\npub fn lazy_or(first: Option(a), second: fn() -> Option(a)) -> Option(a) {\n  case first {\n    Some(_) -> first\n    None -> second()\n  }\n}\n\nfn do_values(list: List(Option(a)), acc: List(a)) -> List(a) {\n  case list {\n    [] -> acc\n    [x, ..xs] -> {\n      let accumulate = fn(acc, item) {\n        case item {\n          Some(value) -> [value, ..acc]\n          None -> acc\n        }\n      }\n      accumulate(do_values(xs, acc), x)\n    }\n  }\n}\n\n/// Given a list of `Option`s,\n/// returns only the values inside `Some`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > values([Some(1), None, Some(3)])\n/// [1, 3]\n/// ```\n///\npub fn values(options: List(Option(a))) -> List(a) {\n  do_values(options, [])\n}\n" (Durability(0))    
2023-08-04T09:30:46.271948Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.271956Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R140    
2023-08-04T09:30:46.271965Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(44)) = "/// Returns the first element in a pair.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > first(#(1, 2))\n/// 1\n/// ```\n///\npub fn first(pair: #(a, b)) -> a {\n  let #(a, _) = pair\n  a\n}\n\n/// Returns the second element in a pair.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > second(#(1, 2))\n/// 2\n/// ```\n///\npub fn second(pair: #(a, b)) -> b {\n  let #(_, a) = pair\n  a\n}\n\n/// Returns a new pair with the elements swapped.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > swap(#(1, 2))\n/// #(2, 1)\n/// ```\n///\npub fn swap(pair: #(a, b)) -> #(b, a) {\n  let #(a, b) = pair\n  #(b, a)\n}\n\n/// Returns a new pair with the first element having had `with` applied to\n/// it.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > #(1, 2) |> map_first(fn(n) { n * 2 })\n/// #(2, 2)\n/// ```\n///\npub fn map_first(of pair: #(a, b), with fun: fn(a) -> c) -> #(c, b) {\n  let #(a, b) = pair\n  #(fun(a), b)\n}\n\n/// Returns a new pair with the second element having had `with` applied to\n/// it.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > #(1, 2) |> map_second(fn(n) { n * 2 })\n/// #(1, 4)\n/// ```\n///\npub fn map_second(of pair: #(a, b), with fun: fn(b) -> c) -> #(a, c) {\n  let #(a, b) = pair\n  #(a, fun(b))\n}\n\n/// Returns a new pair with the given elements. This can also be done using the dedicated\n/// syntax instead: `new(1, 2) == #(1, 2)`.\n/// \n/// ##\u{a0}Examples\n/// \n/// ```gleam\n/// > new(1, 2)\n/// #(1, 2)\n/// ```\n/// \npub fn new(first: a, second: b) -> #(a, b) {\n  #(first, second)\n}\n" (Durability(0))    
2023-08-04T09:30:46.271990Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.271998Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R141    
2023-08-04T09:30:46.272022Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(45)) = "//// Result represents the result of something that may succeed or not.\n//// `Ok` means it was successful, `Error` means it was not successful.\n\nimport gleam/list\n\n/// Checks whether the result is an `Ok` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_ok(Ok(1))\n/// True\n/// ```\n///\n/// ```gleam\n/// > is_ok(Error(Nil))\n/// False\n/// ```\n///\npub fn is_ok(result: Result(a, e)) -> Bool {\n  case result {\n    Error(_) -> False\n    Ok(_) -> True\n  }\n}\n\n/// Checks whether the result is an `Error` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > is_error(Ok(1))\n/// False\n/// ```\n///\n/// ```gleam\n/// > is_error(Error(Nil))\n/// True\n/// ```\n///\npub fn is_error(result: Result(a, e)) -> Bool {\n  case result {\n    Ok(_) -> False\n    Error(_) -> True\n  }\n}\n\n/// Updates a value held within the `Ok` of a result by calling a given function\n/// on it.\n///\n/// If the result is an `Error` rather than `Ok` the function is not called and the\n/// result stays the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > map(over: Ok(1), with: fn(x) { x + 1 })\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > map(over: Error(1), with: fn(x) { x + 1 })\n/// Error(1)\n/// ```\n///\npub fn map(over result: Result(a, e), with fun: fn(a) -> b) -> Result(b, e) {\n  case result {\n    Ok(x) -> Ok(fun(x))\n    Error(e) -> Error(e)\n  }\n}\n\n/// Updates a value held within the `Error` of a result by calling a given function\n/// on it.\n///\n/// If the result is `Ok` rather than `Error` the function is not called and the\n/// result stays the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > map_error(over: Error(1), with: fn(x) { x + 1 })\n/// Error(2)\n/// ```\n///\n/// ```gleam\n/// > map_error(over: Ok(1), with: fn(x) { x + 1 })\n/// Ok(1)\n/// ```\n///\npub fn map_error(\n  over result: Result(a, e),\n  with fun: fn(e) -> f,\n) -> Result(a, f) {\n  case result {\n    Ok(x) -> Ok(x)\n    Error(error) -> Error(fun(error))\n  }\n}\n\n/// Merges a nested `Result` into a single layer.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > flatten(Ok(Ok(1)))\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > flatten(Ok(Error(\"\")))\n/// Error(\"\")\n/// ```\n///\n/// ```gleam\n/// > flatten(Error(Nil))\n/// Error(Nil)\n/// ```\n///\npub fn flatten(result: Result(Result(a, e), e)) -> Result(a, e) {\n  case result {\n    Ok(x) -> x\n    Error(error) -> Error(error)\n  }\n}\n\n/// Updates a value held within the `Ok` of a result by calling a given function\n/// on it, where the given function also returns a result. The two results are\n/// then merged together into one result.\n///\n/// If the result is an `Error` rather than `Ok` the function is not called and the\n/// result stays the same.\n///\n/// This function is the equivalent of calling `map` followed by `flatten`, and\n/// it is useful for chaining together multiple functions that may fail.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > try(Ok(1), fn(x) { Ok(x + 1) })\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > try(Ok(1), fn(x) { Ok(#(\"a\", x)) })\n/// Ok(#(\"a\", 1))\n/// ```\n///\n/// ```gleam\n/// > try(Ok(1), fn(_) { Error(\"Oh no\") })\n/// Error(\"Oh no\")\n/// ```\n///\n/// ```gleam\n/// > try(Error(Nil), fn(x) { Ok(x + 1) })\n/// Error(Nil)\n/// ```\n///\npub fn try(\n  result: Result(a, e),\n  apply fun: fn(a) -> Result(b, e),\n) -> Result(b, e) {\n  case result {\n    Ok(x) -> fun(x)\n    Error(e) -> Error(e)\n  }\n}\n\n/// An alias for `try`. See the documentation for that function for more information.\n///\npub fn then(\n  result: Result(a, e),\n  apply fun: fn(a) -> Result(b, e),\n) -> Result(b, e) {\n  try(result, fun)\n}\n\n/// Extracts the `Ok` value from a result, returning a default value if the result\n/// is an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > unwrap(Ok(1), 0)\n/// 1\n/// ```\n///\n/// ```gleam\n/// > unwrap(Error(\"\"), 0)\n/// 0\n/// ```\n///\npub fn unwrap(result: Result(a, e), or default: a) -> a {\n  case result {\n    Ok(v) -> v\n    Error(_) -> default\n  }\n}\n\n/// Extracts the `Ok` value from a result, evaluating the default function if the result\n/// is an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > lazy_unwrap(Ok(1), fn() { 0 })\n/// 1\n/// ```\n///\n/// ```gleam\n/// > lazy_unwrap(Error(\"\"), fn() { 0 })\n/// 0\n/// ```\n///\npub fn lazy_unwrap(result: Result(a, e), or default: fn() -> a) -> a {\n  case result {\n    Ok(v) -> v\n    Error(_) -> default()\n  }\n}\n\n/// Extracts the `Error` value from a result, returning a default value if the result\n/// is an `Ok`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > unwrap_error(Error(1), 0)\n/// 1\n/// ```\n///\n/// ```gleam\n/// > unwrap_error(Ok(\"\"), 0)\n/// 0\n/// ```\n///\npub fn unwrap_error(result: Result(a, e), or default: e) -> e {\n  case result {\n    Ok(_) -> default\n    Error(e) -> e\n  }\n}\n\n/// Extracts the inner value from a result. Both the value and error must be of\n/// the same type.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > unwrap_both(Error(1))\n/// 1\n/// ```\n///\n/// ```gleam\n/// > unwrap_both(Ok(2))\n/// 2\n/// ```\n///\npub fn unwrap_both(result: Result(a, a)) -> a {\n  case result {\n    Ok(a) -> a\n    Error(a) -> a\n  }\n}\n\n/// Transforms any error into `Error(Nil)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > nil_error(Error(1))\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > nil_error(Ok(1))\n/// Ok(1)\n/// ```\n///\npub fn nil_error(result: Result(a, e)) -> Result(a, Nil) {\n  map_error(result, fn(_) { Nil })\n}\n\n/// Returns the first value if it is `Ok`, otherwise returns the second value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > or(Ok(1), Ok(2))\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > or(Ok(1), Error(\"Error 2\"))\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > or(Error(\"Error 1\"), Ok(2))\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > or(Error(\"Error 1\"), Error(\"Error 2\"))\n/// Error(\"Error 2\")\n/// ```\n///\npub fn or(first: Result(a, e), second: Result(a, e)) -> Result(a, e) {\n  case first {\n    Ok(_) -> first\n    Error(_) -> second\n  }\n}\n\n/// Returns the first value if it is `Ok`, otherwise evaluates the given function for a fallback value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > lazy_or(Ok(1), fn() { Ok(2) })\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > lazy_or(Ok(1), fn() { Error(\"Error 2\") })\n/// Ok(1)\n/// ```\n///\n/// ```gleam\n/// > lazy_or(Error(\"Error 1\"), fn() { Ok(2) })\n/// Ok(2)\n/// ```\n///\n/// ```gleam\n/// > lazy_or(Error(\"Error 1\"), fn() { Error(\"Error 2\") })\n/// Error(\"Error 2\")\n/// ```\n///\npub fn lazy_or(\n  first: Result(a, e),\n  second: fn() -> Result(a, e),\n) -> Result(a, e) {\n  case first {\n    Ok(_) -> first\n    Error(_) -> second()\n  }\n}\n\n/// Combines a list of results into a single result.\n/// If all elements in the list are `Ok` then returns an `Ok` holding the list of values.\n/// If any element is `Error` then returns the first error.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > all([Ok(1), Ok(2)])\n/// Ok([1, 2])\n/// ```\n///\n/// ```gleam\n/// > all([Ok(1), Error(\"e\")])\n/// Error(\"e\")\n/// ```\n///\npub fn all(results: List(Result(a, e))) -> Result(List(a), e) {\n  list.try_map(results, fn(x) { x })\n}\n\n/// Given a list of results, returns a pair where the first element is a list\n/// of all the values inside `Ok` and the second element is a list with all the\n/// values inside `Error`. The values in both lists appear in reverse order with\n/// respect to their position in the original list of results. \n///\n/// ## Examples\n///\n/// ```gleam\n/// > partition([Ok(1), Error(\"a\"), Error(\"b\"), Ok(2)])\n/// #([2, 1], [\"b\", \"a\"])\n/// ```\n///\npub fn partition(results: List(Result(a, e))) -> #(List(a), List(e)) {\n  do_partition(results, [], [])\n}\n\nfn do_partition(results: List(Result(a, e)), oks: List(a), errors: List(e)) {\n  case results {\n    [] -> #(oks, errors)\n    [Ok(a), ..rest] -> do_partition(rest, [a, ..oks], errors)\n    [Error(e), ..rest] -> do_partition(rest, oks, [e, ..errors])\n  }\n}\n\n/// Replace the value within a result\n///\n/// ## Examples\n///\n/// ```gleam\n/// > replace(Ok(1), Nil)\n/// Ok(Nil)\n/// ```\n///\n/// ```gleam\n/// > replace(Error(1), Nil)\n/// Error(1)\n/// ```\n///\npub fn replace(result: Result(a, e), value: b) -> Result(b, e) {\n  case result {\n    Ok(_) -> Ok(value)\n    Error(error) -> Error(error)\n  }\n}\n\n/// Replace the error within a result\n///\n/// ## Examples\n///\n/// ```gleam\n/// > replace_error(Error(1), Nil)\n/// Error(Nil)\n/// ```\n///\n/// ```gleam\n/// > replace_error(Ok(1), Nil)\n/// Ok(1)\n/// ```\n///\npub fn replace_error(result: Result(a, e1), error: e2) -> Result(a, e2) {\n  case result {\n    Ok(x) -> Ok(x)\n    Error(_) -> Error(error)\n  }\n}\n\n/// Given a list of results, returns only the values inside `Ok`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > values([Ok(1), None, Ok(3)])\n/// [1, 3]\n/// ```\n///\npub fn values(results: List(Result(a, e))) -> List(a) {\n  list.filter_map(results, fn(r) { r })\n}\n" (Durability(0))    
2023-08-04T09:30:46.272139Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.272147Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R142    
2023-08-04T09:30:46.272155Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(46)) = "/// Represents the result of a single comparison to determine the precise\n/// ordering of two values.\n///\npub type Order {\n  /// Less-than\n  Lt\n\n  /// Equal\n  Eq\n\n  /// Greater than\n  Gt\n}\n\n/// Inverts an order, so less-than becomes greater-than and greater-than\n/// becomes less-than.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > reverse(Lt)\n/// Gt\n/// ```\n///\n/// ```gleam\n/// > reverse(Eq)\n/// Eq\n/// ```\n///\n/// ```gleam\n/// > reverse(Lt)\n/// Gt\n/// ```\n///\npub fn reverse(order: Order) -> Order {\n  case order {\n    Lt -> Gt\n    Eq -> Eq\n    Gt -> Lt\n  }\n}\n\n/// Produces a numeric representation of the order.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > to_int(Lt)\n/// -1\n/// ```\n///\n/// ```gleam\n/// > to_int(Eq)\n/// 0\n/// ```\n///\n/// ```gleam\n/// > to_int(Gt)\n/// 1\n/// ```\n///\npub fn to_int(order: Order) -> Int {\n  case order {\n    Lt -> -1\n    Eq -> 0\n    Gt -> 1\n  }\n}\n\n/// Compares two `Order` values to one another, producing a new `Order`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > compare(Eq, with: Lt)\n/// Gt\n/// ```\n///\npub fn compare(a: Order, with b: Order) -> Order {\n  case a, b {\n    x, y if x == y -> Eq\n    Lt, _ | Eq, Gt -> Lt\n    _, _ -> Gt\n  }\n}\n\n/// Returns the largest of two orders.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > max(Eq, Lt)\n/// Eq\n/// ```\n///\npub fn max(a: Order, b: Order) -> Order {\n  case a, b {\n    Gt, _ -> Gt\n    Eq, Lt -> Eq\n    _, _ -> b\n  }\n}\n\n/// Returns the smallest of two orders.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > min(Eq, Lt)\n/// Lt\n/// ```\n///\npub fn min(a: Order, b: Order) -> Order {\n  case a, b {\n    Lt, _ -> Lt\n    Eq, Gt -> Eq\n    _, _ -> b\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.272184Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.272192Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R143    
2023-08-04T09:30:46.272200Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(47)) = "import gleam/int\nimport gleam/list\nimport gleam/map.{Map}\nimport gleam/option.{Option}\nimport gleam/result\nimport gleam/string_builder\n\nif erlang {\n  import gleam/bit_string\n}\n\n/// `Dynamic` data is data that we don't know the type of yet.\n/// We likely get data like this from interop with Erlang, or from\n/// IO with the outside world.\n///\npub external type Dynamic\n\n/// Error returned when unexpected data is encountered\n///\npub type DecodeError {\n  DecodeError(expected: String, found: String, path: List(String))\n}\n\npub type DecodeErrors =\n  List(DecodeError)\n\npub type Decoder(t) =\n  fn(Dynamic) -> Result(t, DecodeErrors)\n\n/// Converts any Gleam data into `Dynamic` data.\n///\npub fn from(a) -> Dynamic {\n  do_from(a)\n}\n\nif erlang {\n  external fn do_from(anything) -> Dynamic =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn do_from(anything) -> Dynamic =\n    \"../gleam_stdlib.mjs\" \"identity\"\n}\n\n/// Unsafely casts a Dynamic value into any other type.\n///\n/// This is an escape hatch for the type system that may be useful when wrapping\n/// native Erlang APIs. It is to be used as a last measure only!\n///\n/// If you can avoid using this function, do!\n///\npub fn unsafe_coerce(a: Dynamic) -> anything {\n  do_unsafe_coerce(a)\n}\n\nif erlang {\n  external fn do_unsafe_coerce(Dynamic) -> a =\n    \"gleam_stdlib\" \"identity\"\n}\n\nif javascript {\n  external fn do_unsafe_coerce(Dynamic) -> a =\n    \"../gleam_stdlib.mjs\" \"identity\"\n}\n\n/// Decodes a `Dynamic` value from a `Dynamic` value.\n///\n/// This function doesn't seem very useful at first, but it can be convenient\n/// when you need to give a decoder function but you don't actually care what\n/// the to-decode value is.\n///\npub fn dynamic(value: Dynamic) -> Result(Dynamic, List(DecodeError)) {\n  Ok(value)\n}\n\n/// Checks to see whether a `Dynamic` value is a bit_string, and returns that bit string if\n/// it is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > bit_string(from(\"Hello\")) == bit_string.from_string(\"Hello\")\n/// True\n/// ```\n///\n/// ```gleam\n/// > bit_string(from(123))\n/// Error([DecodeError(expected: \"BitString\", found: \"Int\", path: [])])\n/// ```\n///\npub fn bit_string(from data: Dynamic) -> Result(BitString, DecodeErrors) {\n  decode_bit_string(data)\n}\n\nif erlang {\n  external fn decode_bit_string(Dynamic) -> Result(BitString, DecodeErrors) =\n    \"gleam_stdlib\" \"decode_bit_string\"\n}\n\nif javascript {\n  external fn decode_bit_string(Dynamic) -> Result(BitString, DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_bit_string\"\n}\n\n/// Checks to see whether a `Dynamic` value is a string, and returns that string if\n/// it is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > string(from(\"Hello\"))\n/// Ok(\"Hello\")\n/// ```\n///\n/// ```gleam\n/// > string(from(123))\n/// Error([DecodeError(expected: \"String\", found: \"Int\", path: [])])\n/// ```\n///\npub fn string(from data: Dynamic) -> Result(String, DecodeErrors) {\n  decode_string(data)\n}\n\nfn map_errors(\n  result: Result(t, DecodeErrors),\n  f: fn(DecodeError) -> DecodeError,\n) -> Result(t, DecodeErrors) {\n  result.map_error(result, list.map(_, f))\n}\n\nif erlang {\n  fn decode_string(data: Dynamic) -> Result(String, DecodeErrors) {\n    bit_string(data)\n    |> map_errors(put_expected(_, \"String\"))\n    |> result.try(fn(raw) {\n      case bit_string.to_string(raw) {\n        Ok(string) -> Ok(string)\n        Error(Nil) ->\n          Error([DecodeError(expected: \"String\", found: \"BitString\", path: [])])\n      }\n    })\n  }\n\n  fn put_expected(error: DecodeError, expected: String) -> DecodeError {\n    DecodeError(..error, expected: expected)\n  }\n}\n\nif javascript {\n  external fn decode_string(Dynamic) -> Result(String, DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_string\"\n}\n\n/// Return a string indicating the type of the dynamic value.\n///\n/// ```gleam\n/// > classify(from(\"Hello\"))\n/// \"String\"\n/// ```\n///\npub fn classify(data: Dynamic) -> String {\n  do_classify(data)\n}\n\nif erlang {\n  external fn do_classify(Dynamic) -> String =\n    \"gleam_stdlib\" \"classify_dynamic\"\n}\n\nif javascript {\n  external fn do_classify(Dynamic) -> String =\n    \"../gleam_stdlib.mjs\" \"classify_dynamic\"\n}\n\n/// Checks to see whether a `Dynamic` value is an int, and returns that int if it\n/// is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > int(from(123))\n/// Ok(123)\n/// ```\n///\n/// ```gleam\n/// > int(from(\"Hello\"))\n/// Error([DecodeError(expected: \"Int\", found: \"String\", path: [])])\n/// ```\n///\npub fn int(from data: Dynamic) -> Result(Int, DecodeErrors) {\n  decode_int(data)\n}\n\nif erlang {\n  external fn decode_int(Dynamic) -> Result(Int, DecodeErrors) =\n    \"gleam_stdlib\" \"decode_int\"\n}\n\nif javascript {\n  external fn decode_int(Dynamic) -> Result(Int, DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_int\"\n}\n\n/// Checks to see whether a `Dynamic` value is a float, and returns that float if\n/// it is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > float(from(2.0))\n/// Ok(2.0)\n/// ```\n///\n/// ```gleam\n/// > float(from(123))\n/// Error([DecodeError(expected: \"Float\", found: \"Int\", path: [])])\n/// ```\n///\npub fn float(from data: Dynamic) -> Result(Float, DecodeErrors) {\n  decode_float(data)\n}\n\nif erlang {\n  external fn decode_float(Dynamic) -> Result(Float, DecodeErrors) =\n    \"gleam_stdlib\" \"decode_float\"\n}\n\nif javascript {\n  external fn decode_float(Dynamic) -> Result(Float, DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_float\"\n}\n\n/// Checks to see whether a `Dynamic` value is a bool, and returns that bool if\n/// it is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > bool(from(True))\n/// Ok(True)\n/// ```\n///\n/// ```gleam\n/// > bool(from(123))\n/// Error([DecodeError(expected: \"Bool\", found: \"Int\", path: [])])\n/// ```\n///\npub fn bool(from data: Dynamic) -> Result(Bool, DecodeErrors) {\n  decode_bool(data)\n}\n\nif erlang {\n  external fn decode_bool(Dynamic) -> Result(Bool, DecodeErrors) =\n    \"gleam_stdlib\" \"decode_bool\"\n}\n\nif javascript {\n  external fn decode_bool(Dynamic) -> Result(Bool, DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_bool\"\n}\n\n/// Checks to see whether a `Dynamic` value is a list, and returns that list if it\n/// is. The types of the elements are not checked.\n///\n/// If you wish to decode all the elements in the list use the `list` function\n/// instead.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > shallow_list(from([\"a\", \"b\", \"c\"]))\n/// Ok([from(\"a\"), from(\"b\"), from(\"c\")])\n/// ```\n///\n/// ```gleam\n/// > shallow_list(1)\n/// Error([DecodeError(expected: \"List\", found: \"Int\", path: [])])\n/// ```\n///\npub fn shallow_list(from value: Dynamic) -> Result(List(Dynamic), DecodeErrors) {\n  decode_list(value)\n}\n\nif erlang {\n  external fn decode_list(Dynamic) -> Result(List(Dynamic), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_list\"\n}\n\nif javascript {\n  external fn decode_list(Dynamic) -> Result(List(Dynamic), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_list\"\n}\n\nif erlang {\n  external fn decode_result(Dynamic) -> Result(Result(a, e), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_result\"\n}\n\nif javascript {\n  external fn decode_result(Dynamic) -> Result(Result(a, e), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_result\"\n}\n\n/// Checks to see whether a `Dynamic` value is a result of a particular type, and\n/// returns that result if it is.\n///\n/// The `ok` and `error` arguments are decoders for decoding the `Ok` and\n/// `Error` values of the result.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(Ok(1))\n/// > |> result(ok: int, error: string)\n/// Ok(Ok(1))\n/// ```\n///\n/// ```gleam\n/// > from(Error(\"boom\"))\n/// > |> result(ok: int, error: string)\n/// Ok(Error(\"boom\"))\n/// ```\n///\n/// ```gleam\n/// > from(123)\n/// > |> result(ok: int, error: string)\n/// Error([DecodeError(expected: \"Result\", found: \"Int\", path: [])])\n/// ```\n///\npub fn result(\n  ok decode_ok: Decoder(a),\n  error decode_error: Decoder(e),\n) -> Decoder(Result(a, e)) {\n  fn(value) {\n    use inner_result <- result.try(decode_result(value))\n\n    case inner_result {\n      Ok(raw) -> {\n        use value <- result.try(\n          decode_ok(raw)\n          |> map_errors(push_path(_, \"ok\")),\n        )\n        Ok(Ok(value))\n      }\n      Error(raw) -> {\n        use value <- result.try(\n          decode_error(raw)\n          |> map_errors(push_path(_, \"error\")),\n        )\n        Ok(Error(value))\n      }\n    }\n  }\n}\n\n/// Checks to see whether a `Dynamic` value is a list of a particular type, and\n/// returns that list if it is.\n///\n/// The second argument is a decoder function used to decode the elements of\n/// the list. The list is only decoded if all elements in the list can be\n/// successfully decoded using this function.\n///\n/// If you do not wish to decode all the elements in the list use the `shallow_list`\n/// function instead.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from([\"a\", \"b\", \"c\"])\n/// > |> list(of: string)\n/// Ok([\"a\", \"b\", \"c\"])\n/// ```\n///\n/// ```gleam\n/// > from([1, 2, 3])\n/// > |> list(of: string)\n/// Error([DecodeError(expected: \"String\", found: \"Int\", path: [\"*\"])])\n/// ```\n///\n/// ```gleam\n/// > from(\"ok\")\n/// > |> list(of: string)\n/// Error([DecodeError(expected: \"List\", found: \"String\", path: [])])\n/// ```\n///\npub fn list(\n  of decoder_type: fn(Dynamic) -> Result(inner, DecodeErrors),\n) -> Decoder(List(inner)) {\n  fn(dynamic) {\n    use list <- result.try(shallow_list(dynamic))\n    list\n    |> list.try_map(decoder_type)\n    |> map_errors(push_path(_, \"*\"))\n  }\n}\n\n/// Checks to see if a `Dynamic` value is a nullable version of a particular\n/// type, and returns a corresponding `Option` if it is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(\"Hello\")\n/// > |> optional(string)\n/// Ok(Some(\"Hello\"))\n/// ```\n///\n/// ```gleam\n/// > from(\"Hello\")\n/// > |> optional(string)\n/// Ok(Some(\"Hello\"))\n/// ```\n///\n/// ```gleam\n/// > from(atom.from_string(\"null\"))\n/// > |> optional(string)\n/// Ok(None)\n/// ```\n///\n/// ```gleam\n/// > from(atom.from_string(\"nil\"))\n/// > |> optional(string)\n/// Ok(None)\n/// ```\n///\n/// ```gleam\n/// > from(atom.from_string(\"undefined\"))\n/// > |> optional(string)\n/// Ok(None)\n/// ```\n///\n/// ```gleam\n/// > from(123)\n/// > |> optional(string)\n/// Error([DecodeError(expected: \"String\", found: \"Int\", path: [])])\n/// ```\n///\npub fn optional(of decode: Decoder(inner)) -> Decoder(Option(inner)) {\n  fn(value) { decode_optional(value, decode) }\n}\n\nif erlang {\n  external fn decode_optional(\n    Dynamic,\n    Decoder(a),\n  ) -> Result(Option(a), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_option\"\n}\n\nif javascript {\n  external fn decode_optional(\n    Dynamic,\n    Decoder(a),\n  ) -> Result(Option(a), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_option\"\n}\n\n/// Checks to see if a `Dynamic` value is a map with a specific field, and returns\n/// the value of that field if it is.\n///\n/// This will not succeed on a record.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/map\n/// > map.new()\n/// > |> map.insert(\"Hello\", \"World\")\n/// > |> from\n/// > |> field(named: \"Hello\", of: string)\n/// Ok(\"World\")\n/// ```\n///\n/// ```gleam\n/// > from(123)\n/// > |> field(\"Hello\", string)\n/// Error([DecodeError(expected: \"Map\", found: \"Int\", path: [])])\n/// ```\n///\npub fn field(named name: a, of inner_type: Decoder(t)) -> Decoder(t) {\n  fn(value) {\n    let missing_field_error =\n      DecodeError(expected: \"field\", found: \"nothing\", path: [])\n\n    use maybe_inner <- result.try(decode_field(value, name))\n    maybe_inner\n    |> option.to_result([missing_field_error])\n    |> result.try(inner_type)\n    |> map_errors(push_path(_, name))\n  }\n}\n\n/// Checks to see if a `Dynamic` value is a map with a specific field.\n/// If the map does not have the specified field, returns an `Ok(None)` instead of failing; otherwise,\n/// returns the decoded field wrapped in `Some(_)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/map\n/// > map.new()\n/// > |> map.insert(\"Hello\", \"World\")\n/// > |> from\n/// > |> field(named: \"Hello\", of: string)\n/// Ok(Some(\"World\"))\n/// ```\n///\n/// ```gleam\n/// > import gleam/map\n/// > map.new()\n/// > |> from\n/// > |> field(named: \"Hello\", of: string)\n/// Ok(None)\n/// ```\n///\n/// ```gleam\n/// > from(123)\n/// > |> field(\"Hello\", string)\n/// Error([DecodeError(expected: \"Map\", found: \"Int\", path: [])])\n/// ```\n///\npub fn optional_field(\n  named name: a,\n  of inner_type: Decoder(t),\n) -> Decoder(Option(t)) {\n  fn(value) {\n    use maybe_inner <- result.try(decode_field(value, name))\n    case maybe_inner {\n      option.None -> Ok(option.None)\n      option.Some(dynamic_inner) ->\n        dynamic_inner\n        |> decode_optional(inner_type)\n        |> map_errors(push_path(_, name))\n    }\n  }\n}\n\nif erlang {\n  external fn decode_field(\n    Dynamic,\n    name,\n  ) -> Result(Option(Dynamic), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_field\"\n}\n\nif javascript {\n  external fn decode_field(\n    Dynamic,\n    name,\n  ) -> Result(Option(Dynamic), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_field\"\n}\n\n/// Checks to see if a `Dynamic` value is a tuple large enough to have a certain\n/// index, and returns the value of that index if it is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2))\n/// > |> element(0, int)\n/// Ok(from(1))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2))\n/// > |> element(2, int)\n/// Error([\n///   DecodeError(\n///     expected: \"Tuple of at least 3 elements\",\n///     found: \"Tuple of 2 elements\",\n///     path: [],\n///   ),\n/// ])\n/// ```\n///\npub fn element(at index: Int, of inner_type: Decoder(t)) -> Decoder(t) {\n  fn(data: Dynamic) {\n    use tuple <- result.try(decode_tuple(data))\n    let size = tuple_size(tuple)\n    use data <- result.try(case index >= 0 {\n      True ->\n        case index < size {\n          True -> tuple_get(tuple, index)\n          False -> at_least_decode_tuple_error(index + 1, data)\n        }\n      False ->\n        case int.absolute_value(index) <= size {\n          True -> tuple_get(tuple, size + index)\n          False -> at_least_decode_tuple_error(int.absolute_value(index), data)\n        }\n    })\n    inner_type(data)\n    |> map_errors(push_path(_, index))\n  }\n}\n\nfn at_least_decode_tuple_error(\n  size: Int,\n  data: Dynamic,\n) -> Result(a, DecodeErrors) {\n  let s = case size {\n    1 -> \"\"\n    _ -> \"s\"\n  }\n  let error =\n    [\"Tuple of at least \", int.to_string(size), \" element\", s]\n    |> string_builder.from_strings\n    |> string_builder.to_string\n    |> DecodeError(found: classify(data), path: [])\n  Error([error])\n}\n\n// A tuple of unknown size\nexternal type UnknownTuple\n\nif erlang {\n  external fn decode_tuple(Dynamic) -> Result(UnknownTuple, DecodeErrors) =\n    \"gleam_stdlib\" \"decode_tuple\"\n\n  external fn decode_tuple2(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_tuple2\"\n\n  external fn decode_tuple3(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic, Dynamic), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_tuple3\"\n\n  external fn decode_tuple4(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic, Dynamic, Dynamic), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_tuple4\"\n\n  external fn decode_tuple5(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic, Dynamic, Dynamic, Dynamic), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_tuple5\"\n\n  external fn decode_tuple6(\n    Dynamic,\n  ) -> Result(\n    #(Dynamic, Dynamic, Dynamic, Dynamic, Dynamic, Dynamic),\n    DecodeErrors,\n  ) =\n    \"gleam_stdlib\" \"decode_tuple6\"\n\n  external fn tuple_get(UnknownTuple, Int) -> Result(Dynamic, DecodeErrors) =\n    \"gleam_stdlib\" \"tuple_get\"\n\n  external fn tuple_size(UnknownTuple) -> Int =\n    \"gleam_stdlib\" \"size_of_tuple\"\n}\n\nif javascript {\n  external fn decode_tuple(Dynamic) -> Result(UnknownTuple, DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_tuple\"\n\n  external fn decode_tuple2(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_tuple2\"\n\n  external fn decode_tuple3(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic, Dynamic), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_tuple3\"\n\n  external fn decode_tuple4(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic, Dynamic, Dynamic), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_tuple4\"\n\n  external fn decode_tuple5(\n    Dynamic,\n  ) -> Result(#(Dynamic, Dynamic, Dynamic, Dynamic, Dynamic), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_tuple5\"\n\n  external fn decode_tuple6(\n    Dynamic,\n  ) -> Result(\n    #(Dynamic, Dynamic, Dynamic, Dynamic, Dynamic, Dynamic),\n    DecodeErrors,\n  ) =\n    \"../gleam_stdlib.mjs\" \"decode_tuple6\"\n\n  external fn tuple_get(UnknownTuple, Int) -> Result(Dynamic, DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"tuple_get\"\n\n  external fn tuple_size(UnknownTuple) -> Int =\n    \"../gleam_stdlib.mjs\" \"length\"\n}\n\nfn tuple_errors(\n  result: Result(a, List(DecodeError)),\n  name: String,\n) -> List(DecodeError) {\n  case result {\n    Ok(_) -> []\n    Error(errors) -> list.map(errors, push_path(_, name))\n  }\n}\n\nfn push_path(error: DecodeError, name: t) -> DecodeError {\n  let name = from(name)\n  let decoder = any([string, fn(x) { result.map(int(x), int.to_string) }])\n  let name = case decoder(name) {\n    Ok(name) -> name\n    Error(_) ->\n      [\"<\", classify(name), \">\"]\n      |> string_builder.from_strings\n      |> string_builder.to_string\n  }\n  DecodeError(..error, path: [name, ..error.path])\n}\n\n/// Checks to see if a `Dynamic` value is a 2-element tuple, list or array containing\n/// specifically typed elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2))\n/// > |> tuple2(int, int)\n/// Ok(#(1, 2))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2.0))\n/// > |> tuple2(int, float)\n/// Ok(#(1, 2.0))\n/// ```\n///\n/// ```gleam\n/// > from([1, 2])\n/// > |> tuple2(int, int)\n/// Ok(#(1, 2))\n/// ```\n///\n/// ```gleam\n/// > from([from(1), from(2.0)])\n/// > |> tuple2(int, float)\n/// Ok(#(1, 2.0))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2, 3))\n/// > |> tuple2(int, float)\n/// Error([\n///   DecodeError(expected: \"Tuple of 2 elements\", found: \"Tuple of 3 elements\", path: []),\n/// ])\n/// ```\n///\n/// ```gleam\n/// > from(\"\")\n/// > |> tuple2(int, float)\n/// Error([DecodeError(expected: \"Tuple of 2 elements\", found: \"String\", path: [])])\n/// ```\n///\npub fn tuple2(\n  first decode1: Decoder(a),\n  second decode2: Decoder(b),\n) -> Decoder(#(a, b)) {\n  fn(value) {\n    use #(a, b) <- result.try(decode_tuple2(value))\n    case decode1(a), decode2(b) {\n      Ok(a), Ok(b) -> Ok(#(a, b))\n      a, b ->\n        tuple_errors(a, \"0\")\n        |> list.append(tuple_errors(b, \"1\"))\n        |> Error\n    }\n  }\n}\n\n/// Checks to see if a `Dynamic` value is a 3-element tuple, list or array containing\n/// specifically typed elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2, 3))\n/// > |> tuple3(int, int, int)\n/// Ok(#(1, 2, 3))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2.0, \"3\"))\n/// > |> tuple3(int, float, string)\n/// Ok(#(1, 2.0, \"3\"))\n/// ```\n///\n/// ```gleam\n/// > from([1, 2, 3])\n/// > |> tuple3(int, int, int)\n/// Ok(#(1, 2, 3))\n/// ```\n///\n/// ```gleam\n/// > from([from(1), from(2.0), from(\"3\")])\n/// > |> tuple3(int, float, string)\n/// Ok(#(1, 2.0, \"3\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2))\n/// > |> tuple3(int, float, string)\n/// Error([\n///   DecodeError(expected: \"Tuple of 3 elements\", found: \"Tuple of 2 elements\", path: [])),\n/// ])\n/// ```\n///\n/// ```gleam\n/// > from(\"\")\n/// > |> tuple3(int, float, string)\n/// Error([\n///   DecodeError(expected: \"Tuple of 3 elements\", found: \"String\", path: []),\n/// ])\n/// ```\n///\npub fn tuple3(\n  first decode1: Decoder(a),\n  second decode2: Decoder(b),\n  third decode3: Decoder(c),\n) -> Decoder(#(a, b, c)) {\n  fn(value) {\n    use #(a, b, c) <- result.try(decode_tuple3(value))\n    case decode1(a), decode2(b), decode3(c) {\n      Ok(a), Ok(b), Ok(c) -> Ok(#(a, b, c))\n      a, b, c ->\n        tuple_errors(a, \"0\")\n        |> list.append(tuple_errors(b, \"1\"))\n        |> list.append(tuple_errors(c, \"2\"))\n        |> Error\n    }\n  }\n}\n\n/// Checks to see if a `Dynamic` value is a 4-element tuple, list or array containing\n/// specifically typed elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2, 3, 4))\n/// > |> tuple4(int, int, int, int)\n/// Ok(#(1, 2, 3, 4))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2.0, \"3\", 4))\n/// > |> tuple4(int, float, string, int)\n/// Ok(#(1, 2.0, \"3\", 4))\n///\n/// ```gleam\n/// > from([1, 2, 3, 4])\n/// > |> tuple4(int, int, int, int)\n/// Ok(#(1, 2, 3, 4))\n/// ```\n///\n/// ```gleam\n/// > from([from(1), from(2.0), from(\"3\"), from(4)])\n/// > |> tuple4(int, float, string, int)\n/// Ok(#(1, 2.0, \"3\", 4))\n/// ```\n///\n/// > from(#(1, 2))\n/// > |> tuple4(int, float, string, int)\n/// Error([\n///   DecodeError(expected: \"Tuple of 4 elements\", found: \"Tuple of 2 elements\", path: []),\n/// ])\n/// ```\n///\n/// ```gleam\n/// > from(\"\")\n/// > |> tuple4(int, float, string, int)\n/// Error([\n///   DecodeError(expected: \"Tuple of 4 elements\", found: \"String\", path: []),\n/// ])\n/// ```\n///\npub fn tuple4(\n  first decode1: Decoder(a),\n  second decode2: Decoder(b),\n  third decode3: Decoder(c),\n  fourth decode4: Decoder(d),\n) -> Decoder(#(a, b, c, d)) {\n  fn(value) {\n    use #(a, b, c, d) <- result.try(decode_tuple4(value))\n    case decode1(a), decode2(b), decode3(c), decode4(d) {\n      Ok(a), Ok(b), Ok(c), Ok(d) -> Ok(#(a, b, c, d))\n      a, b, c, d ->\n        tuple_errors(a, \"0\")\n        |> list.append(tuple_errors(b, \"1\"))\n        |> list.append(tuple_errors(c, \"2\"))\n        |> list.append(tuple_errors(d, \"3\"))\n        |> Error\n    }\n  }\n}\n\n/// Checks to see if a `Dynamic` value is a 5-element tuple, list or array containing\n/// specifically typed elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2, 3, 4, 5))\n/// > |> tuple5(int, int, int, int, int)\n/// Ok(#(1, 2, 3, 4, 5))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2.0, \"3\", 4, 5))\n/// > |> tuple5(int, float, string, int, int)\n/// Ok(#(1, 2.0, \"3\", 4, 5))\n/// ```\n///\n/// ```gleam\n/// > from([1, 2, 3, 4, 5])\n/// > |> tuple5(int, int, int, int, int)\n/// Ok(#(1, 2, 3, 4, 5))\n/// ```\n///\n/// ```gleam\n/// > from([from(1), from(2.0), from(\"3\"), from(4), from(True)])\n/// > |> tuple5(int, float, string, int, bool)\n/// Ok(#(1, 2.0, \"3\", 4, True))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2))\n/// > |> tuple5(int, float, string, int, int)\n/// Error([\n///   DecodeError(expected: \"Tuple of 5 elements\", found: \"Tuple of 2 elements\", path: [])),\n/// ])\n///\n/// > from(\"\")\n/// > |> tuple5(int, float, string, int, int)\n/// Error([DecodeError(expected: \"Tuple of 5 elements\", found: \"String\", path: [])])\n/// ```\n///\npub fn tuple5(\n  first decode1: Decoder(a),\n  second decode2: Decoder(b),\n  third decode3: Decoder(c),\n  fourth decode4: Decoder(d),\n  fifth decode5: Decoder(e),\n) -> Decoder(#(a, b, c, d, e)) {\n  fn(value) {\n    use #(a, b, c, d, e) <- result.try(decode_tuple5(value))\n    case decode1(a), decode2(b), decode3(c), decode4(d), decode5(e) {\n      Ok(a), Ok(b), Ok(c), Ok(d), Ok(e) -> Ok(#(a, b, c, d, e))\n      a, b, c, d, e ->\n        tuple_errors(a, \"0\")\n        |> list.append(tuple_errors(b, \"1\"))\n        |> list.append(tuple_errors(c, \"2\"))\n        |> list.append(tuple_errors(d, \"3\"))\n        |> list.append(tuple_errors(e, \"4\"))\n        |> Error\n    }\n  }\n}\n\n/// Checks to see if a `Dynamic` value is a 6-element tuple, list or array containing\n/// specifically typed elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2, 3, 4, 5, 6))\n/// > |> tuple6(int, int, int, int, int, int)\n/// Ok(#(1, 2, 3, 4, 5, 6))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2.0, \"3\", 4, 5, 6))\n/// > |> tuple6(int, float, string, int, int)\n/// Ok(#(1, 2.0, \"3\", 4, 5, 6))\n/// ```\n///\n/// ```gleam\n/// > from([1, 2, 3, 4, 5, 6])\n/// > |> tuple6(int, int, int, int, int, int)\n/// Ok(#(1, 2, 3, 4, 5, 6))\n/// ```\n///\n/// ```gleam\n/// > from([from(1), from(2.0), from(\"3\"), from(4), from(True), from(False)])\n/// > |> tuple6(int, float, string, int, bool, bool)\n/// Ok(#(1, 2.0, \"3\", 4, True, False))\n/// ```\n///\n/// ```gleam\n/// > from(#(1, 2))\n/// > |> tuple6(int, float, string, int, int, int)\n/// Error([\n///   DecodeError(expected: \"Tuple of 6 elements\", found: \"Tuple of 2 elements\", path: []),\n/// ])\n/// ```\n///\n/// ```gleam\n/// > from(\"\")\n/// > |> tuple6(int, float, string, int, int, int)\n/// Error([DecodeError(expected: \"Tuple of 6 elements\", found: \"String\", path: [])])\n/// ```\n///\npub fn tuple6(\n  first decode1: Decoder(a),\n  second decode2: Decoder(b),\n  third decode3: Decoder(c),\n  fourth decode4: Decoder(d),\n  fifth decode5: Decoder(e),\n  sixth decode6: Decoder(f),\n) -> Decoder(#(a, b, c, d, e, f)) {\n  fn(value) {\n    use #(a, b, c, d, e, f) <- result.try(decode_tuple6(value))\n    case\n      decode1(a),\n      decode2(b),\n      decode3(c),\n      decode4(d),\n      decode5(e),\n      decode6(f)\n    {\n      Ok(a), Ok(b), Ok(c), Ok(d), Ok(e), Ok(f) -> Ok(#(a, b, c, d, e, f))\n      a, b, c, d, e, f ->\n        tuple_errors(a, \"0\")\n        |> list.append(tuple_errors(b, \"1\"))\n        |> list.append(tuple_errors(c, \"2\"))\n        |> list.append(tuple_errors(d, \"3\"))\n        |> list.append(tuple_errors(e, \"4\"))\n        |> list.append(tuple_errors(f, \"5\"))\n        |> Error\n    }\n  }\n}\n\n/// Checks to see if a `Dynamic` value is a map.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/map\n/// > map.new() |> from |> map(string, int)\n/// Ok(map.new())\n/// ```\n///\n/// ```gleam\n/// > from(1) |> map(string, int)\n/// Error(DecodeError(expected: \"Map\", found: \"Int\", path: []))\n/// ```\n///\n/// ```gleam\n/// > from(\"\") |> map(string, int)\n/// Error(DecodeError(expected: \"Map\", found: \"String\", path: []))\n/// ```\n///\npub fn map(\n  of key_type: Decoder(k),\n  to value_type: Decoder(v),\n) -> Decoder(Map(k, v)) {\n  fn(value) {\n    use map <- result.try(decode_map(value))\n    use pairs <- result.try(\n      map\n      |> map.to_list\n      |> list.try_map(fn(pair) {\n        let #(k, v) = pair\n        use k <- result.try(\n          key_type(k)\n          |> map_errors(push_path(_, \"keys\")),\n        )\n        use v <- result.try(\n          value_type(v)\n          |> map_errors(push_path(_, \"values\")),\n        )\n        Ok(#(k, v))\n      }),\n    )\n    Ok(map.from_list(pairs))\n  }\n}\n\nif erlang {\n  external fn decode_map(Dynamic) -> Result(Map(Dynamic, Dynamic), DecodeErrors) =\n    \"gleam_stdlib\" \"decode_map\"\n}\n\nif javascript {\n  external fn decode_map(Dynamic) -> Result(Map(Dynamic, Dynamic), DecodeErrors) =\n    \"../gleam_stdlib.mjs\" \"decode_map\"\n}\n\n/// Joins multiple decoders into one. When run they will each be tried in turn\n/// until one succeeds, or they all fail.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > import gleam/result\n/// > let bool_or_string = any(of: [\n/// >   string,\n/// >   fn(x) { result.map(bool(x), fn(_) { \"a bool\" }) }\n/// > ])\n/// > bool_or_string(from(\"ok\"))\n/// Ok(\"ok\")\n/// ```\n///\n/// ```gleam\n/// > bool_or_string(from(True))\n/// Ok(\"a bool\")\n/// ```\n///\n/// ```gleam\n/// > bool_or_string(from(1))\n/// Error(DecodeError(expected: \"another type\", found: \"Int\", path: []))\n/// ```\n///\npub fn any(of decoders: List(Decoder(t))) -> Decoder(t) {\n  fn(data) {\n    case decoders {\n      [] ->\n        Error([\n          DecodeError(found: classify(data), expected: \"another type\", path: []),\n        ])\n\n      [decoder, ..decoders] ->\n        case decoder(data) {\n          Ok(decoded) -> Ok(decoded)\n          Error(_) -> any(decoders)(data)\n        }\n    }\n  }\n}\n\n/// Decode 1 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.0, \"3\"))\n/// > |> decode1(MyRecord, element(0, int))\n/// Ok(MyRecord(1))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\"))\n/// > |> decode1(MyRecord, element(0, int))\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n/// ])\n/// ```\n///\npub fn decode1(constructor: fn(t1) -> t, t1: Decoder(t1)) -> Decoder(t) {\n  fn(value) {\n    case t1(value) {\n      Ok(a) -> Ok(constructor(a))\n      a -> Error(all_errors(a))\n    }\n  }\n}\n\n/// Decode 2 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.0, \"3\"))\n/// > |> decode2(MyRecord, element(0, int), element(1, float))\n/// Ok(MyRecord(1, 2.0))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\"))\n/// > |> decode2(MyRecord, element(0, int), element(1, float))\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode2(\n  constructor: fn(t1, t2) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n) -> Decoder(t) {\n  fn(value) {\n    case t1(value), t2(value) {\n      Ok(a), Ok(b) -> Ok(constructor(a, b))\n      a, b -> Error(list.flatten([all_errors(a), all_errors(b)]))\n    }\n  }\n}\n\n/// Decode 3 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.0, \"3\"))\n/// > |> decode3(MyRecord, element(0, int), element(1, float), element(2, string))\n/// Ok(MyRecord(1, 2.0, \"3\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\"))\n/// > |> decode3(MyRecord, element(0, int), element(1, float), element(2, string))\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode3(\n  constructor: fn(t1, t2, t3) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n  t3: Decoder(t3),\n) -> Decoder(t) {\n  fn(value) {\n    case t1(value), t2(value), t3(value) {\n      Ok(a), Ok(b), Ok(c) -> Ok(constructor(a, b, c))\n      a, b, c ->\n        Error(list.flatten([all_errors(a), all_errors(b), all_errors(c)]))\n    }\n  }\n}\n\n/// Decode 4 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.1, \"3\", \"4\"))\n/// > |> decode4(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// > )\n/// Ok(MyRecord(1, 2.1, \"3\", \"4\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\", \"\"))\n/// > |> decode4(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// > )\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode4(\n  constructor: fn(t1, t2, t3, t4) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n  t3: Decoder(t3),\n  t4: Decoder(t4),\n) -> Decoder(t) {\n  fn(x: Dynamic) {\n    case t1(x), t2(x), t3(x), t4(x) {\n      Ok(a), Ok(b), Ok(c), Ok(d) -> Ok(constructor(a, b, c, d))\n      a, b, c, d ->\n        Error(list.flatten([\n          all_errors(a),\n          all_errors(b),\n          all_errors(c),\n          all_errors(d),\n        ]))\n    }\n  }\n}\n\n/// Decode 5 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.1, \"3\", \"4\", \"5\"))\n/// > |> decode5(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// > )\n/// Ok(MyRecord(1, 2.1, \"3\", \"4\", \"5\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\", \"\", \"\"))\n/// > |> decode5(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// > )\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode5(\n  constructor: fn(t1, t2, t3, t4, t5) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n  t3: Decoder(t3),\n  t4: Decoder(t4),\n  t5: Decoder(t5),\n) -> Decoder(t) {\n  fn(x: Dynamic) {\n    case t1(x), t2(x), t3(x), t4(x), t5(x) {\n      Ok(a), Ok(b), Ok(c), Ok(d), Ok(e) -> Ok(constructor(a, b, c, d, e))\n      a, b, c, d, e ->\n        Error(list.flatten([\n          all_errors(a),\n          all_errors(b),\n          all_errors(c),\n          all_errors(d),\n          all_errors(e),\n        ]))\n    }\n  }\n}\n\n/// Decode 6 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.1, \"3\", \"4\", \"5\", \"6\"))\n/// > |> decode6(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// > )\n/// Ok(MyRecord(1, 2.1, \"3\", \"4\", \"5\", \"6\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\", \"\", \"\", \"\"))\n/// > |> decode6(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// > )\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode6(\n  constructor: fn(t1, t2, t3, t4, t5, t6) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n  t3: Decoder(t3),\n  t4: Decoder(t4),\n  t5: Decoder(t5),\n  t6: Decoder(t6),\n) -> Decoder(t) {\n  fn(x: Dynamic) {\n    case t1(x), t2(x), t3(x), t4(x), t5(x), t6(x) {\n      Ok(a), Ok(b), Ok(c), Ok(d), Ok(e), Ok(f) ->\n        Ok(constructor(a, b, c, d, e, f))\n      a, b, c, d, e, f ->\n        Error(list.flatten([\n          all_errors(a),\n          all_errors(b),\n          all_errors(c),\n          all_errors(d),\n          all_errors(e),\n          all_errors(f),\n        ]))\n    }\n  }\n}\n\n/// Decode 7 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.1, \"3\", \"4\", \"5\", \"6\"))\n/// > |> decode7(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// >   element(6, string),\n/// > )\n/// Ok(MyRecord(1, 2.1, \"3\", \"4\", \"5\", \"6\", \"7\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\", \"\", \"\", \"\", \"\"))\n/// > |> decode7(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// >   element(6, string),\n/// > )\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode7(\n  constructor: fn(t1, t2, t3, t4, t5, t6, t7) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n  t3: Decoder(t3),\n  t4: Decoder(t4),\n  t5: Decoder(t5),\n  t6: Decoder(t6),\n  t7: Decoder(t7),\n) -> Decoder(t) {\n  fn(x: Dynamic) {\n    case t1(x), t2(x), t3(x), t4(x), t5(x), t6(x), t7(x) {\n      Ok(a), Ok(b), Ok(c), Ok(d), Ok(e), Ok(f), Ok(g) ->\n        Ok(constructor(a, b, c, d, e, f, g))\n      a, b, c, d, e, f, g ->\n        Error(list.flatten([\n          all_errors(a),\n          all_errors(b),\n          all_errors(c),\n          all_errors(d),\n          all_errors(e),\n          all_errors(f),\n          all_errors(g),\n        ]))\n    }\n  }\n}\n\n/// Decode 8 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.1, \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"))\n/// > |> decode8(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// >   element(6, string),\n/// >   element(7, string),\n/// > )\n/// Ok(MyRecord(1, 2.1, \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"))\n/// > |> decode8(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// >   element(6, string),\n/// >   element(7, string),\n/// > )\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode8(\n  constructor: fn(t1, t2, t3, t4, t5, t6, t7, t8) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n  t3: Decoder(t3),\n  t4: Decoder(t4),\n  t5: Decoder(t5),\n  t6: Decoder(t6),\n  t7: Decoder(t7),\n  t8: Decoder(t8),\n) -> Decoder(t) {\n  fn(x: Dynamic) {\n    case t1(x), t2(x), t3(x), t4(x), t5(x), t6(x), t7(x), t8(x) {\n      Ok(a), Ok(b), Ok(c), Ok(d), Ok(e), Ok(f), Ok(g), Ok(h) ->\n        Ok(constructor(a, b, c, d, e, f, g, h))\n      a, b, c, d, e, f, g, h ->\n        Error(list.flatten([\n          all_errors(a),\n          all_errors(b),\n          all_errors(c),\n          all_errors(d),\n          all_errors(e),\n          all_errors(f),\n          all_errors(g),\n          all_errors(h),\n        ]))\n    }\n  }\n}\n\n/// Decode 9 values from a `Dynamic` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// > from(#(1, 2.1, \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"))\n/// > |> decode9(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// >   element(6, string),\n/// >   element(7, string),\n/// >   element(8, string),\n/// > )\n/// Ok(MyRecord(1, 2.1, \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"))\n/// ```\n///\n/// ```gleam\n/// > from(#(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"))\n/// > |> decode9(\n/// >   MyRecord,\n/// >   element(0, int),\n/// >   element(1, float),\n/// >   element(2, string),\n/// >   element(3, string),\n/// >   element(4, string),\n/// >   element(5, string),\n/// >   element(6, string),\n/// >   element(7, string),\n/// >   element(8, string),\n/// > )\n/// Error([\n///   DecodeError(expected: \"Int\", found: \"String\", path: [\"0\"]),\n///   DecodeError(expected: \"Float\", found: \"String\", path: [\"1\"]),\n/// ])\n/// ```\n///\npub fn decode9(\n  constructor: fn(t1, t2, t3, t4, t5, t6, t7, t8, t9) -> t,\n  t1: Decoder(t1),\n  t2: Decoder(t2),\n  t3: Decoder(t3),\n  t4: Decoder(t4),\n  t5: Decoder(t5),\n  t6: Decoder(t6),\n  t7: Decoder(t7),\n  t8: Decoder(t8),\n  t9: Decoder(t9),\n) -> Decoder(t) {\n  fn(x: Dynamic) {\n    case t1(x), t2(x), t3(x), t4(x), t5(x), t6(x), t7(x), t8(x), t9(x) {\n      Ok(a), Ok(b), Ok(c), Ok(d), Ok(e), Ok(f), Ok(g), Ok(h), Ok(i) ->\n        Ok(constructor(a, b, c, d, e, f, g, h, i))\n      a, b, c, d, e, f, g, h, i ->\n        Error(list.flatten([\n          all_errors(a),\n          all_errors(b),\n          all_errors(c),\n          all_errors(d),\n          all_errors(e),\n          all_errors(f),\n          all_errors(g),\n          all_errors(h),\n          all_errors(i),\n        ]))\n    }\n  }\n}\n\nfn all_errors(result: Result(a, List(DecodeError))) -> List(DecodeError) {\n  case result {\n    Ok(_) -> []\n    Error(errors) -> errors\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.272661Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.272669Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R144    
2023-08-04T09:30:46.272678Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(48)) = "//// A module for testing your Gleam code. The functions found here are\n//// compatible with the Erlang eunit test framework.\n////\n//// More information on running eunit can be found in [the rebar3\n//// documentation](https://rebar3.org/docs/testing/eunit/).\n\nif erlang {\n  pub external fn equal(a, a) -> Nil =\n    \"gleeunit_ffi\" \"should_equal\"\n\n  pub external fn not_equal(a, a) -> Nil =\n    \"gleeunit_ffi\" \"should_not_equal\"\n\n  pub external fn be_ok(Result(a, b)) -> a =\n    \"gleeunit_ffi\" \"should_be_ok\"\n\n  pub external fn be_error(Result(a, b)) -> b =\n    \"gleeunit_ffi\" \"should_be_error\"\n}\n\nif javascript {\n  import gleam/string\n\n  external fn stringify(anything) -> String =\n    \"../gleam.mjs\" \"inspect\"\n\n  external fn crash(String) -> anything =\n    \"../gleeunit_ffi.mjs\" \"crash\"\n\n  pub fn equal(a, b) {\n    case a == b {\n      True -> Nil\n      _ ->\n        crash(string.concat([\n          \"\\n\\t\",\n          stringify(a),\n          \"\\n\\tshould equal \\n\\t\",\n          stringify(b),\n        ]))\n    }\n  }\n\n  pub fn not_equal(a, b) {\n    case a != b {\n      True -> Nil\n      _ ->\n        crash(string.concat([\n          \"\\n\",\n          stringify(a),\n          \"\\nshould not equal \\n\",\n          stringify(b),\n        ]))\n    }\n  }\n\n  pub fn be_ok(a) {\n    case a {\n      Ok(value) -> value\n      _ -> crash(string.concat([\"\\n\", stringify(a), \"\\nshould be ok\"]))\n    }\n  }\n\n  pub fn be_error(a) {\n    case a {\n      Error(error) -> error\n      _ -> crash(string.concat([\"\\n\", stringify(a), \"\\nshould be error\"]))\n    }\n  }\n}\n\npub fn be_true(actual: Bool) -> Nil {\n  actual\n  |> equal(True)\n}\n\npub fn be_false(actual: Bool) -> Nil {\n  actual\n  |> equal(False)\n}\n\npub fn fail() -> Nil {\n  be_true(False)\n}\n" (Durability(0))    
2023-08-04T09:30:46.272716Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.272724Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R145    
2023-08-04T09:30:46.272733Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(49)) = "/// Find and run all test functions for the current project using Erlang's EUnit\n/// test framework.\n///\n/// Any Erlang or Gleam function in the `test` directory with a name editing in\n/// `_test` is considered a test function and will be run.\n///\n/// If running on JavaScript tests will be run with a custom test runner.\n///\npub fn main() -> Nil {\n  do_main()\n}\n\nif javascript {\n  external fn do_main() -> Nil =\n    \"./gleeunit_ffi.mjs\" \"main\"\n}\n\nif erlang {\n  import gleam/list\n  import gleam/result\n  import gleam/string\n  import gleam/dynamic.{Dynamic}\n\n  fn do_main() -> Nil {\n    let options = [Verbose, NoTty, Report(#(GleeunitProgress, [Colored(True)]))]\n\n    let result =\n      find_files(matching: \"**/*.{erl,gleam}\", in: \"test\")\n      |> list.map(gleam_to_erlang_module_name)\n      |> list.map(dangerously_convert_string_to_atom(_, Utf8))\n      |> run_eunit(options)\n      |> dynamic.result(dynamic.dynamic, dynamic.dynamic)\n      |> result.unwrap(Error(dynamic.from(Nil)))\n\n    let code = case result {\n      Ok(_) -> 0\n      Error(_) -> 1\n    }\n    halt(code)\n  }\n\n  external fn halt(Int) -> Nil =\n    \"erlang\" \"halt\"\n\n  fn gleam_to_erlang_module_name(path: String) -> String {\n    path\n    |> string.replace(\".gleam\", \"\")\n    |> string.replace(\".erl\", \"\")\n    |> string.replace(\"/\", \"@\")\n  }\n\n  external fn find_files(matching: String, in: String) -> List(String) =\n    \"gleeunit_ffi\" \"find_files\"\n\n  external type Atom\n\n  type Encoding {\n    Utf8\n  }\n\n  external fn dangerously_convert_string_to_atom(String, Encoding) -> Atom =\n    \"erlang\" \"binary_to_atom\"\n\n  type ReportModuleName {\n    GleeunitProgress\n  }\n\n  type GleeunitProgressOption {\n    Colored(Bool)\n  }\n\n  type EunitOption {\n    Verbose\n    NoTty\n    Report(#(ReportModuleName, List(GleeunitProgressOption)))\n  }\n\n  external fn run_eunit(List(Atom), List(EunitOption)) -> Dynamic =\n    \"eunit\" \"test\"\n}\n" (Durability(0))    
2023-08-04T09:30:46.272763Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.272780Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R146    
2023-08-04T09:30:46.272789Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(50)) = "import gleam/int\nimport gleam/string\nimport gleam/list\nimport gleam/map.{Map}\nimport gleam/result\nimport gleam/crypto\nimport gleam/option.{None, Option, Some}\nimport gleam/uri\nimport gleam/bit_builder\nimport gleam/otp/actor\nimport gleam/erlang/process.{Selector, Subject}\nimport gleam/http.{Get}\nimport gleam/http/request.{Request}\nimport gleam/http/response\nimport mist.{Body}\nimport mist/websocket\nimport mist/internal/websocket.{TextMessage} as iwebsocket\nimport glisten\nimport glisten/handler.{HandlerMessage}\nimport nakai\nimport nakai/html\nimport nakai/html/attrs\n\nconst sess_id_prefix = \"gliew-\"\n\nconst csrf_prefix = \"g-\"\n\nconst elem_id_prefix = \"g-\"\n\n// Event is a special type that can be added to attributes\n// in HTML tree elements.\n// That way we can just return a HTML tree of `html.Node(Event)`\n// and later walk the tree to extract various data from it.\n//\npub opaque type Event {\n  // Instructs that the HTML node is the root of a mount\n  // and contains the selector function for the worker\n  // to know how to process updates.\n  Mount(selecting: fn(Selector(WorkerMessage)) -> Selector(WorkerMessage))\n}\n\n/// Creates a HTML node tree that will be `mounted`\n/// and receive live updates with data on `Subject(a)`\n/// returned by the mount function.\n///\npub fn mount(\n  mount mount: fn(b) -> Subject(a),\n  with context: b,\n  render render: fn(Option(a)) -> html.Node(Event),\n) {\n  // Render initial node tree\n  let tree =\n    render(None)\n    |> process_tree(None)\n\n  // Get id from root element\n  let id = extract_id(tree)\n\n  // Add mount event to root of tree\n  fn(selector: Selector(WorkerMessage)) {\n    // Mount component to get subject\n    let subject = mount(context)\n\n    // Select and map subject\n    selector\n    |> process.selecting(\n      subject,\n      fn(val) {\n        render(Some(val))\n        |> process_tree(Some(id))\n        |> nakai.to_inline_string\n        |> LiveUpdate\n      },\n    )\n  }\n  |> Mount\n  |> insert_event(tree)\n}\n\n// Insert the event to the node.\n//\nfn insert_event(event: Event, node: html.Node(Event)) {\n  case node {\n    html.Element(tag, attrs, children) ->\n      attrs\n      |> list.prepend(attrs.Event(\"gliew-event\", event))\n      |> html.Element(tag, _, children)\n    html.LeafElement(tag, attrs) ->\n      attrs\n      |> list.prepend(attrs.Event(\"gliew-event\", event))\n      |> html.LeafElement(tag, _)\n    other -> other\n  }\n}\n\n// Adds the id attribute to the node if provided, otherwise\n// generates it.\n//\nfn process_tree(node: html.Node(Event), id: Option(String)) {\n  case node {\n    html.Element(tag, attrs, children) ->\n      attrs\n      |> ensure_id(id)\n      |> html.Element(tag, _, children)\n    html.LeafElement(tag, attrs) ->\n      attrs\n      |> ensure_id(id)\n      |> html.LeafElement(tag, _)\n    other -> other\n  }\n}\n\n// Make sure there is an id attribute in the list of attributes.\n// If id is `None` it will generate one if there isn't one.\n// If id is `Some(id)` it will replace any id if there is one or\n// otherwise add it.\n//\nfn ensure_id(attrs: List(attrs.Attr(Event)), id: Option(String)) {\n  case has_id(attrs) {\n    True ->\n      case id {\n        Some(id) ->\n          list.map(\n            attrs,\n            fn(attr) {\n              case attr {\n                attrs.Attr(\"id\", _) -> attrs.id(id)\n                other -> other\n              }\n            },\n          )\n        None -> attrs\n      }\n    False ->\n      attrs\n      |> list.prepend(attrs.id(\n        id\n        |> option.unwrap(random_id()),\n      ))\n  }\n}\n\n// Extract the ID value from a HTML node.\n//\nfn extract_id(node: html.Node(Event)) {\n  case node {\n    html.Element(_, attrs, _) -> find_id(attrs)\n    html.LeafElement(_, attrs) -> find_id(attrs)\n    _ -> Error(Nil)\n  }\n  |> result.unwrap(random_id())\n}\n\n// Find id attribute in a list of attrs.\n//\nfn find_id(attrs: List(attrs.Attr(Event))) {\n  attrs\n  |> list.find_map(fn(attr) {\n    case attr {\n      attrs.Attr(\"id\", id) -> Ok(id)\n      _ -> Error(Nil)\n    }\n  })\n}\n\n// Generates a random ID for a HTML id attribute.\n//\nfn random_id() {\n  elem_id_prefix <> random_string(3)\n}\n\n// Check if list of attrs has id.\n//\nfn has_id(attrs: List(attrs.Attr(a))) {\n  attrs\n  |> list.any(fn(a) {\n    case a {\n      attrs.Attr(\"id\", _) -> True\n      _ -> False\n    }\n  })\n}\n\n// Manager -----------------------------------------------\n\ntype LoopState {\n  LoopState(sessions: Map(String, Session))\n}\n\ntype Session {\n  Session(\n    id: String,\n    csrf: String,\n    selects: List(fn(Selector(WorkerMessage)) -> Selector(WorkerMessage)),\n    tree: html.Node(Event),\n  )\n}\n\ntype Message {\n  RenderTree(\n    from: Subject(String),\n    request: Request(Body),\n    tree: html.Node(Event),\n  )\n  CheckConnect(from: Subject(Bool), id: String, csrf: String)\n  DoConnect(id: String, socket: Subject(HandlerMessage))\n}\n\nfn start_manager() {\n  actor.start(LoopState(sessions: map.new()), loop)\n}\n\nfn loop(message: Message, state: LoopState) -> actor.Next(LoopState) {\n  case message {\n    // Render tree\n    RenderTree(from, _, tree) ->\n      case extract_selects([], tree) {\n        // Regular static view\n        [] -> {\n          process.send(\n            from,\n            tree\n            |> nakai.to_inline_string,\n          )\n\n          actor.Continue(state)\n        }\n        selects -> {\n          // Create a session ID\n          let sess_id = sess_id_prefix <> random_string(10)\n          // Create a CSRF token\n          let csrf = csrf_prefix <> random_string(24)\n\n          process.send(\n            from,\n            tree\n            |> nakai.to_inline_string\n            |> wrap_live_view(sess_id, csrf),\n          )\n\n          actor.Continue(LoopState(\n            sessions: state.sessions\n            |> map.insert(sess_id, Session(sess_id, csrf, selects, tree)),\n          ))\n        }\n      }\n\n    // Check if session is active\n    CheckConnect(from, id, csrf) -> {\n      case\n        state.sessions\n        |> map.get(id)\n      {\n        Ok(sess) -> process.send(from, sess.csrf == csrf)\n        Error(Nil) -> process.send(from, False)\n      }\n      actor.Continue(state)\n    }\n\n    // Start a connection worker\n    DoConnect(id, socket) -> {\n      // TODO: handle gracefully\n      case\n        state.sessions\n        |> map.get(id)\n      {\n        Ok(sess) -> {\n          let _ = start_worker(socket, sess.selects, sess.tree)\n          Nil\n        }\n        Error(Nil) -> Nil\n      }\n\n      actor.Continue(state)\n    }\n  }\n}\n\n// Walks the node tree until it finds a `Mount` event and adds\n// its select function to the list of of all select functions\n// in the tree.\n//\nfn extract_selects(\n  selects: List(fn(Selector(WorkerMessage)) -> Selector(WorkerMessage)),\n  node: html.Node(Event),\n) {\n  case node {\n    html.Element(_, attrs, children) ->\n      case extract_event(attrs) {\n        Ok(Mount(selector)) ->\n          selects\n          |> list.prepend(selector)\n        Error(Nil) ->\n          children\n          |> list.fold(selects, extract_selects)\n      }\n    html.LeafElement(_, attrs) ->\n      case extract_event(attrs) {\n        Ok(Mount(selector)) ->\n          selects\n          |> list.prepend(selector)\n        Error(Nil) -> selects\n      }\n    _ -> selects\n  }\n}\n\n// Extract a single gliew event attribute.\n//\nfn extract_event(attrs: List(attrs.Attr(Event))) {\n  attrs\n  |> list.find_map(fn(attr) {\n    case attr {\n      attrs.Event(\"gliew-event\", event) -> Ok(event)\n      _ -> Error(Nil)\n    }\n  })\n}\n\n// Wrap a container around a node tree containing any\n// live mounts inside.\n// This instructs htmx to make a websocket connection back\n// to the server.\n//\nfn wrap_live_view(markup: String, session_id: String, csrf: String) {\n  html.div(\n    [\n      attrs.Attr(\"hx-ext\", \"ws\"),\n      attrs.Attr(\n        \"ws-connect\",\n        \"/connect?session=\" <> session_id <> \"&csrf=\" <> csrf,\n      ),\n      attrs.Attr(\"hx-ext\", \"morph\"),\n    ],\n    [html.UnsafeText(markup)],\n  )\n  |> nakai.to_string\n}\n\nfn render_tree(\n  subject: Subject(Message),\n  request: Request(Body),\n  tree: html.Node(Event),\n) {\n  process.call(subject, RenderTree(_, request, tree), 1000)\n}\n\nfn check_connect(subject: Subject(Message), id: String, csrf: String) {\n  process.call(subject, CheckConnect(_, id, csrf), 1000)\n}\n\nfn do_connect(\n  subject: Subject(Message),\n  id: String,\n  socket: Subject(HandlerMessage),\n) {\n  process.send(subject, DoConnect(id, socket))\n}\n\nfn to_hex_string(bstr: BitString) {\n  case bstr {\n    <<>> -> \"\"\n    <<a:8, rest:bit_string>> -> {\n      int.to_base16(a)\n      |> string.lowercase <> to_hex_string(rest)\n    }\n  }\n}\n\nfn random_string(len: Int) {\n  crypto.strong_random_bytes(len)\n  |> to_hex_string\n}\n\n// Worker ------------------------------------------------\n\ntype WorkerState {\n  WorkerState(socket: Subject(HandlerMessage), tree: html.Node(Event))\n}\n\ntype WorkerMessage {\n  LiveUpdate(markup: String)\n}\n\nfn start_worker(\n  socket: Subject(HandlerMessage),\n  selects: List(fn(Selector(WorkerMessage)) -> Selector(WorkerMessage)),\n  tree: html.Node(Event),\n) {\n  actor.start_spec(actor.Spec(\n    init: fn() {\n      let selector =\n        process.new_selector()\n        |> apply_selects(selects)\n\n      actor.Ready(WorkerState(socket, tree), selector)\n    },\n    init_timeout: 1000,\n    loop: worker_loop,\n  ))\n}\n\nfn worker_loop(msg: WorkerMessage, state: WorkerState) {\n  case msg {\n    LiveUpdate(markup) -> {\n      // Send updated markup to websocket\n      websocket.send(state.socket, TextMessage(markup))\n\n      actor.Continue(state)\n    }\n  }\n}\n\nfn apply_selects(\n  selector: Selector(WorkerMessage),\n  selects: List(fn(Selector(WorkerMessage)) -> Selector(WorkerMessage)),\n) {\n  selector\n  |> list.fold(selects, _, fn(selector, selecting) { selecting(selector) })\n}\n\n// Server ------------------------------------------------\n\npub fn serve(port: Int, handler: fn(Request(Body)) -> html.Node(Event)) {\n  use manager <- result.try(\n    start_manager()\n    |> result.map_error(fn(err) {\n      case err {\n        actor.InitTimeout -> glisten.AcceptorTimeout\n        actor.InitFailed(reason) -> glisten.AcceptorFailed(reason)\n        actor.InitCrashed(any) -> glisten.AcceptorCrashed(any)\n      }\n    }),\n  )\n\n  mist.serve(port, handler_func(manager, handler))\n}\n\nfn handler_func(\n  manager: Subject(Message),\n  handler: fn(Request(Body)) -> html.Node(Event),\n) {\n  // Return actual handler func\n  fn(req: Request(Body)) {\n    case req.method, req.path {\n      Get, \"/connect\" -> handle_ws_connect(manager, req)\n      _, _ -> {\n        let view = handler(req)\n\n        let body =\n          html.Html(\n            [],\n            [\n              html.Head([\n                html.Element(\n                  tag: \"script\",\n                  attrs: [\n                    attrs.src(\n                      \"https://unpkg.com/htmx.org@1.9.2/dist/htmx.min.js\",\n                    ),\n                  ],\n                  children: [],\n                ),\n                html.Element(\n                  tag: \"script\",\n                  attrs: [\n                    attrs.src(\"https://unpkg.com/htmx.org@1.9.2/dist/ext/ws.js\"),\n                  ],\n                  children: [],\n                ),\n                html.Element(\n                  tag: \"script\",\n                  attrs: [\n                    attrs.src(\n                      \"https://unpkg.com/idiomorph@0.0.8/dist/idiomorph-ext.min.js\",\n                    ),\n                  ],\n                  children: [],\n                ),\n              ]),\n              html.Body(\n                attrs: [],\n                children: [html.UnsafeText(render_tree(manager, req, view))],\n              ),\n            ],\n          )\n          |> nakai.to_string\n\n        response.new(200)\n        |> mist.bit_builder_response(bit_builder.from_string(body))\n      }\n    }\n  }\n  |> mist.handler_func\n}\n\nfn handle_ws_connect(manager: Subject(Message), req: Request(Body)) {\n  case parse_params(req) {\n    Ok(#(id, csrf)) -> upgrade_connection(manager, id, csrf)\n    Error(Nil) ->\n      response.new(401)\n      |> mist.empty_response\n  }\n}\n\nfn upgrade_connection(manager: Subject(Message), session: String, csrf: String) {\n  case check_connect(manager, session, csrf) {\n    False ->\n      response.new(401)\n      |> mist.empty_response\n    True -> {\n      fn(_msg, _subject: Subject(HandlerMessage)) { Ok(Nil) }\n      |> websocket.with_handler\n      |> websocket.on_init(fn(subject: Subject(HandlerMessage)) {\n        do_connect(manager, session, subject)\n      })\n      |> mist.upgrade\n    }\n  }\n}\n\nfn parse_params(req: Request(Body)) {\n  case req.query {\n    Some(params) ->\n      case uri.parse_query(params) {\n        Ok(params) ->\n          list.map(\n            params,\n            fn(p) {\n              #(\n                p.0,\n                p.1\n                |> string.replace(\" \", \"+\"),\n              )\n            },\n          )\n          |> get_params\n        Error(Nil) -> Error(Nil)\n      }\n    None -> Error(Nil)\n  }\n}\n\nfn get_params(params: List(#(String, String))) {\n  let pmap = map.from_list(params)\n\n  use session <- result.then(map.get(pmap, \"session\"))\n  use csrf <- result.then(map.get(pmap, \"csrf\"))\n\n  Ok(#(session, csrf))\n}\n" (Durability(0))    
2023-08-04T09:30:46.272958Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.272967Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R147    
2023-08-04T09:30:46.272976Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(51)) = "import gleam/dynamic.{Dynamic}\nimport gleam/erlang/process\nimport gleam/result\nimport glisten/acceptor.{Pool, over_ssl}\nimport glisten/socket.{Closed, ListenSocket, SocketReason, Timeout}\nimport glisten/tcp\nimport glisten/ssl\nimport gleam/otp/actor\nimport glisten/socket/options.{Certfile, Keyfile}\n\n/// Reasons that `serve` might fail\npub type StartError {\n  ListenerClosed\n  ListenerTimeout\n  AcceptorTimeout\n  AcceptorFailed(process.ExitReason)\n  AcceptorCrashed(Dynamic)\n  SystemError(SocketReason)\n}\n\n/// Sets up a TCP listener with the given acceptor pool. The second argument\n/// can be obtained from the `glisten/acceptor.{acceptor_pool}` function.\npub fn serve(\n  port: Int,\n  with_pool: fn(ListenSocket) -> Pool(data),\n) -> Result(Nil, StartError) {\n  port\n  |> tcp.listen([])\n  |> result.map_error(fn(err) {\n    case err {\n      Closed -> ListenerClosed\n      Timeout -> ListenerTimeout\n      err -> SystemError(err)\n    }\n  })\n  |> result.then(fn(socket) {\n    socket\n    |> with_pool\n    |> acceptor.start_pool\n    |> result.map_error(fn(err) {\n      case err {\n        actor.InitTimeout -> AcceptorTimeout\n        actor.InitFailed(reason) -> AcceptorFailed(reason)\n        actor.InitCrashed(reason) -> AcceptorCrashed(reason)\n      }\n    })\n  })\n  |> result.replace(Nil)\n}\n\nexternal fn start_ssl() -> Result(Nil, Dynamic) =\n  \"ssl_ffi\" \"start_ssl\"\n\n/// Sets up a SSL listener with the given acceptor pool. The second argument\n/// can be obtained from the `glisten/acceptor.{acceptor_pool}` function.\npub fn serve_ssl(\n  port port: Int,\n  certfile certfile: String,\n  keyfile keyfile: String,\n  with_pool with_pool: fn(ListenSocket) -> Pool(data),\n) -> Result(Nil, StartError) {\n  let assert Ok(_nil) = start_ssl()\n  port\n  |> ssl.listen([Certfile(certfile), Keyfile(keyfile)])\n  |> result.map_error(fn(err) {\n    case err {\n      Closed -> ListenerClosed\n      Timeout -> ListenerTimeout\n      err -> SystemError(err)\n    }\n  })\n  |> result.then(fn(socket) {\n    socket\n    |> over_ssl(with_pool)\n    |> acceptor.start_pool\n    |> result.map_error(fn(err) {\n      case err {\n        actor.InitTimeout -> AcceptorTimeout\n        actor.InitFailed(reason) -> AcceptorFailed(reason)\n        actor.InitCrashed(reason) -> AcceptorCrashed(reason)\n      }\n    })\n  })\n  |> result.replace(Nil)\n}\n" (Durability(0))    
2023-08-04T09:30:46.273024Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273032Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R148    
2023-08-04T09:30:46.273041Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(52)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/dynamic.{Dynamic}\nimport gleam/erlang/atom.{Atom}\nimport gleam/erlang/process.{Pid}\nimport gleam/list\nimport gleam/map\nimport glisten/socket.{ListenSocket, Socket, SocketReason}\nimport glisten/socket/options\n\npub external fn controlling_process(\n  socket: Socket,\n  pid: Pid,\n) -> Result(Nil, Atom) =\n  \"ssl_ffi\" \"controlling_process\"\n\nexternal fn do_listen(\n  port: Int,\n  options: List(options.TcpOption),\n) -> Result(ListenSocket, SocketReason) =\n  \"ssl\" \"listen\"\n\npub external fn accept_timeout(\n  socket: ListenSocket,\n  timeout: Int,\n) -> Result(Socket, SocketReason) =\n  \"ssl\" \"transport_accept\"\n\npub external fn accept(socket: ListenSocket) -> Result(Socket, SocketReason) =\n  \"ssl\" \"transport_accept\"\n\npub external fn receive_timeout(\n  socket: Socket,\n  length: Int,\n  timeout: Int,\n) -> Result(BitString, SocketReason) =\n  \"ssl\" \"recv\"\n\npub external fn receive(\n  socket: Socket,\n  length: Int,\n) -> Result(BitString, SocketReason) =\n  \"ssl\" \"recv\"\n\npub external fn send(\n  socket: Socket,\n  packet: BitBuilder,\n) -> Result(Nil, SocketReason) =\n  \"ssl_ffi\" \"send\"\n\npub external fn close(socket: Socket) -> Result(Nil, SocketReason) =\n  \"ssl_ffi\" \"close\"\n\npub external fn do_shutdown(\n  socket: Socket,\n  write: Atom,\n) -> Result(Nil, SocketReason) =\n  \"ssl_ffi\" \"shutdown\"\n\npub fn shutdown(socket: Socket) -> Result(Nil, SocketReason) {\n  let assert Ok(write) = atom.from_string(\"write\")\n  do_shutdown(socket, write)\n}\n\nexternal fn do_set_opts(socket: Socket, opts: List(Dynamic)) -> Result(Nil, Nil) =\n  \"ssl_ffi\" \"set_opts\"\n\n/// Update the optons for a socket (mutates the socket)\npub fn set_opts(\n  socket: Socket,\n  opts: List(options.TcpOption),\n) -> Result(Nil, Nil) {\n  opts\n  |> options.to_map\n  |> map.to_list\n  |> list.map(dynamic.from)\n  |> do_set_opts(socket, _)\n}\n\npub external fn handshake(socket: Socket) -> Result(Socket, Nil) =\n  \"ssl\" \"handshake\"\n\n/// Start listening over SSL on a port with the given options\npub fn listen(\n  port: Int,\n  options: List(options.TcpOption),\n) -> Result(ListenSocket, SocketReason) {\n  options\n  |> options.merge_with_defaults\n  |> do_listen(port, _)\n}\n\npub external fn negotiated_protocol(socket: Socket) -> Result(String, String) =\n  \"ssl_ffi\" \"negotiated_protocol\"\n" (Durability(0))    
2023-08-04T09:30:46.273076Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273085Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R149    
2023-08-04T09:30:46.273093Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(53)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/dynamic\nimport gleam/erlang/process.{Subject}\nimport gleam/function\nimport gleam/option.{Option, Some}\nimport gleam/otp/actor\nimport gleam/otp/port.{Port}\nimport gleam/result\nimport gleam/string\nimport glisten/logger\nimport glisten/socket.{Socket}\nimport glisten/socket/transport.{Transport}\nimport glisten/socket/options\n\n/// All message types that the handler will receive, or that you can\n/// send to the handler process\npub type HandlerMessage {\n  Close\n  Ready\n  ReceiveMessage(BitString)\n  SendMessage(BitBuilder)\n  Ssl(socket: Port, data: BitString)\n  SslClosed(Nil)\n  Tcp(socket: Port, data: BitString)\n  TcpClosed(Nil)\n}\n\npub type LoopState(data) {\n  LoopState(\n    socket: Socket,\n    sender: Subject(HandlerMessage),\n    transport: Transport,\n    data: data,\n  )\n}\n\npub type LoopFn(data) =\n  fn(HandlerMessage, LoopState(data)) -> actor.Next(LoopState(data))\n\npub type Handler(data) {\n  Handler(\n    socket: Socket,\n    initial_data: data,\n    loop: LoopFn(data),\n    on_init: Option(fn(Subject(HandlerMessage)) -> Nil),\n    on_close: Option(fn(Subject(HandlerMessage)) -> Nil),\n    transport: Transport,\n  )\n}\n\n/// Starts an actor for the TCP connection\npub fn start(\n  handler: Handler(data),\n) -> Result(Subject(HandlerMessage), actor.StartError) {\n  actor.start_spec(actor.Spec(\n    init: fn() {\n      let subject = process.new_subject()\n      let selector =\n        process.new_selector()\n        |> process.selecting(subject, function.identity)\n        |> process.selecting_anything(fn(msg) {\n          case dynamic.unsafe_coerce(msg) {\n            Tcp(_sock, data) | Ssl(_sock, data) -> ReceiveMessage(data)\n            msg -> msg\n          }\n        })\n      actor.Ready(\n        LoopState(\n          handler.socket,\n          subject,\n          handler.transport,\n          data: handler.initial_data,\n        ),\n        selector,\n      )\n    },\n    init_timeout: 1000,\n    loop: fn(msg, state) {\n      case msg {\n        TcpClosed(_) | SslClosed(_) | Close ->\n          case state.transport.close(state.socket) {\n            Ok(Nil) -> {\n              let _ = case handler.on_close {\n                Some(func) -> func(state.sender)\n                _ -> Nil\n              }\n              actor.Stop(process.Normal)\n            }\n            Error(err) -> actor.Stop(process.Abnormal(string.inspect(err)))\n          }\n        Ready ->\n          state.socket\n          |> state.transport.handshake\n          |> result.replace_error(\"Failed to handshake socket\")\n          |> result.map(fn(_ok) {\n            let _ = case handler.on_init {\n              Some(func) -> func(state.sender)\n              _ -> Nil\n            }\n          })\n          |> result.then(fn(_ok) {\n            state.transport.set_opts(\n              state.socket,\n              [options.ActiveMode(options.Once)],\n            )\n            |> result.replace_error(\"Failed to set socket active\")\n          })\n          |> result.replace(actor.Continue(state))\n          |> result.map_error(fn(reason) {\n            actor.Stop(process.Abnormal(reason))\n          })\n          |> result.unwrap_both\n        msg ->\n          case handler.loop(msg, state) {\n            actor.Continue(next_state) -> {\n              let assert Ok(Nil) =\n                state.transport.set_opts(\n                  state.socket,\n                  [options.ActiveMode(options.Once)],\n                )\n              actor.Continue(next_state)\n            }\n            msg -> msg\n          }\n      }\n    },\n  ))\n}\n\npub type HandlerFunc(data) =\n  fn(BitString, LoopState(data)) -> actor.Next(LoopState(data))\n\n/// This helper will generate a TCP handler that will call your handler function\n/// with the BitString data in the packet as well as the LoopState, with any\n/// associated state data you are maintaining\npub fn func(handler func: HandlerFunc(data)) -> LoopFn(data) {\n  fn(msg, state: LoopState(data)) {\n    case msg {\n      Tcp(_, _) | Ready -> {\n        logger.error(#(\"Received an unexpected TCP message\", msg))\n        actor.Continue(state)\n      }\n      ReceiveMessage(data) -> func(data, state)\n      SendMessage(data) ->\n        case state.transport.send(state.socket, data) {\n          Ok(_nil) -> actor.Continue(state)\n          Error(reason) -> {\n            logger.error(#(\"Failed to send data\", reason))\n            actor.Stop(process.Abnormal(\"Failed to send data\"))\n          }\n        }\n      // NOTE:  this should never happen.  This function is only called _after_\n      // the other message types are handled\n      msg -> {\n        logger.error(#(\"Unhandled TCP message\", msg))\n        actor.Stop(process.Abnormal(\"Unhandled TCP message\"))\n      }\n    }\n  }\n}\n" (Durability(0))    
2023-08-04T09:30:46.273166Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273174Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R150    
2023-08-04T09:30:46.273183Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(54)) = "pub type SocketReason {\n  Closed\n  Timeout\n  Badarg\n  Terminated\n\n  // inet:posix() errors.\n  Eaddrinuse\n  Eaddrnotavail\n  Eafnosupport\n  Ealready\n  Econnaborted\n  Econnrefused\n  Econnreset\n  Edestaddrreq\n  Ehostdown\n  Ehostunreach\n  Einprogress\n  Eisconn\n  Emsgsize\n  Enetdown\n  Enetunreach\n  Enopkg\n  Enoprotoopt\n  Enotconn\n  Enotty\n  Enotsock\n  Eproto\n  Eprotonosupport\n  Eprototype\n  Esocktnosupport\n  Etimedout\n  Ewouldblock\n  Exbadport\n  Exbadseq\n\n  // file:posix() errors.\n  Eacces\n  Eagain\n  Ebadf\n  Ebadmsg\n  Ebusy\n  Edeadlk\n  Edeadlock\n  Edquot\n  Eexist\n  Efault\n  Efbig\n  Eftype\n  Eintr\n  Einval\n  Eio\n  Eisdir\n  Eloop\n  Emfile\n  Emlink\n  Emultihop\n  Enametoolong\n  Enfile\n  Enobufs\n  Enodev\n  Enolck\n  Enolink\n  Enoent\n  Enomem\n  Enospc\n  Enosr\n  Enostr\n  Enosys\n  Enotblk\n  Enotdir\n  Enotsup\n  Enxio\n  Eopnotsupp\n  Eoverflow\n  Eperm\n  Epipe\n  Erange\n  Erofs\n  Espipe\n  Esrch\n  Estale\n  Etxtbsy\n  Exdev\n}\n\npub opaque type ListenSocket {\n  ListenSocket\n}\n\npub opaque type Socket {\n  Socket\n}\n" (Durability(0))    
2023-08-04T09:30:46.273204Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273212Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R151    
2023-08-04T09:30:46.273220Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(55)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/dynamic.{Dynamic}\nimport gleam/erlang/atom.{Atom}\nimport gleam/erlang/process.{Pid}\nimport gleam/list\nimport gleam/map.{Map}\nimport glisten/socket.{ListenSocket, Socket, SocketReason}\nimport glisten/socket/options.{TcpOption}\n\npub external fn controlling_process(\n  socket: Socket,\n  pid: Pid,\n) -> Result(Nil, Atom) =\n  \"tcp_ffi\" \"controlling_process\"\n\nexternal fn do_listen_tcp(\n  port: Int,\n  options: List(TcpOption),\n) -> Result(ListenSocket, SocketReason) =\n  \"gen_tcp\" \"listen\"\n\npub external fn accept_timeout(\n  socket: ListenSocket,\n  timeout: Int,\n) -> Result(Socket, SocketReason) =\n  \"gen_tcp\" \"accept\"\n\npub external fn accept(socket: ListenSocket) -> Result(Socket, SocketReason) =\n  \"gen_tcp\" \"accept\"\n\npub external fn receive_timeout(\n  socket: Socket,\n  length: Int,\n  timeout: Int,\n) -> Result(BitString, SocketReason) =\n  \"gen_tcp\" \"recv\"\n\npub external fn receive(\n  socket: Socket,\n  length: Int,\n) -> Result(BitString, SocketReason) =\n  \"gen_tcp\" \"recv\"\n\npub external fn send(\n  socket: Socket,\n  packet: BitBuilder,\n) -> Result(Nil, SocketReason) =\n  \"tcp_ffi\" \"send\"\n\npub external fn socket_info(socket: Socket) -> Map(a, b) =\n  \"socket\" \"info\"\n\npub external fn close(socket: a) -> Result(Nil, SocketReason) =\n  \"tcp_ffi\" \"close\"\n\npub external fn do_shutdown(\n  socket: Socket,\n  write: Atom,\n) -> Result(Nil, SocketReason) =\n  \"tcp_ffi\" \"shutdown\"\n\npub fn shutdown(socket: Socket) -> Result(Nil, SocketReason) {\n  let assert Ok(write) = atom.from_string(\"write\")\n  do_shutdown(socket, write)\n}\n\nexternal fn do_set_opts(socket: Socket, opts: List(Dynamic)) -> Result(Nil, Nil) =\n  \"tcp_ffi\" \"set_opts\"\n\n/// Update the optons for a socket (mutates the socket)\npub fn set_opts(socket: Socket, opts: List(TcpOption)) -> Result(Nil, Nil) {\n  opts\n  |> options.to_map\n  |> map.to_list\n  |> list.map(dynamic.from)\n  |> do_set_opts(socket, _)\n}\n\n/// Start listening over TCP on a port with the given options\npub fn listen(\n  port: Int,\n  options: List(TcpOption),\n) -> Result(ListenSocket, SocketReason) {\n  options\n  |> options.merge_with_defaults\n  |> do_listen_tcp(port, _)\n}\n\npub fn handshake(socket: Socket) -> Result(Socket, Nil) {\n  Ok(socket)\n}\n\npub external fn negotiated_protocol(socket: Socket) -> a =\n  \"tcp\" \"negotiated_protocol\"\n" (Durability(0))    
2023-08-04T09:30:46.273275Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273283Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R152    
2023-08-04T09:30:46.273292Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(56)) = "import gleam/erlang/charlist.{Charlist}\n\nexternal fn log_error(format: Charlist, data: any) -> Nil =\n  \"logger\" \"error\"\n\npub fn error(data: any) -> Nil {\n  log_error(charlist.from_string(\"~tp\"), [data])\n}\n" (Durability(0))    
2023-08-04T09:30:46.273303Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273311Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R153    
2023-08-04T09:30:46.273331Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(57)) = "import gleam/erlang/process.{Abnormal, Subject}\nimport gleam/function\nimport gleam/iterator\nimport gleam/option.{None, Option, Some}\nimport gleam/otp/actor\nimport gleam/otp/supervisor\nimport gleam/result\nimport glisten/handler.{Handler, HandlerMessage, LoopFn, Ready}\nimport glisten/logger\nimport glisten/socket.{ListenSocket, Socket}\nimport glisten/socket/transport.{Transport}\n\npub type AcceptorMessage {\n  AcceptConnection(ListenSocket)\n}\n\npub type AcceptorError {\n  AcceptError\n  HandlerError\n  ControlError\n}\n\npub type AcceptorState {\n  AcceptorState(\n    sender: Subject(AcceptorMessage),\n    socket: Option(Socket),\n    transport: Transport,\n  )\n}\n\n/// Worker process that handles `accept`ing connections and starts a new process\n/// which receives the messages from the socket\npub fn start(\n  pool: Pool(data),\n) -> Result(Subject(AcceptorMessage), actor.StartError) {\n  actor.start_spec(actor.Spec(\n    init: fn() {\n      let subject = process.new_subject()\n      let selector =\n        process.new_selector()\n        |> process.selecting(subject, function.identity)\n\n      process.send(subject, AcceptConnection(pool.listener_socket))\n\n      actor.Ready(AcceptorState(subject, None, pool.transport), selector)\n    },\n    // TODO:  rethink this value, probably...\n    init_timeout: 1000,\n    loop: fn(msg, state) {\n      let AcceptorState(sender, ..) = state\n      case msg {\n        AcceptConnection(listener) -> {\n          let res = {\n            use sock <- result.then(\n              state.transport.accept(listener)\n              |> result.replace_error(AcceptError),\n            )\n            use start <- result.then(\n              Handler(\n                sock,\n                pool.initial_data,\n                pool.handler,\n                pool.on_init,\n                pool.on_close,\n                pool.transport,\n              )\n              |> handler.start\n              |> result.replace_error(HandlerError),\n            )\n            sock\n            |> state.transport.controlling_process(process.subject_owner(start))\n            |> result.replace_error(ControlError)\n            |> result.map(fn(_) { process.send(start, Ready) })\n          }\n          case res {\n            Error(reason) -> {\n              logger.error(#(\"Failed to accept/start handler\", reason))\n              actor.Stop(Abnormal(\"Failed to accept/start handler\"))\n            }\n            _val -> {\n              actor.send(sender, AcceptConnection(listener))\n              actor.Continue(state)\n            }\n          }\n        }\n        msg -> {\n          logger.error(#(\"Unknown message type\", msg))\n          actor.Stop(process.Abnormal(\"Unknown message type\"))\n        }\n      }\n    },\n  ))\n}\n\npub type Pool(data) {\n  Pool(\n    listener_socket: ListenSocket,\n    handler: LoopFn(data),\n    initial_data: data,\n    pool_count: Int,\n    on_init: Option(fn(Subject(HandlerMessage)) -> Nil),\n    on_close: Option(fn(Subject(HandlerMessage)) -> Nil),\n    transport: Transport,\n  )\n}\n\n/// Initialize acceptor pool where each handler has no state\npub fn new_pool(handler: LoopFn(Nil)) -> fn(ListenSocket) -> Pool(Nil) {\n  fn(listener_socket) {\n    Pool(\n      listener_socket: listener_socket,\n      handler: handler,\n      initial_data: Nil,\n      pool_count: 10,\n      on_init: None,\n      on_close: None,\n      transport: transport.tcp(),\n    )\n  }\n}\n\n/// Initialize an acceptor pool where each handler holds some state\npub fn new_pool_with_data(\n  handler: LoopFn(data),\n  initial_data: data,\n) -> fn(ListenSocket) -> Pool(data) {\n  fn(listener_socket) {\n    Pool(\n      listener_socket: listener_socket,\n      handler: handler,\n      initial_data: initial_data,\n      pool_count: 10,\n      on_init: None,\n      on_close: None,\n      transport: transport.tcp(),\n    )\n  }\n}\n\n/// Add an `on_init` handler to the acceptor pool\npub fn with_init(\n  make_pool: fn(ListenSocket) -> Pool(data),\n  func: fn(Subject(HandlerMessage)) -> Nil,\n) -> fn(ListenSocket) -> Pool(data) {\n  fn(socket) {\n    let pool = make_pool(socket)\n    Pool(..pool, on_init: Some(func))\n  }\n}\n\n/// Add an `on_close` handler to the acceptor pool\npub fn with_close(\n  make_pool: fn(ListenSocket) -> Pool(data),\n  func: fn(Subject(HandlerMessage)) -> Nil,\n) -> fn(ListenSocket) -> Pool(data) {\n  fn(socket) {\n    let pool = make_pool(socket)\n    Pool(..pool, on_close: Some(func))\n  }\n}\n\n/// Adjust the number of TCP acceptors in the pool\npub fn with_pool_size(\n  make_pool: fn(ListenSocket) -> Pool(data),\n  pool_count: Int,\n) -> fn(ListenSocket) -> Pool(data) {\n  fn(socket) {\n    let pool = make_pool(socket)\n    Pool(..pool, pool_count: pool_count)\n  }\n}\n\n/// Use SSL for the underlying socket.\npub fn over_ssl(\n  make_pool: fn(ListenSocket) -> Pool(data),\n) -> fn(ListenSocket) -> Pool(data) {\n  fn(socket) {\n    let pool = make_pool(socket)\n    Pool(..pool, transport: transport.ssl())\n  }\n}\n\n/// Starts a pool of acceptors of size `pool_count`.\n///\n/// Runs `loop_fn` on ever message received\npub fn start_pool(\n  pool: Pool(data),\n) -> Result(Subject(supervisor.Message), actor.StartError) {\n  supervisor.start_spec(supervisor.Spec(\n    argument: Nil,\n    // TODO:  i think these might need some tweaking\n    max_frequency: 100,\n    frequency_period: 1,\n    init: fn(children) {\n      iterator.range(from: 0, to: pool.pool_count)\n      |> iterator.fold(\n        children,\n        fn(children, _index) {\n          supervisor.add(children, supervisor.worker(fn(_arg) { start(pool) }))\n        },\n      )\n    },\n  ))\n}\n" (Durability(0))    
2023-08-04T09:30:46.273409Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273417Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R154    
2023-08-04T09:30:46.273426Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(58)) = "import gleam/dynamic.{Dynamic}\nimport gleam/erlang/atom\nimport gleam/list\nimport gleam/map.{Map}\nimport gleam/pair\n\n/// Mode for the socket.  Currently `list` is not supported\npub type SocketMode {\n  Binary\n}\n\n/// Mapping to the {active, _} option\npub type ActiveState {\n  Once\n  Passive\n  Count(Int)\n  // This is dumb and annoying. I'd much prefer `True` or `Active`, but both\n  // of those make this a lot more annoying to work with\n  Active\n}\n\n/// Options for the TCP socket\npub type TcpOption {\n  Backlog(Int)\n  Nodelay(Bool)\n  Linger(#(Bool, Int))\n  SendTimeout(Int)\n  SendTimeoutClose(Bool)\n  Reuseaddr(Bool)\n  ActiveMode(ActiveState)\n  Mode(SocketMode)\n  // TODO:  Probably should adjust the type here to only allow this for SSL\n  Certfile(String)\n  Keyfile(String)\n  AlpnPreferredProtocols(List(String))\n}\n\npub fn to_map(options: List(TcpOption)) -> Map(atom.Atom, Dynamic) {\n  let opt_decoder = dynamic.tuple2(dynamic.dynamic, dynamic.dynamic)\n\n  options\n  |> list.map(fn(opt) {\n    case opt {\n      ActiveMode(Passive) ->\n        dynamic.from(#(atom.create_from_string(\"active\"), False))\n      ActiveMode(Active) ->\n        dynamic.from(#(atom.create_from_string(\"active\"), True))\n      ActiveMode(Count(n)) ->\n        dynamic.from(#(atom.create_from_string(\"active\"), n))\n      ActiveMode(Once) ->\n        dynamic.from(#(\n          atom.create_from_string(\"active\"),\n          atom.create_from_string(\"once\"),\n        ))\n      other -> dynamic.from(other)\n    }\n  })\n  |> list.filter_map(opt_decoder)\n  |> list.map(pair.map_first(_, dynamic.unsafe_coerce))\n  |> map.from_list\n}\n\nconst default_options = [\n  Backlog(1024),\n  Nodelay(True),\n  Linger(#(True, 30)),\n  SendTimeout(30_000),\n  SendTimeoutClose(True),\n  Reuseaddr(True),\n  Mode(Binary),\n  ActiveMode(Passive),\n]\n\npub fn merge_with_defaults(options: List(TcpOption)) -> List(TcpOption) {\n  let overrides = to_map(options)\n\n  default_options\n  |> to_map\n  |> map.merge(overrides)\n  |> map.to_list\n  |> list.map(dynamic.from)\n  |> list.map(dynamic.unsafe_coerce)\n}\n" (Durability(0))    
2023-08-04T09:30:46.273467Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273475Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R155    
2023-08-04T09:30:46.273484Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(59)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/dynamic.{Dynamic}\nimport gleam/erlang/atom.{Atom}\nimport gleam/erlang/process.{Pid}\nimport gleam/map.{Map}\nimport glisten/socket/options\nimport glisten/socket.{ListenSocket, Socket, SocketReason}\nimport glisten/ssl\nimport glisten/tcp\n\ntype ControllingProcess =\n  fn(Socket, Pid) -> Result(Nil, Atom)\n\ntype Listen =\n  fn(Int, List(options.TcpOption)) -> Result(ListenSocket, SocketReason)\n\ntype AcceptTimeout =\n  fn(ListenSocket, Int) -> Result(Socket, SocketReason)\n\ntype Accept =\n  fn(ListenSocket) -> Result(Socket, SocketReason)\n\ntype ReceiveTimeout =\n  fn(Socket, Int, Int) -> Result(BitString, SocketReason)\n\ntype Receive =\n  fn(Socket, Int) -> Result(BitString, SocketReason)\n\ntype Send =\n  fn(Socket, BitBuilder) -> Result(Nil, SocketReason)\n\ntype SocketInfo =\n  fn(Socket) -> Map(Atom, Dynamic)\n\ntype Close =\n  fn(Socket) -> Result(Nil, SocketReason)\n\ntype Shutdown =\n  fn(Socket) -> Result(Nil, SocketReason)\n\ntype SetOpts =\n  fn(Socket, List(options.TcpOption)) -> Result(Nil, Nil)\n\ntype Handshake =\n  fn(Socket) -> Result(Socket, Nil)\n\ntype NegotiatedProtocol =\n  fn(Socket) -> Result(String, String)\n\npub type Transport {\n  Ssl(\n    accept: Accept,\n    accept_timeout: AcceptTimeout,\n    close: Close,\n    controlling_process: ControllingProcess,\n    handshake: Handshake,\n    listen: Listen,\n    negotiated_protocol: NegotiatedProtocol,\n    receive: Receive,\n    receive_timeout: ReceiveTimeout,\n    send: Send,\n    set_opts: SetOpts,\n    shutdown: Shutdown,\n    socket_info: SocketInfo,\n  )\n  Tcp(\n    accept: Accept,\n    accept_timeout: AcceptTimeout,\n    close: Close,\n    controlling_process: ControllingProcess,\n    handshake: Handshake,\n    listen: Listen,\n    negotiated_protocol: NegotiatedProtocol,\n    receive: Receive,\n    receive_timeout: ReceiveTimeout,\n    send: Send,\n    set_opts: SetOpts,\n    shutdown: Shutdown,\n    socket_info: SocketInfo,\n  )\n}\n\npub fn tcp() -> Transport {\n  Tcp(\n    accept: tcp.accept,\n    accept_timeout: tcp.accept_timeout,\n    close: tcp.close,\n    controlling_process: tcp.controlling_process,\n    handshake: tcp.handshake,\n    listen: tcp.listen,\n    negotiated_protocol: fn(_socket) {\n      Error(\"Can't negotiate protocol on tcp\")\n    },\n    receive: tcp.receive,\n    receive_timeout: tcp.receive_timeout,\n    send: tcp.send,\n    set_opts: tcp.set_opts,\n    shutdown: tcp.shutdown,\n    socket_info: socket_info,\n  )\n}\n\npub fn ssl() -> Transport {\n  Ssl(\n    accept: ssl.accept,\n    accept_timeout: ssl.accept_timeout,\n    close: ssl.close,\n    controlling_process: ssl.controlling_process,\n    handshake: ssl.handshake,\n    listen: ssl.listen,\n    negotiated_protocol: ssl.negotiated_protocol,\n    receive: ssl.receive,\n    receive_timeout: ssl.receive_timeout,\n    send: ssl.send,\n    set_opts: ssl.set_opts,\n    shutdown: ssl.shutdown,\n    socket_info: socket_info,\n  )\n}\n\npub external fn socket_info(socket: Socket) -> Map(a, b) =\n  \"socket\" \"info\"\n" (Durability(0))    
2023-08-04T09:30:46.273534Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273542Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R156    
2023-08-04T09:30:46.273550Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(60)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/bit_string\nimport gleam/http/request.{Request}\nimport gleam/http/response.{Response as HttpResponse}\nimport gleam/iterator.{Iterator}\nimport gleam/result\nimport glisten\nimport glisten/acceptor\nimport glisten/handler.{LoopFn} as glisten_handler\nimport mist/internal/handler.{\n  HandlerResponse, Response as MistResponse, State, Upgrade,\n}\nimport mist/internal/http.{BitBuilderBody, Body as HTTPBody, Chunked, FileBody}\nimport mist/internal/file.{FileError}\nimport mist/internal/websocket.{WebsocketHandler}\n\n/// This type reflects whether the body has been read from the socket yet.\npub type Body =\n  HTTPBody\n\n/// Mist supports `BitBuilder`, `FileBody`, and `Chunked` response types. The\n/// helper methods provided can generate these from a `gleam/http/response`\n/// Response. This type is re-exported for pulling specific handlers out into\n/// separate functions.\npub type Response =\n  HandlerResponse\n\n/// Runs an HTTP Request->Response server at the given port, with your defined\n/// handler. This will automatically read the full body contents up to the\n/// specified `max_body_limit` in bytes. If you'd prefer to have finer-grain\n/// control over this behavior, consider using `mist.serve`.\npub fn run_service(\n  port: Int,\n  handler: handler.Handler,\n  max_body_limit max_body_limit: Int,\n) -> Result(Nil, glisten.StartError) {\n  handler\n  |> handler.with(max_body_limit)\n  |> acceptor.new_pool_with_data(handler.new_state())\n  |> glisten.serve(port, _)\n}\n\n/// Similar setup and behavior to `run_service`, but instead takes in the SSL\n/// certificate/key and serves over HTTPS.\npub fn run_service_ssl(\n  port port: Int,\n  certfile certfile: String,\n  keyfile keyfile: String,\n  handler handler: handler.Handler,\n  max_body_limit max_body_limit: Int,\n) -> Result(Nil, glisten.StartError) {\n  handler\n  |> handler.with(max_body_limit)\n  |> acceptor.new_pool_with_data(handler.new_state())\n  |> glisten.serve_ssl(\n    port: port,\n    certfile: certfile,\n    keyfile: keyfile,\n    with_pool: _,\n  )\n}\n\n/// Slightly more flexible alternative to `run_service`. This allows hooking\n/// into the `mist.handler_func` method. Note that the request body\n/// will not be automatically read. You will need to call `mist.read_body`.\n/// Ensure that this is only called _once_ per request.\npub fn serve(\n  port port: Int,\n  handler handler: LoopFn(State),\n) -> Result(Nil, glisten.StartError) {\n  handler\n  |> acceptor.new_pool_with_data(handler.new_state())\n  |> glisten.serve(port, _)\n}\n\n/// Similar to the `run_service` method, `serve` also has a similar SSL method.\npub fn serve_ssl(\n  port port: Int,\n  certfile certfile: String,\n  keyfile keyfile: String,\n  handler handler: LoopFn(State),\n) -> Result(Nil, glisten.StartError) {\n  handler\n  |> acceptor.new_pool_with_data(handler.new_state())\n  |> glisten.serve_ssl(\n    port: port,\n    certfile: certfile,\n    keyfile: keyfile,\n    with_pool: _,\n  )\n}\n\n/// Handles converting the mist `Response` type into a gleam HTTP Response. Use\n/// this when calling `mist.serve` to start your application.\npub fn handler_func(\n  handler: handler.HandlerFunc,\n) -> glisten_handler.LoopFn(handler.State) {\n  handler.with_func(handler)\n}\n\n/// When using `mist.serve`, the body is not automatically read. You can\n/// inspect content headers to determine whether to read the body or not.\n/// This function will pull the content from the sender. It gives back a\n/// `Request(BitString)` containing the body. This return value should be\n/// treated as replacing the initial request. Do not attempt to call this\n/// method multiple times on the same request.\npub fn read_body(\n  req: Request(Body),\n) -> Result(Request(BitString), http.DecodeError) {\n  http.read_body(req)\n}\n\n/// A websocket handler is created using the `websocket.with_handler`\n/// method. This function enables the mist HTTP layer to build the properly\n/// formatted websocket upgrade response.\npub fn upgrade(websocket_handler: WebsocketHandler) -> Response {\n  Upgrade(websocket_handler)\n}\n\n/// `mist.serve` expects the mist Response type, rather than the `gleam/http`\n/// Response. When returning a response with no body, this will convert the\n/// type. Note that any previously set response body will be removed before\n/// sending.\npub fn empty_response(resp: HttpResponse(a)) -> Response {\n  resp\n  |> response.set_body(BitBuilderBody(bit_builder.new()))\n  |> MistResponse\n}\n\n/// The mist runtime only supports sending BitBuilder types, or files (see\n/// below). This method will erase any pre-existing response body.\npub fn bit_builder_response(resp: HttpResponse(a), data: BitBuilder) -> Response {\n  resp\n  |> response.set_body(BitBuilderBody(data))\n  |> MistResponse\n}\n\n/// This is a more generally optimized method for returning files to a client.\n/// It's a light wrapper around Erlang's `file:sendfile/5` method. The error\n/// can be matched on with `mist/file.{FileError}` if custom behavior is desired\n/// for various cases. The size of the file will be added to the\n/// `content-length` header field.\npub fn file_response(\n  resp: HttpResponse(a),\n  path: String,\n  content_type: String,\n) -> Result(Response, FileError) {\n  let file_path = bit_string.from_string(path)\n  let size = file.size(file_path)\n  use fd <- result.map(file.open(file_path))\n  resp\n  |> response.set_body(FileBody(fd, content_type, 0, size))\n  |> MistResponse\n}\n\n/// You can send chunks of responses from an iterator. The iterator must\n/// complete.\npub fn chunked_response(\n  resp: HttpResponse(a),\n  iter: Iterator(BitBuilder),\n) -> Response {\n  resp\n  |> response.set_body(Chunked(iter))\n  |> MistResponse\n}\n" (Durability(0))    
2023-08-04T09:30:46.273627Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273635Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R157    
2023-08-04T09:30:46.273657Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(61)) = "import gleam/bit_string\nimport gleam/erlang/process.{Subject}\nimport gleam/option.{None, Some}\nimport glisten/handler.{HandlerMessage, SendMessage}\nimport mist/internal/websocket.{\n  BinaryMessage, EventHandler, Handler, Message, TextMessage, WebsocketHandler,\n  to_binary_frame, to_text_frame,\n}\n\n/// Helper to encapsulate the logic to send a provided message over the\n/// WebSocket\npub fn send(sender: Subject(HandlerMessage), message: Message) -> Nil {\n  case message {\n    TextMessage(data) ->\n      data\n      |> bit_string.from_string\n      |> to_text_frame\n    BinaryMessage(data) -> to_binary_frame(data)\n  }\n  |> SendMessage\n  |> process.send(sender, _)\n\n  Nil\n}\n\npub fn echo_handler(\n  message: Message,\n  sender: Subject(HandlerMessage),\n) -> Result(Nil, Nil) {\n  let _ = send(sender, message)\n\n  Ok(Nil)\n}\n\npub fn with_handler(func: Handler) -> WebsocketHandler {\n  WebsocketHandler(on_close: None, on_init: None, handler: func)\n}\n\npub fn on_init(\n  handler: WebsocketHandler,\n  func: EventHandler,\n) -> WebsocketHandler {\n  WebsocketHandler(..handler, on_init: Some(func))\n}\n\npub fn on_close(\n  handler: WebsocketHandler,\n  func: EventHandler,\n) -> WebsocketHandler {\n  WebsocketHandler(..handler, on_close: Some(func))\n}\n" (Durability(0))    
2023-08-04T09:30:46.273678Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273686Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R158    
2023-08-04T09:30:46.273694Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(62)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/bit_string\nimport gleam/dynamic.{Dynamic}\nimport gleam/erlang/atom.{Atom}\nimport gleam/erlang/charlist.{Charlist}\nimport gleam/http/request.{Request}\nimport gleam/http/response.{Response}\nimport gleam/http\nimport gleam/int\nimport gleam/iterator.{Iterator}\nimport gleam/list\nimport gleam/map.{Map}\nimport gleam/option.{Option}\nimport gleam/pair\nimport gleam/result\nimport gleam/string\nimport gleam/uri\nimport glisten/socket.{Socket}\nimport glisten/socket/transport.{Transport}\nimport mist/internal/encoder\nimport mist/internal/file\nimport mist/internal/websocket\n\npub type PacketType {\n  Http\n  HttphBin\n  HttpBin\n}\n\npub type HttpUri {\n  AbsPath(BitString)\n}\n\npub type HttpPacket {\n  HttpRequest(Dynamic, HttpUri, #(Int, Int))\n  HttpHeader(Int, Atom, BitString, BitString)\n}\n\npub type DecodedPacket {\n  BinaryData(HttpPacket, BitString)\n  EndOfHeaders(BitString)\n  MoreData(Option(Int))\n}\n\npub type DecodeError {\n  MalformedRequest\n  InvalidMethod\n  InvalidPath\n  UnknownHeader\n  UnknownMethod\n  // TODO:  better name?\n  InvalidBody\n  DiscardPacket\n}\n\nexternal fn decode_packet(\n  packet_type: PacketType,\n  packet: BitString,\n  options: List(a),\n) -> Result(DecodedPacket, DecodeError) =\n  \"mist_ffi\" \"decode_packet\"\n\npub fn from_header(value: BitString) -> String {\n  let assert Ok(value) = bit_string.to_string(value)\n\n  string.lowercase(value)\n}\n\npub type Buffer {\n  Buffer(remaining: Int, data: BitString)\n}\n\npub fn parse_headers(\n  bs: BitString,\n  socket: Socket,\n  transport: Transport,\n  headers: Map(String, String),\n) -> Result(#(Map(String, String), BitString), DecodeError) {\n  case decode_packet(HttphBin, bs, []) {\n    Ok(BinaryData(HttpHeader(_, _field, field, value), rest)) -> {\n      let field = from_header(field)\n      let assert Ok(value) = bit_string.to_string(value)\n      headers\n      |> map.insert(field, value)\n      |> parse_headers(rest, socket, transport, _)\n    }\n    Ok(EndOfHeaders(rest)) -> Ok(#(headers, rest))\n    Ok(MoreData(size)) -> {\n      let amount_to_read = option.unwrap(size, 0)\n      use next <- result.then(read_data(\n        socket,\n        transport,\n        Buffer(amount_to_read, bs),\n        UnknownHeader,\n      ))\n      parse_headers(next, socket, transport, headers)\n    }\n    _other -> Error(UnknownHeader)\n  }\n}\n\npub fn read_data(\n  socket: Socket,\n  transport: Transport,\n  buffer: Buffer,\n  error: DecodeError,\n) -> Result(BitString, DecodeError) {\n  // TODO:  don't hard-code these, probably\n  let to_read = int.min(buffer.remaining, 1_000_000)\n  let timeout = 15_000\n  use data <- result.then(\n    socket\n    |> transport.receive_timeout(to_read, timeout)\n    |> result.replace_error(error),\n  )\n  let next_buffer =\n    Buffer(\n      remaining: buffer.remaining - to_read,\n      data: <<buffer.data:bit_string, data:bit_string>>,\n    )\n\n  case next_buffer.remaining > 0 {\n    True -> read_data(socket, transport, next_buffer, error)\n    False -> Ok(next_buffer.data)\n  }\n}\n\nexternal fn binary_match(\n  source: BitString,\n  pattern: BitString,\n) -> Result(#(Int, Int), Nil) =\n  \"mist_ffi\" \"binary_match\"\n\nexternal fn string_to_int(string: Charlist, base: Int) -> Result(Int, Nil) =\n  \"mist_ffi\" \"string_to_int\"\n\nconst crnl = <<13:int, 10:int>>\n\nfn read_chunk(\n  socket: Socket,\n  transport: Transport,\n  buffer: Buffer,\n  body: BitBuilder,\n) -> Result(BitBuilder, DecodeError) {\n  case buffer.data, binary_match(buffer.data, crnl) {\n    _, Ok(#(offset, _)) -> {\n      let assert <<\n        chunk:binary-size(offset),\n        _return:int,\n        _newline:int,\n        rest:binary,\n      >> = buffer.data\n      use chunk_size <- result.then(\n        chunk\n        |> bit_string.to_string\n        |> result.map(charlist.from_string)\n        |> result.replace_error(InvalidBody),\n      )\n      use size <- result.then(\n        string_to_int(chunk_size, 16)\n        |> result.replace_error(InvalidBody),\n      )\n      case size {\n        0 -> Ok(body)\n        size ->\n          case rest {\n            <<next_chunk:binary-size(size), 13:int, 10:int, rest:binary>> ->\n              read_chunk(\n                socket,\n                transport,\n                Buffer(0, rest),\n                bit_builder.append(body, next_chunk),\n              )\n            _ -> {\n              use next <- result.then(read_data(\n                socket,\n                transport,\n                Buffer(0, buffer.data),\n                InvalidBody,\n              ))\n              read_chunk(socket, transport, Buffer(0, next), body)\n            }\n          }\n      }\n    }\n    <<>>, _ -> {\n      use next <- result.then(read_data(\n        socket,\n        transport,\n        Buffer(0, buffer.data),\n        InvalidBody,\n      ))\n      read_chunk(socket, transport, Buffer(0, next), body)\n    }\n    _, Error(Nil) -> Error(InvalidBody)\n  }\n}\n\n/// Turns the TCP message into an HTTP request\npub fn parse_request(\n  bs: BitString,\n  socket: Socket,\n  transport: Transport,\n) -> Result(request.Request(Body), DecodeError) {\n  case decode_packet(HttpBin, bs, []) {\n    Ok(BinaryData(HttpRequest(http_method, AbsPath(path), _version), rest)) -> {\n      use method <- result.then(\n        http_method\n        |> atom.from_dynamic\n        |> result.map(atom.to_string)\n        |> result.or(dynamic.string(http_method))\n        |> result.nil_error\n        |> result.then(http.parse_method)\n        |> result.replace_error(UnknownMethod),\n      )\n      use #(headers, rest) <- result.then(parse_headers(\n        rest,\n        socket,\n        transport,\n        map.new(),\n      ))\n      use path <- result.then(\n        path\n        |> bit_string.to_string\n        |> result.replace_error(InvalidPath),\n      )\n      let #(path, query) = case string.split(path, \"?\") {\n        [path] -> #(path, [])\n        [path, query_string] -> {\n          let query =\n            query_string\n            |> uri.parse_query\n            |> result.unwrap([])\n          #(path, query)\n        }\n      }\n      let req =\n        request.new()\n        |> request.set_scheme(case transport {\n          transport.Ssl(..) -> http.Https\n          transport.Tcp(..) -> http.Http\n        })\n        |> request.set_body(Unread(rest, socket))\n        |> request.set_method(method)\n        |> request.set_path(path)\n        |> request.set_query(query)\n      Ok(request.Request(..req, headers: map.to_list(headers)))\n    }\n    _ -> Error(DiscardPacket)\n  }\n}\n\npub opaque type Body {\n  Unread(rest: BitString, socket: Socket)\n  Read(data: BitString)\n}\n\npub fn read_body(req: Request(Body)) -> Result(Request(BitString), DecodeError) {\n  let transport = case req.scheme {\n    http.Https -> transport.ssl()\n    http.Http -> transport.tcp()\n  }\n  case request.get_header(req, \"transfer-encoding\"), req.body {\n    Ok(\"chunked\"), Unread(rest, socket) -> {\n      use chunk <- result.then(read_chunk(\n        socket,\n        transport,\n        Buffer(remaining: 0, data: rest),\n        bit_builder.new(),\n      ))\n      Ok(request.set_body(req, bit_builder.to_bit_string(chunk)))\n    }\n    _, Unread(rest, socket) -> {\n      let _continue = case is_continue(req) {\n        True -> {\n          let assert Ok(Nil) =\n            response.new(100)\n            |> response.set_body(bit_builder.new())\n            |> encoder.to_bit_builder\n            |> transport.send(socket, _)\n          Nil\n        }\n        False -> Nil\n      }\n      let body_size =\n        req.headers\n        |> list.find(fn(tup) { pair.first(tup) == \"content-length\" })\n        |> result.map(pair.second)\n        |> result.then(int.parse)\n        |> result.unwrap(0)\n      let remaining = body_size - bit_string.byte_size(rest)\n      case body_size, remaining {\n        0, 0 -> Ok(<<>>)\n        0, _n -> Ok(rest)\n        // is this pipelining? check for GET?\n        _n, 0 -> Ok(rest)\n        _size, _rem ->\n          read_data(socket, transport, Buffer(remaining, rest), InvalidBody)\n      }\n      |> result.map(request.set_body(req, _))\n      |> result.replace_error(InvalidBody)\n    }\n    _, Read(_data) -> Error(InvalidBody)\n  }\n}\n\npub type HttpResponseBody {\n  BitBuilderBody(BitBuilder)\n  Chunked(Iterator(BitBuilder))\n  FileBody(\n    file_descriptor: file.FileDescriptor,\n    content_type: String,\n    offset: Int,\n    length: Int,\n  )\n}\n\npub fn upgrade_socket(\n  req: Request(Body),\n) -> Result(Response(BitBuilder), Request(Body)) {\n  use _upgrade <- result.then(\n    request.get_header(req, \"upgrade\")\n    |> result.replace_error(req),\n  )\n  use key <- result.then(\n    request.get_header(req, \"sec-websocket-key\")\n    |> result.replace_error(req),\n  )\n  use _version <- result.then(\n    request.get_header(req, \"sec-websocket-version\")\n    |> result.replace_error(req),\n  )\n\n  let accept_key = websocket.parse_key(key)\n\n  response.new(101)\n  |> response.set_body(bit_builder.new())\n  |> response.prepend_header(\"Upgrade\", \"websocket\")\n  |> response.prepend_header(\"Connection\", \"Upgrade\")\n  |> response.prepend_header(\"Sec-WebSocket-Accept\", accept_key)\n  |> Ok\n}\n\n// TODO: improve this error type\npub fn upgrade(\n  socket: Socket,\n  transport: Transport,\n  req: Request(Body),\n) -> Result(Nil, Nil) {\n  use resp <- result.then(\n    upgrade_socket(req)\n    |> result.nil_error,\n  )\n\n  use _sent <- result.then(\n    resp\n    |> add_default_headers\n    |> encoder.to_bit_builder\n    |> transport.send(socket, _)\n    |> result.nil_error,\n  )\n\n  Ok(Nil)\n}\n\npub fn add_default_headers(resp: Response(BitBuilder)) -> Response(BitBuilder) {\n  let body_size = bit_builder.byte_size(resp.body)\n\n  let headers =\n    map.from_list([\n      #(\"content-length\", int.to_string(body_size)),\n      #(\"connection\", \"keep-alive\"),\n    ])\n    |> list.fold(\n      resp.headers,\n      _,\n      fn(defaults, tup) {\n        let #(key, value) = tup\n        map.insert(defaults, key, value)\n      },\n    )\n    |> map.to_list\n\n  Response(..resp, headers: headers)\n}\n\nfn is_continue(req: Request(Body)) -> Bool {\n  req.headers\n  |> list.find(fn(tup) {\n    pair.first(tup) == \"expect\" && pair.second(tup) == \"100-continue\"\n  })\n  |> result.is_ok\n}\n" (Durability(0))    
2023-08-04T09:30:46.273827Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273835Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R159    
2023-08-04T09:30:46.273843Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(63)) = "import gleam/erlang/atom.{Atom}\nimport glisten/socket.{Socket}\n\npub external type FileDescriptor\n\npub external fn size(path: BitString) -> Int =\n  \"filelib\" \"file_size\"\n\npub external fn sendfile(\n  file_descriptor: FileDescriptor,\n  socket: Socket,\n  offset: Int,\n  bytes: Int,\n  options: List(a),\n) -> Result(Int, Atom) =\n  \"file\" \"sendfile\"\n\npub type FileError {\n  IsDir\n  NoAccess\n  NoEntry\n  UnknownFileError\n}\n\npub external fn open(file: BitString) -> Result(FileDescriptor, FileError) =\n  \"mist_ffi\" \"file_open\"\n" (Durability(0))    
2023-08-04T09:30:46.273857Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.273865Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R160    
2023-08-04T09:30:46.273873Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(64)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/bit_string\nimport gleam/dynamic\nimport gleam/erlang.{Errored, Exited, Thrown, rescue}\nimport gleam/erlang/process\nimport gleam/http/request.{Request}\nimport gleam/http/response\nimport gleam/int\nimport gleam/iterator.{Iterator}\nimport gleam/option.{None, Option, Some}\nimport gleam/otp/actor\nimport gleam/result\nimport glisten/handler.{Close, LoopFn, LoopState}\nimport glisten/socket.{Socket}\nimport glisten/socket/transport.{Transport}\nimport mist/internal/encoder\nimport mist/internal/file\nimport mist/internal/http.{\n  BitBuilderBody, Body, Chunked, DecodeError, DiscardPacket, FileBody,\n  HttpResponseBody,\n}\nimport mist/internal/logger\nimport mist/internal/websocket\n\npub type Handler =\n  fn(request.Request(BitString)) -> response.Response(BitBuilder)\n\npub type HandlerResponse {\n  Response(response: response.Response(HttpResponseBody))\n  Upgrade(websocket.WebsocketHandler)\n}\n\npub type HandlerFunc =\n  fn(Request(Body)) -> HandlerResponse\n\npub type HandlerError {\n  InvalidRequest(DecodeError)\n  NotFound\n}\n\nconst stop_normal = actor.Stop(process.Normal)\n\npub type State {\n  State(\n    idle_timer: Option(process.Timer),\n    upgraded_handler: Option(websocket.WebsocketHandler),\n  )\n}\n\npub fn new_state() -> State {\n  State(None, None)\n}\n\n/// This is a more flexible handler. It will allow you to upgrade a connection\n/// to a websocket connection, or deal with a regular HTTP req->resp workflow.\npub fn with_func(handler: HandlerFunc) -> LoopFn(State) {\n  handler.func(fn(msg, socket_state: LoopState(State)) {\n    let LoopState(socket, transport: transport, data: state, ..) = socket_state\n    case state.upgraded_handler {\n      Some(ws_handler) ->\n        handle_websocket_message(socket_state, ws_handler, msg)\n      None ->\n        {\n          let _ = case state.idle_timer {\n            Some(t) -> process.cancel_timer(t)\n            _ -> process.TimerNotFound\n          }\n          msg\n          |> http.parse_request(socket, transport)\n          |> result.map_error(fn(err) {\n            case err {\n              DiscardPacket -> Nil\n              _ -> {\n                logger.error(err)\n                let _ = transport.close(socket)\n                Nil\n              }\n            }\n          })\n          |> result.replace_error(stop_normal)\n          |> result.then(fn(req) {\n            rescue(fn() { handler(req) })\n            |> result.map(fn(resp) { #(req, resp) })\n            |> result.map_error(log_and_error(\n              _,\n              socket_state.socket,\n              socket_state.transport,\n            ))\n          })\n          |> result.map(fn(req_resp) {\n            let #(req, response) = req_resp\n            case response {\n              Response(\n                response: response.Response(body: BitBuilderBody(body), ..) as resp,\n              ) -> handle_bit_builder_body(resp, body, socket_state)\n              Response(\n                response: response.Response(body: Chunked(body), ..) as resp,\n              ) -> handle_chunked_body(resp, body, socket_state)\n              Response(\n                response: response.Response(body: FileBody(..), ..) as resp,\n              ) -> handle_file_body(resp, socket_state)\n              Upgrade(with_handler) ->\n                handle_upgrade(req, with_handler, socket_state)\n            }\n          })\n        }\n        |> result.unwrap_both\n    }\n  })\n}\n\nfn handle_websocket_message(\n  state: LoopState(State),\n  handler: websocket.WebsocketHandler,\n  msg: BitString,\n) -> actor.Next(LoopState(State)) {\n  case websocket.frame_from_message(state.socket, state.transport, msg) {\n    Ok(websocket.PingFrame(_, _)) -> {\n      let assert Ok(_) =\n        state.transport.send(\n          state.socket,\n          websocket.frame_to_bit_builder(websocket.PongFrame(0, <<>>)),\n        )\n      actor.Continue(state)\n    }\n    Ok(websocket.CloseFrame(..) as frame) -> {\n      let assert Ok(_) =\n        state.transport.send(\n          state.socket,\n          websocket.frame_to_bit_builder(frame),\n        )\n      let _ = case handler.on_close {\n        Some(func) -> func(state.sender)\n        _ -> Nil\n      }\n      actor.Stop(process.Normal)\n    }\n    Ok(websocket.PongFrame(..)) -> stop_normal\n    Ok(frame) ->\n      case frame {\n        websocket.TextFrame(_length, payload) -> {\n          let assert Ok(msg) = bit_string.to_string(payload)\n          websocket.TextMessage(msg)\n        }\n        // NOTE:  this doesn't need to be exhaustive since we already\n        // cover the cases above\n        _frame -> websocket.BinaryMessage(frame.payload)\n      }\n      |> fn(ws_msg) { rescue(fn() { handler.handler(ws_msg, state.sender) }) }\n      |> result.replace(actor.Continue(state))\n      |> result.map_error(fn(err) {\n        logger.error(err)\n        let _ = case handler.on_close {\n          Some(func) -> func(state.sender)\n          _ -> Nil\n        }\n        err\n      })\n      |> result.replace_error(stop_normal)\n      |> result.unwrap_both\n    Error(_) -> {\n      let _ = case handler.on_close {\n        Some(func) -> func(state.sender)\n        _ -> Nil\n      }\n      // TODO:  not normal\n      stop_normal\n    }\n  }\n}\n\nfn log_and_error(\n  error: erlang.Crash,\n  socket: Socket,\n  transport: Transport,\n) -> actor.Next(LoopState(State)) {\n  case error {\n    Exited(msg) | Thrown(msg) | Errored(msg) -> {\n      logger.error(error)\n      response.new(500)\n      |> response.set_body(bit_builder.from_bit_string(<<\n        \"Internal Server Error\":utf8,\n      >>))\n      |> response.prepend_header(\"content-length\", \"21\")\n      |> http.add_default_headers\n      |> encoder.to_bit_builder\n      |> transport.send(socket, _)\n      let _ = transport.close(socket)\n      actor.Stop(process.Abnormal(dynamic.unsafe_coerce(msg)))\n    }\n  }\n}\n\nfn handle_bit_builder_body(\n  resp: response.Response(HttpResponseBody),\n  body: BitBuilder,\n  state: LoopState(State),\n) -> actor.Next(LoopState(State)) {\n  resp\n  |> response.set_body(body)\n  |> http.add_default_headers\n  |> encoder.to_bit_builder\n  |> state.transport.send(state.socket, _)\n  |> result.map(fn(_sent) {\n    // If the handler explicitly says to close the connection, we should\n    // probably listen to them\n    case response.get_header(resp, \"connection\") {\n      Ok(\"close\") -> {\n        let _ = state.transport.close(state.socket)\n        stop_normal\n      }\n      _ -> {\n        // TODO:  this should be a configuration\n        let timer = process.send_after(state.sender, 10_000, Close)\n        actor.Continue(\n          LoopState(..state, data: State(..state.data, idle_timer: Some(timer))),\n        )\n      }\n    }\n  })\n  |> result.replace_error(stop_normal)\n  |> result.unwrap_both\n}\n\nexternal fn integer_to_list(int: Int, base: Int) -> String =\n  \"erlang\" \"integer_to_list\"\n\nfn int_to_hex(int: Int) -> String {\n  integer_to_list(int, 16)\n}\n\nfn handle_chunked_body(\n  resp: response.Response(HttpResponseBody),\n  body: Iterator(BitBuilder),\n  state: LoopState(State),\n) -> actor.Next(LoopState(State)) {\n  let headers = [#(\"transfer-encoding\", \"chunked\"), ..resp.headers]\n  let initial_payload = encoder.response_builder(resp.status, headers)\n\n  state.transport.send(state.socket, initial_payload)\n  |> result.then(fn(_ok) {\n    body\n    |> iterator.append(iterator.from_list([bit_builder.new()]))\n    |> iterator.try_fold(\n      Nil,\n      fn(_prev, chunk) {\n        let size = bit_builder.byte_size(chunk)\n        let encoded =\n          size\n          |> int_to_hex\n          |> bit_builder.from_string\n          |> bit_builder.append_string(\"\\r\\n\")\n          |> bit_builder.append_builder(chunk)\n          |> bit_builder.append_string(\"\\r\\n\")\n\n        state.transport.send(state.socket, encoded)\n      },\n    )\n  })\n  |> result.replace(actor.Continue(state))\n  |> result.unwrap(stop_normal)\n}\n\nfn handle_file_body(\n  resp: response.Response(HttpResponseBody),\n  state: LoopState(State),\n) -> actor.Next(LoopState(State)) {\n  let assert FileBody(file_descriptor, content_type, offset, length) = resp.body\n  resp\n  |> response.prepend_header(\"content-length\", int.to_string(length - offset))\n  |> response.prepend_header(\"content-type\", content_type)\n  |> response.set_body(bit_builder.new())\n  |> fn(r: response.Response(BitBuilder)) {\n    encoder.response_builder(resp.status, r.headers)\n  }\n  |> state.transport.send(state.socket, _)\n  |> result.map(fn(_) {\n    file.sendfile(file_descriptor, state.socket, offset, length, [])\n  })\n  |> result.replace(actor.Continue(state))\n  // TODO:  not normal\n  |> result.replace_error(stop_normal)\n  |> result.unwrap_both\n}\n\nfn handle_upgrade(\n  req: Request(Body),\n  handler: websocket.WebsocketHandler,\n  state: LoopState(State),\n) -> actor.Next(LoopState(State)) {\n  req\n  |> http.upgrade(state.socket, state.transport, _)\n  |> result.map(fn(_nil) {\n    let _ = case handler.on_init {\n      Some(func) -> func(state.sender)\n      _ -> Nil\n    }\n  })\n  |> result.replace(actor.Continue(\n    LoopState(\n      ..state,\n      data: State(..state.data, upgraded_handler: Some(handler)),\n    ),\n  ))\n  // TODO:  not normal\n  |> result.replace_error(stop_normal)\n  |> result.unwrap_both\n}\n\n/// Creates a standard HTTP handler service to pass to `mist.serve`\npub fn with(handler: Handler, max_body_limit: Int) -> LoopFn(State) {\n  let bad_request =\n    response.new(400)\n    |> response.set_body(bit_builder.new())\n  with_func(fn(req) {\n    case\n      request.get_header(req, \"content-length\"),\n      request.get_header(req, \"transfer-encoding\")\n    {\n      Ok(\"0\"), _ | Error(Nil), Error(Nil) ->\n        req\n        |> request.set_body(<<>>)\n        |> handler\n      _, Ok(\"chunked\") ->\n        req\n        |> http.read_body\n        |> result.map(handler)\n        |> result.unwrap(bad_request)\n      Ok(size), _ ->\n        size\n        |> int.parse\n        |> result.map(fn(size) {\n          case size > max_body_limit {\n            True ->\n              response.new(413)\n              |> response.set_body(bit_builder.new())\n              |> response.prepend_header(\"connection\", \"close\")\n            False ->\n              req\n              |> http.read_body\n              |> result.map(handler)\n              |> result.unwrap(bad_request)\n          }\n        })\n        |> result.unwrap(bad_request)\n    }\n    |> response.map(BitBuilderBody)\n    |> Response\n  })\n}\n" (Durability(0))    
2023-08-04T09:30:46.274001Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274009Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R161    
2023-08-04T09:30:46.274017Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(65)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/bit_string\nimport gleam/erlang/process.{Subject}\nimport gleam/list\nimport gleam/option.{Option}\nimport gleam/string\nimport glisten/handler.{HandlerMessage}\nimport glisten/socket.{Socket}\nimport glisten/socket/transport.{Transport}\n\npub type Message {\n  BinaryMessage(data: BitString)\n  TextMessage(data: String)\n}\n\npub type Handler =\n  fn(Message, Subject(HandlerMessage)) -> Result(Nil, Nil)\n\n// TODO:  there are other message types, AND ALSO will need to buffer across\n// multiple frames, potentially\npub type Frame {\n  // TODO:  should this include data?\n  CloseFrame(payload_length: Int, payload: BitString)\n  TextFrame(payload_length: Int, payload: BitString)\n  BinaryFrame(payload_length: Int, payload: BitString)\n  // We don't care about basicaly everything else for now\n  PingFrame(payload_length: Int, payload: BitString)\n  PongFrame(payload_length: Int, payload: BitString)\n}\n\nexternal fn crypto_exor(a: BitString, b: BitString) -> BitString =\n  \"crypto\" \"exor\"\n\nfn unmask_data(\n  data: BitString,\n  masks: List(BitString),\n  index: Int,\n  resp: BitString,\n) -> BitString {\n  case data {\n    <<>> -> resp\n    <<masked:bit_string-size(8), rest:bit_string>> -> {\n      let assert Ok(mask_value) = list.at(masks, index % 4)\n      let unmasked = crypto_exor(mask_value, masked)\n      unmask_data(\n        rest,\n        masks,\n        index + 1,\n        <<resp:bit_string, unmasked:bit_string>>,\n      )\n    }\n  }\n}\n\npub fn frame_from_message(\n  socket: Socket,\n  transport: Transport,\n  message: BitString,\n) -> Result(Frame, Nil) {\n  let assert <<_fin:1, rest:bit_string>> = message\n  let assert <<_reserved:3, rest:bit_string>> = rest\n  let assert <<opcode:int-size(4), rest:bit_string>> = rest\n  case opcode {\n    1 | 2 -> {\n      // mask\n      let assert <<1:1, rest:bit_string>> = rest\n      let assert <<payload_length:int-size(7), rest:bit_string>> = rest\n      let #(payload_length, rest) = case payload_length {\n        126 -> {\n          let assert <<length:int-size(16), rest:bit_string>> = rest\n          #(length, rest)\n        }\n        127 -> {\n          let assert <<length:int-size(64), rest:bit_string>> = rest\n          #(length, rest)\n        }\n        _ -> #(payload_length, rest)\n      }\n      let assert <<\n        mask1:bit_string-size(8),\n        mask2:bit_string-size(8),\n        mask3:bit_string-size(8),\n        mask4:bit_string-size(8),\n        rest:bit_string,\n      >> = rest\n      let data = case payload_length - bit_string.byte_size(rest) {\n        0 -> unmask_data(rest, [mask1, mask2, mask3, mask4], 0, <<>>)\n        need -> {\n          let assert Ok(needed) = transport.receive(socket, need)\n          rest\n          |> bit_string.append(needed)\n          |> unmask_data([mask1, mask2, mask3, mask4], 0, <<>>)\n        }\n      }\n      case opcode {\n        1 -> TextFrame(payload_length, data)\n        2 -> BinaryFrame(payload_length, data)\n      }\n      |> Ok\n    }\n    8 -> Ok(CloseFrame(payload_length: 0, payload: <<>>))\n  }\n}\n\npub fn frame_to_bit_builder(frame: Frame) -> BitBuilder {\n  case frame {\n    TextFrame(payload_length, payload) -> make_frame(1, payload_length, payload)\n    CloseFrame(payload_length, payload) ->\n      make_frame(8, payload_length, payload)\n    BinaryFrame(payload_length, payload) ->\n      make_frame(2, payload_length, payload)\n    PongFrame(payload_length, payload) ->\n      make_frame(10, payload_length, payload)\n    PingFrame(..) -> bit_builder.from_bit_string(<<>>)\n  }\n}\n\nfn make_frame(opcode: Int, length: Int, payload: BitString) -> BitBuilder {\n  let length_section = case length {\n    length if length > 65_535 -> <<127:7, length:int-size(64)>>\n    length if length >= 126 -> <<126:7, length:int-size(16)>>\n    _length -> <<length:7>>\n  }\n\n  <<1:1, 0:3, opcode:4, 0:1, length_section:bit_string, payload:bit_string>>\n  |> bit_builder.from_bit_string\n}\n\npub fn to_text_frame(data: BitString) -> BitBuilder {\n  let size = bit_string.byte_size(data)\n  frame_to_bit_builder(TextFrame(size, data))\n}\n\npub fn to_binary_frame(data: BitString) -> BitBuilder {\n  let size = bit_string.byte_size(data)\n  frame_to_bit_builder(BinaryFrame(size, data))\n}\n\nconst websocket_key = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\npub type ShaHash {\n  Sha\n}\n\npub external fn crypto_hash(hash: ShaHash, data: String) -> String =\n  \"crypto\" \"hash\"\n\npub external fn base64_encode(data: String) -> String =\n  \"base64\" \"encode\"\n\npub fn parse_key(key: String) -> String {\n  key\n  |> string.append(websocket_key)\n  |> crypto_hash(Sha, _)\n  |> base64_encode\n}\n\npub type EventHandler =\n  fn(Subject(HandlerMessage)) -> Nil\n\npub type WebsocketHandler {\n  WebsocketHandler(\n    on_close: Option(EventHandler),\n    on_init: Option(EventHandler),\n    handler: Handler,\n  )\n}\n" (Durability(0))    
2023-08-04T09:30:46.274090Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274098Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R162    
2023-08-04T09:30:46.274107Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(66)) = "import gleam/erlang/charlist.{Charlist}\n\nexternal fn log_error(format: Charlist, data: any) -> Nil =\n  \"logger\" \"error\"\n\npub fn error(data: any) -> Nil {\n  log_error(charlist.from_string(\"~tp\"), [data])\n}\n" (Durability(0))    
2023-08-04T09:30:46.274118Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274126Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R163    
2023-08-04T09:30:46.274134Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(67)) = "import gleam/bit_builder.{BitBuilder}\nimport gleam/http.{Header}\nimport gleam/http/response.{Response}\nimport gleam/int\nimport gleam/list\n\n/// Turns an HTTP response into a TCP message\npub fn to_bit_builder(resp: Response(BitBuilder)) -> BitBuilder {\n  resp.status\n  |> response_builder(resp.headers)\n  |> bit_builder.append_builder(resp.body)\n}\n\npub fn response_builder(status: Int, headers: List(Header)) -> BitBuilder {\n  let status_string =\n    status\n    |> int.to_string\n    |> bit_builder.from_string\n    |> bit_builder.append(<<\" \":utf8>>)\n    |> bit_builder.append(status_to_bit_string(status))\n\n  bit_builder.new()\n  |> bit_builder.append(<<\"HTTP/1.1 \":utf8>>)\n  |> bit_builder.append_builder(status_string)\n  |> bit_builder.append(<<\"\\r\\n\":utf8>>)\n  |> bit_builder.append_builder(encode_headers(headers))\n  |> bit_builder.append(<<\"\\r\\n\":utf8>>)\n}\n\npub fn status_to_bit_string(status: Int) -> BitString {\n  // Obviously nowhere near exhaustive...\n  case status {\n    100 -> <<\"Continue\":utf8>>\n    101 -> <<\"Switching Protocols\":utf8>>\n    103 -> <<\"Early Hints\":utf8>>\n    200 -> <<\"OK\":utf8>>\n    201 -> <<\"Created\":utf8>>\n    202 -> <<\"Accepted\":utf8>>\n    203 -> <<\"Non-Authoritative Information\":utf8>>\n    204 -> <<\"No Content\":utf8>>\n    205 -> <<\"Reset Content\":utf8>>\n    206 -> <<\"Partial Content\":utf8>>\n    300 -> <<\"Multiple Choices\":utf8>>\n    301 -> <<\"Moved Permanently\":utf8>>\n    302 -> <<\"Found\":utf8>>\n    303 -> <<\"See Other\":utf8>>\n    304 -> <<\"Not Modified\":utf8>>\n    307 -> <<\"Temporary Redirect\":utf8>>\n    308 -> <<\"Permanent Redirect\":utf8>>\n    400 -> <<\"Bad Request\":utf8>>\n    401 -> <<\"Unauthorized\":utf8>>\n    402 -> <<\"Payment Required\":utf8>>\n    403 -> <<\"Forbidden\":utf8>>\n    404 -> <<\"Not Found\":utf8>>\n    405 -> <<\"Method Not Allowed\":utf8>>\n    406 -> <<\"Not Acceptable\":utf8>>\n    407 -> <<\"Proxy Authentication Required\":utf8>>\n    408 -> <<\"Request Timeout\":utf8>>\n    409 -> <<\"Conflict\":utf8>>\n    410 -> <<\"Gone\":utf8>>\n    411 -> <<\"Length Required\":utf8>>\n    412 -> <<\"Precondition Failed\":utf8>>\n    413 -> <<\"Payload Too Large\":utf8>>\n    414 -> <<\"URI Too Long\":utf8>>\n    415 -> <<\"Unsupported Media Type\":utf8>>\n    416 -> <<\"Range Not Satisfiable\":utf8>>\n    417 -> <<\"Expectation Failed\":utf8>>\n    418 -> <<\"I'm a teapot\":utf8>>\n    422 -> <<\"Unprocessable Entity\":utf8>>\n    425 -> <<\"Too Early\":utf8>>\n    426 -> <<\"Upgrade Required\":utf8>>\n    428 -> <<\"Precondition Required\":utf8>>\n    429 -> <<\"Too Many Requests\":utf8>>\n    431 -> <<\"Request Header Fields Too Large\":utf8>>\n    451 -> <<\"Unavailable For Legal Reasons\":utf8>>\n    500 -> <<\"Internal Server Error\":utf8>>\n    501 -> <<\"Not Implemented\":utf8>>\n    502 -> <<\"Bad Gateway\":utf8>>\n    503 -> <<\"Service Unavailable\":utf8>>\n    504 -> <<\"Gateway Timeout\":utf8>>\n    505 -> <<\"HTTP Version Not Supported\":utf8>>\n    506 -> <<\"Variant Also Negotiates\":utf8>>\n    507 -> <<\"Insufficient Storage\":utf8>>\n    508 -> <<\"Loop Detected\":utf8>>\n    510 -> <<\"Not Extended\":utf8>>\n    511 -> <<\"Network Authentication Required\":utf8>>\n  }\n}\n\npub fn encode_headers(headers: List(Header)) -> BitBuilder {\n  list.fold(\n    headers,\n    bit_builder.new(),\n    fn(builder, tup) {\n      let #(header, value) = tup\n\n      builder\n      |> bit_builder.append_string(header)\n      |> bit_builder.append(<<\": \":utf8>>)\n      |> bit_builder.append_string(value)\n      |> bit_builder.append(<<\"\\r\\n\":utf8>>)\n    },\n  )\n}\n" (Durability(0))    
2023-08-04T09:30:46.274198Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274206Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R164    
2023-08-04T09:30:46.274215Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(68)) = "//// Nakai has several \"builders\" that can be used.\n//// - A `document` builder (the recommend one) that renders a full HTML document,\n////   does a little magic to dedepulicate `<head>` elements, and some other things\n////   that generally fit the theme of \"rendering a full, valid, HTML document\"\n//// - An `inline` builder that should mostly be used for snippets, and partial bits of\n////   HTML that will be inlined into a full document; hence the name. It renders things\n////   much more literally. If you tell it to give you a `<head>` element inside a\n////   `<p>`, it will, as an example.\n//// - A future experimental DOM renderer (meant for use in the browser) that isn't\n////   actually done yet.\n\nimport gleam/string_builder.{StringBuilder}\nimport nakai/html.{Node}\nimport nakai/internal/render\n\n/// Renders a full HTML document from the given tree, into a `StringBuilder`.\n/// ## Examples\n/// ```gleam\n/// html.div_text([], \"hello, lucy!\")\n/// |> nakai.to_string_builder()\n/// ```\npub fn to_string_builder(tree: Node(a)) -> StringBuilder {\n  render.render_document(tree)\n}\n\n/// Renders a full HTML document from the given tree, into a `String`.\n/// ## Examples\n/// ```gleam\n/// html.div_text([], \"hello, lucy!\")\n/// |> nakai.to_string()\n/// ```\npub fn to_string(tree: Node(a)) -> String {\n  render.render_document(tree)\n  |> string_builder.to_string()\n}\n\n/// Renders only the provided HTML, exactly as provided (disables `<head>`\n/// deduplication, etc.), into a `StringBuilder`. Useful for generating snippets\n/// instead of whole pages.\n/// ## Examples\n/// ```gleam\n/// html.div_text([], \"hello, lucy!\")\n/// |> nakai.to_inline_string_builder()\n/// ```\npub fn to_inline_string_builder(tree: Node(a)) -> StringBuilder {\n  render.render_inline(tree)\n}\n\n/// Renders only the provided HTML, exactly as provided (disables `<head>`\n/// deduplication, etc.), into a `String`. Useful for generating snippets instead\n/// of whole pages.\n/// ## Examples\n/// ```gleam\n/// html.div_text([], \"hello, lucy!\")\n/// |> nakai.to_inline_string()\n/// ```\npub fn to_inline_string(tree: Node(a)) -> String {\n  render.render_inline(tree)\n  |> string_builder.to_string()\n}\n" (Durability(0))    
2023-08-04T09:30:46.274260Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274268Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R165    
2023-08-04T09:30:46.274277Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(69)) = "import nakai/html/attrs.{Attr}\n\npub fn click(script: String) -> Attr(a) {\n  Attr(name: \"onclick\", value: script)\n}\n" (Durability(0))    
2023-08-04T09:30:46.274287Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274295Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R166    
2023-08-04T09:30:46.274304Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(70)) = "import nakai/html.{Element, LeafElement, Node}\nimport nakai/html/attrs.{Attr}\n\npub fn slot(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"slot\", attrs: attrs)\n}\n\npub fn template(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"template\", attrs: attrs, children: children)\n}\n" (Durability(0))    
2023-08-04T09:30:46.274316Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274324Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R167    
2023-08-04T09:30:46.274333Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(71)) = "import nakai/html\nimport nakai/html/attrs\n\npub fn title(title: String) {\n  html.Head([html.title(title)])\n}\n\npub fn link(rel rel: String, href href: String) {\n  html.Head([html.link([attrs.rel(rel), attrs.href(href)])])\n}\n\npub fn meta(name name: String, content content: String) {\n  html.Head([html.meta([attrs.name(name), attrs.content(content)])])\n}\n\npub fn http_equiv(header: String, content content: String) {\n  html.Head([html.meta([attrs.http_equiv(header), attrs.content(content)])])\n}\n\npub fn charset(charset: String) {\n  html.Head([html.meta([attrs.charset(charset)])])\n}\n" (Durability(0))    
2023-08-04T09:30:46.274347Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274355Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R168    
2023-08-04T09:30:46.274364Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(72)) = "import gleam/option.{Option}\nimport gleam/list\nimport gleam/string_builder.{StringBuilder}\n\npub const encoding = \"\n<meta charset=\\\"utf-8\\\" />\n<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\" />\n\"\n\npub type Document {\n  Document(\n    doctype: Option(String),\n    html_attrs: StringBuilder,\n    body_attrs: StringBuilder,\n    head: StringBuilder,\n    body: StringBuilder,\n    scripts: List(String),\n  )\n}\n\npub fn new() {\n  Document(\n    doctype: option.None,\n    html_attrs: string_builder.new(),\n    body_attrs: string_builder.new(),\n    head: string_builder.new(),\n    body: string_builder.new(),\n    scripts: [],\n  )\n}\n\npub fn merge(self: Document, new: Document) -> Document {\n  Document(\n    // Overwrite the doctype with a newer one, unless the newer one is `None`\n    doctype: option.or(new.doctype, self.doctype),\n    html_attrs: string_builder.append_builder(self.html_attrs, new.html_attrs),\n    body_attrs: string_builder.append_builder(self.body_attrs, new.body_attrs),\n    head: string_builder.append_builder(self.head, new.head),\n    body: string_builder.append_builder(self.body, new.body),\n    scripts: list.append(self.scripts, new.scripts),\n  )\n}\n\npub fn concat(docs: List(Document)) -> Document {\n  docs\n  |> list.fold(new(), merge)\n}\n\npub fn from_doctype(doctype: String) -> Document {\n  Document(..new(), doctype: option.Some(doctype))\n}\n\npub fn append_html_attrs(self: Document, html_attrs: StringBuilder) -> Document {\n  Document(\n    ..self,\n    html_attrs: string_builder.append_builder(self.html_attrs, html_attrs),\n  )\n}\n\npub fn append_body_attrs(self: Document, body_attrs: StringBuilder) -> Document {\n  Document(\n    ..self,\n    body_attrs: string_builder.append_builder(self.body_attrs, body_attrs),\n  )\n}\n\npub fn from_head(head: StringBuilder) -> Document {\n  Document(..new(), head: head)\n}\n\npub fn append_head(self: Document, head: StringBuilder) -> Document {\n  Document(..self, head: string_builder.append_builder(self.head, head))\n}\n\npub fn from_body(body: StringBuilder) -> Document {\n  Document(..new(), body: body)\n}\n\npub fn append_body(self: Document, body: StringBuilder) -> Document {\n  Document(..self, body: string_builder.append_builder(self.body, body))\n}\n\npub fn replace_body(self: Document, body: StringBuilder) -> Document {\n  Document(..self, body: body)\n}\n\npub fn from_script(script: String) -> Document {\n  Document(..new(), scripts: [script])\n}\n\npub fn into_head(state: Document) -> Document {\n  Document(\n    ..state,\n    head: string_builder.append_builder(state.head, state.body),\n    body: string_builder.new(),\n  )\n}\n" (Durability(0))    
2023-08-04T09:30:46.274409Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274418Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R169    
2023-08-04T09:30:46.274427Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(73)) = "import gleam/list\nimport gleam/option\nimport gleam/string_builder.{StringBuilder}\nimport gleam/string\nimport nakai/html.{Node}\nimport nakai/html/attrs.{Attr, Event}\nimport nakai/internal/document.{Document}\n\ntype Builder(a, output) {\n  Builder(map: fn(Node(a)) -> output, fold: fn(List(output)) -> output)\n}\n\nconst document_builder = Builder(\n  map: render_document_node,\n  fold: document.concat,\n)\n\nconst inline_builder = Builder(\n  map: render_inline_node,\n  fold: string_builder.concat,\n)\n\nfn render_doctype(doctype: String) -> StringBuilder {\n  string_builder.from_strings([\"<!DOCTYPE \", doctype, \">\\n\"])\n}\n\nfn render_children(\n  children: List(Node(a)),\n  builder: Builder(a, output),\n) -> output {\n  children\n  |> list.map(builder.map)\n  |> builder.fold()\n}\n\nfn render_attrs(attrs: List(Attr(a))) -> StringBuilder {\n  attrs\n  |> list.map(render_attr)\n  |> list.fold(string_builder.new(), string_builder.append_builder)\n}\n\nfn render_attr(attr: Attr(a)) -> StringBuilder {\n  case attr {\n    Attr(name, value) -> {\n      let sanitized_value =\n        value\n        |> string.replace(\"\\\"\", \"&quot;\")\n        |> string.replace(\">\", \"&gt;\")\n      string_builder.from_strings([\" \", name, \"=\\\"\", sanitized_value, \"\\\"\"])\n    }\n    Event(_name, _action) -> {\n      string_builder.new()\n    }\n  }\n}\n\nfn render_document_node(tree: Node(a)) -> Document {\n  case tree {\n    html.Doctype(doctype) -> document.from_doctype(doctype)\n\n    html.Html(attrs, children) ->\n      render_children(children, document_builder)\n      |> document.append_html_attrs(render_attrs(attrs))\n\n    html.Head(children) ->\n      render_children(children, document_builder)\n      |> document.into_head()\n\n    html.Body(attrs, children) ->\n      render_children(children, document_builder)\n      |> document.append_body_attrs(render_attrs(attrs))\n\n    html.Fragment(children) -> render_children(children, document_builder)\n\n    html.Element(tag, attrs, children) -> {\n      let child_document = render_children(children, document_builder)\n      string_builder.concat([\n        string_builder.from_strings([\"<\", tag]),\n        render_attrs(attrs),\n        string_builder.from_string(\">\"),\n        child_document.body,\n        string_builder.from_strings([\"</\", tag, \">\"]),\n      ])\n      |> document.replace_body(child_document, _)\n    }\n\n    html.LeafElement(tag, attrs) ->\n      string_builder.concat([\n        string_builder.from_strings([\"<\", tag]),\n        render_attrs(attrs),\n        string_builder.from_string(\" />\"),\n      ])\n      |> document.from_body()\n\n    html.Comment(content) -> {\n      let content =\n        content\n        |> string.replace(\"-->\", \"\")\n      string_builder.from_strings([\"<!-- \", content, \" -->\"])\n      |> document.from_body()\n    }\n\n    html.Text(content) ->\n      string_builder.from_string(content)\n      |> string_builder.replace(\"&\", \"&amp;\")\n      |> string_builder.replace(\"<\", \"&lt;\")\n      |> string_builder.replace(\">\", \"&gt;\")\n      |> document.from_body()\n\n    html.UnsafeText(content) ->\n      string_builder.from_string(content)\n      |> document.from_body()\n\n    html.Script(script) -> document.from_script(script)\n\n    html.Nothing -> document.new()\n  }\n}\n\nfn render_inline_node(tree: Node(a)) -> StringBuilder {\n  case tree {\n    html.Doctype(doctype) -> render_doctype(doctype)\n\n    html.Html(attrs, children) ->\n      render_inline_node(html.Element(\"html\", attrs, children))\n\n    html.Head(children) ->\n      render_inline_node(html.Element(\"head\", [], children))\n\n    html.Body(attrs, children) ->\n      render_inline_node(html.Element(\"body\", attrs, children))\n\n    html.Fragment(children) -> render_children(children, inline_builder)\n\n    html.Element(tag, attrs, children) -> {\n      let child_document = render_children(children, inline_builder)\n      string_builder.concat([\n        string_builder.from_strings([\"<\", tag]),\n        render_attrs(attrs),\n        string_builder.from_string(\">\"),\n        child_document,\n        string_builder.from_strings([\"</\", tag, \">\"]),\n      ])\n    }\n\n    html.LeafElement(tag, attrs) ->\n      string_builder.concat([\n        string_builder.from_strings([\"<\", tag]),\n        render_attrs(attrs),\n        string_builder.from_string(\" />\"),\n      ])\n\n    html.Comment(content) -> {\n      let content =\n        content\n        |> string.replace(\"-->\", \"\")\n      string_builder.from_strings([\"<!-- \", content, \" -->\"])\n    }\n\n    html.Text(content) ->\n      string_builder.from_string(content)\n      |> string_builder.replace(\"&\", \"&amp;\")\n      |> string_builder.replace(\"<\", \"&lt;\")\n      |> string_builder.replace(\">\", \"&gt;\")\n\n    html.UnsafeText(content) -> string_builder.from_string(content)\n\n    html.Script(script) ->\n      render_inline_node(html.Element(\"script\", [], [html.Text(script)]))\n\n    html.Nothing -> string_builder.new()\n  }\n}\n\nfn render_script(script: String) -> StringBuilder {\n  string_builder.concat([\n    string_builder.from_string(\"<script>\"),\n    string_builder.from_string(script),\n    string_builder.from_string(\"</script>\\n\"),\n  ])\n}\n\nfn render_scripts(scripts: List(String)) -> StringBuilder {\n  scripts\n  |> list.map(render_script)\n  |> string_builder.concat()\n}\n\npub fn render_document(tree: Node(a)) -> StringBuilder {\n  let result = render_document_node(tree)\n  string_builder.concat([\n    render_doctype(\n      result.doctype\n      |> option.unwrap(\"html\"),\n    ),\n    string_builder.from_string(\"<html\"),\n    result.html_attrs,\n    string_builder.from_string(\">\\n<head>\" <> document.encoding),\n    result.head,\n    string_builder.from_string(\"</head>\\n<body\"),\n    result.body_attrs,\n    string_builder.from_string(\">\"),\n    result.body,\n    render_scripts(result.scripts),\n    string_builder.from_string(\"</body>\\n</html>\\n\"),\n  ])\n}\n\npub fn render_inline(tree: Node(a)) -> StringBuilder {\n  render_inline_node(tree)\n}\n" (Durability(0))    
2023-08-04T09:30:46.274512Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274520Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R170    
2023-08-04T09:30:46.274529Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(74)) = "\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * THIS FILE IS GENERATED. DO NOT EDIT IT.                                             *\n// * You're probably looking for ./codegen/attrs_prelude.gleam, or ./codegen/attrs.json. *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n\n\n\npub type Attr(a) {\n  Attr(name: String, value: String)\n  Event(name: String, action: a)\n}\n\npub fn data(name: String, value: String) -> Attr(a) {\n  Attr(name: \"data-\" <> name, value: value)\n}\n\npub fn accept(value: String) -> Attr(a) {\n  Attr(name: \"accept\", value: value)\n}\n\npub fn accept_charset(value: String) -> Attr(a) {\n  Attr(name: \"accept-charset\", value: value)\n}\n\npub fn action(value: String) -> Attr(a) {\n  Attr(name: \"action\", value: value)\n}\n\npub fn alt(value: String) -> Attr(a) {\n  Attr(name: \"alt\", value: value)\n}\n\npub fn async() -> Attr(a) {\n  Attr(name: \"async\", value: \"true\")\n}\n\npub fn autocapitalize(value: String) -> Attr(a) {\n  Attr(name: \"autocapitalize\", value: value)\n}\n\npub fn autocomplete(value: String) -> Attr(a) {\n  Attr(name: \"autocomplete\", value: value)\n}\n\npub fn autofocus() -> Attr(a) {\n  Attr(name: \"autofocus\", value: \"true\")\n}\n\npub fn autoplay() -> Attr(a) {\n  Attr(name: \"autoplay\", value: \"true\")\n}\n\npub fn capture(value: String) -> Attr(a) {\n  Attr(name: \"capture\", value: value)\n}\n\npub fn charset(value: String) -> Attr(a) {\n  Attr(name: \"charset\", value: value)\n}\n\npub fn checked() -> Attr(a) {\n  Attr(name: \"checked\", value: \"true\")\n}\n\npub fn cite(value: String) -> Attr(a) {\n  Attr(name: \"cite\", value: value)\n}\n\npub fn class(value: String) -> Attr(a) {\n  Attr(name: \"class\", value: value)\n}\n\npub fn content(value: String) -> Attr(a) {\n  Attr(name: \"content\", value: value)\n}\n\npub fn contenteditable() -> Attr(a) {\n  Attr(name: \"contenteditable\", value: \"true\")\n}\n\npub fn crossorigin() -> Attr(a) {\n  Attr(name: \"crossorigin\", value: \"true\")\n}\n\npub fn defer() -> Attr(a) {\n  Attr(name: \"defer\", value: \"true\")\n}\n\npub fn disabled() -> Attr(a) {\n  Attr(name: \"disabled\", value: \"true\")\n}\n\npub fn draggable() -> Attr(a) {\n  Attr(name: \"draggable\", value: \"true\")\n}\n\npub fn for(value: String) -> Attr(a) {\n  Attr(name: \"for\", value: value)\n}\n\npub fn formaction(value: String) -> Attr(a) {\n  Attr(name: \"formaction\", value: value)\n}\n\npub fn height(value: String) -> Attr(a) {\n  Attr(name: \"height\", value: value)\n}\n\npub fn href(value: String) -> Attr(a) {\n  Attr(name: \"href\", value: value)\n}\n\npub fn http_equiv(value: String) -> Attr(a) {\n  Attr(name: \"http-equiv\", value: value)\n}\n\npub fn id(value: String) -> Attr(a) {\n  Attr(name: \"id\", value: value)\n}\n\npub fn integrity(value: String) -> Attr(a) {\n  Attr(name: \"integrity\", value: value)\n}\n\npub fn lang(value: String) -> Attr(a) {\n  Attr(name: \"lang\", value: value)\n}\n\npub fn loop() -> Attr(a) {\n  Attr(name: \"loop\", value: \"true\")\n}\n\npub fn method(value: String) -> Attr(a) {\n  Attr(name: \"method\", value: value)\n}\n\npub fn name(value: String) -> Attr(a) {\n  Attr(name: \"name\", value: value)\n}\n\npub fn placeholder(value: String) -> Attr(a) {\n  Attr(name: \"placeholder\", value: value)\n}\n\npub fn preload() -> Attr(a) {\n  Attr(name: \"preload\", value: \"true\")\n}\n\npub fn property(value: String) -> Attr(a) {\n  Attr(name: \"property\", value: value)\n}\n\npub fn readonly() -> Attr(a) {\n  Attr(name: \"readonly\", value: \"true\")\n}\n\npub fn rel(value: String) -> Attr(a) {\n  Attr(name: \"rel\", value: value)\n}\n\npub fn selected() -> Attr(a) {\n  Attr(name: \"selected\", value: \"true\")\n}\n\npub fn src(value: String) -> Attr(a) {\n  Attr(name: \"src\", value: value)\n}\n\npub fn style(value: String) -> Attr(a) {\n  Attr(name: \"style\", value: value)\n}\n\npub fn tabindex(value: String) -> Attr(a) {\n  Attr(name: \"tabindex\", value: value)\n}\n\npub fn target(value: String) -> Attr(a) {\n  Attr(name: \"target\", value: value)\n}\n\npub fn title(value: String) -> Attr(a) {\n  Attr(name: \"title\", value: value)\n}\n\npub fn type_(value: String) -> Attr(a) {\n  Attr(name: \"type\", value: value)\n}\n\npub fn value(value: String) -> Attr(a) {\n  Attr(name: \"value\", value: value)\n}\n\npub fn width(value: String) -> Attr(a) {\n  Attr(name: \"width\", value: value)\n}\n" (Durability(0))    
2023-08-04T09:30:46.274600Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.274608Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R171    
2023-08-04T09:30:46.274617Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::input: FileContentQuery(FileId(75)) = "\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * THIS FILE IS GENERATED. DO NOT EDIT IT.                                             *\n// * You're probably looking for ./codegen/html_prelude.gleam, or ./codegen/html.json.   *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n\n\n\nimport nakai/html/attrs.{Attr}\n\npub type Node(a) {\n  /// Can be used anywhere in the document, and will set the doctype of the document\n  /// being rendered. Usually not necessary, as documents have a default of `<!DOCTYPE html>`.\n  /// ## Example\n  /// ```gleam\n  /// html.Doctype(\"html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\"\")\n  /// ```\n  Doctype(content: String)\n  /// Used for setting attributes on the root `<html>` element of the document. Children\n  /// will be rendered in-place, equivalent to using `html.Fragment(children)`.\n  /// ## Example\n  /// ```gleam\n  /// html.Html([attrs.lang(\"en-US\")], [\n  ///   ...\n  /// ])\n  /// ```\n  Html(attrs: List(Attr(a)), children: List(Node(a)))\n  /// Used for placing content in the `<head>` of the document. Useful for elements like\n  /// `<meta>`, `<title>`, `<link>`, etc.\n  /// ## Example\n  /// ```gleam\n  /// html.Fragment([\n  ///   html.Head([\n  ///     html.title(\"List of puppies\")\n  ///   ]),\n  ///   html.div([], [\n  ///     ...\n  ///   ])\n  /// ])\n  /// ```\n  Head(children: List(Node(a)))\n  /// Used for setting attributes on the `<body>` element of the document. Children\n  /// will be rendered in-place, equivalent to using `html.Fragment(children)`.\n  /// ## Example\n  /// ```gleam\n  /// html.Body([attrs.class(\"dark-mode\")], [\n  ///   ...\n  /// ])\n  /// ```\n  Body(attrs: List(Attr(a)), children: List(Node(a)))\n  /// An \"transparent\" container that will render it's children, but does not add anything\n  /// itself to the document. If you've ever used `React.Fragment` or `<>` and `</>` in\n  /// JSX/React, this is that.\n  /// ## Example\n  /// ```gleam\n  /// html.ul([], [\n  ///   // some puppies are hard-coded\n  ///   html.li_text([], \"August\"),\n  ///   // some are loaded from a server\n  ///   html.Fragment(puppies_fetched_from_api |> list.map(html.li_text([], _)))\n  /// ])\n  /// // <ul>\n  /// //   <li>August</li>\n  /// //   <li>Dot</li>\n  /// //   <li>Mody</li>\n  /// //   <li>Spot</li>\n  /// //   <li>Toby</li>\n  /// // </ul>\n  /// ```\n  Fragment(children: List(Node(a)))\n  /// An HTML element. You shouldn't need to reach for this very often, but it can be a\n  /// handy escape hatch if there isn't a shorthand function for the element type you need.\n  /// ## Example\n  /// ```gleam\n  /// // bad example, pls use `html.div`\n  /// html.Element(\"div\", [], [html.Text(\"hello, lucy!\")])\n  /// ```\n  Element(tag: String, attrs: List(Attr(a)), children: List(Node(a)))\n  /// An HTML element, but that does not have any children, and should be self closing.\n  /// Similarly to `Element`, you shouldn't really need this, except as an escape hatch\n  /// if there isn't a shorthand function for the element type you need.\n  /// ## Example\n  /// ```gleam\n  /// // bad example, pls use `html.link`\n  /// html.LeafElement(\"link\", [attrs.rel(\"stylesheet\"), attrs.href(...)])\n  /// ```\n  LeafElement(tag: String, attrs: List(Attr(a)))\n  /// An HTML comment, which will be included in the document.\n  /// ## Example\n  /// ```gleam\n  /// html.Comment(\"You've uncovered my secrets!\")\n  /// // <!-- You've uncovered my secrets! -->\n  /// ```\n  Comment(content: String)\n  /// Some plain text to include in the document. The provided text will be escaped, to\n  /// make it safe to include in the document.\n  /// ## Example\n  /// ```gleam\n  /// html.Text(\"hello, lucy!\")\n  /// // hello, lucy!\n  /// ```\n  /// ```gleam\n  /// // Time to trust some unvalidated user input! :^)\n  /// html.div_text([], \"<script>alert('pwned');</script>\")\n  /// // <div>&lt;script&gt;alert('pwned');&lt;/script&gt;</div>\n  /// ```\n  Text(content: String)\n  /// The dangerous cousin of `Text`. This will render the provided text as-is, without\n  /// any santization. Good for things like including some HTML you just generated from\n  /// a Markdown file. Bad for things like `$_GET['search']`.\n  /// ## Example\n  /// ```gleam\n  /// html.Text(\"hello, lucy!\")\n  /// // hello, lucy!\n  /// ```\n  /// ```gleam\n  /// // Time to trust some unvalidated user input! :^)\n  /// html.div([], [html.UnsafeText(\"<script>alert('pwned');</script>\")])\n  /// // <div><script>alert('pwned');</script></div>\n  /// // Oh no, we just got got! D:\n  /// ```\n  UnsafeText(content: String)\n  /// Add some JavaScript to your page! Scripts will always be inserted at the end of the\n  /// page, regardless of where in the document the `Script` node is, so that your content\n  /// loads first.\n  /// ## Example\n  /// ```gleam\n  /// html.Script(\"alert('hello, lucy!')\")\n  /// ```\n  Script(script: String)\n  /// Renders absolutely nothing. For when you may or may not have something to render,\n  /// and need a way to say \"I've got nothing.\"\n  /// ## Example\n  /// ```gleam\n  /// html.div([], [\n  ///   case my_cool_feature {\n  ///     Enabled -> super_cool_stuff()\n  ///     Disabled -> html.Nothing\n  ///   }\n  /// ])\n  Nothing\n}\n\n/// The HTML [`<title>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title) element\npub fn title(text: String) -> Node(a) {\n  Element(\"title\", [], [Text(text)])\n}\n\n/// The [HTML `<a>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a)\npub fn a(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"a\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.a(attrs, children: [html.Text(text)])`\npub fn a_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"a\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<abbr>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr)\npub fn abbr(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"abbr\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.abbr(attrs, children: [html.Text(text)])`\npub fn abbr_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"abbr\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<address>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address)\npub fn address(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"address\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.address(attrs, children: [html.Text(text)])`\npub fn address_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"address\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<area />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area)\npub fn area(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"area\", attrs: attrs)\n}\n\n/// The [HTML `<article>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article)\npub fn article(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"article\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.article(attrs, children: [html.Text(text)])`\npub fn article_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"article\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<aside>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside)\npub fn aside(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"aside\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.aside(attrs, children: [html.Text(text)])`\npub fn aside_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"aside\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<audio>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio)\npub fn audio(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"audio\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.audio(attrs, children: [html.Text(text)])`\npub fn audio_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"audio\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<b>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b)\npub fn b(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"b\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.b(attrs, children: [html.Text(text)])`\npub fn b_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"b\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<base />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base)\npub fn base(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"base\", attrs: attrs)\n}\n\n/// The [HTML `<bdi>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdi)\npub fn bdi(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"bdi\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.bdi(attrs, children: [html.Text(text)])`\npub fn bdi_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"bdi\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<bdo>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo)\npub fn bdo(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"bdo\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.bdo(attrs, children: [html.Text(text)])`\npub fn bdo_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"bdo\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<blockquote>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote)\npub fn blockquote(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"blockquote\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.blockquote(attrs, children: [html.Text(text)])`\npub fn blockquote_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"blockquote\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<br />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br)\npub fn br(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"br\", attrs: attrs)\n}\n\n/// The [HTML `<button>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button)\npub fn button(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"button\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.button(attrs, children: [html.Text(text)])`\npub fn button_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"button\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<canvas>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)\npub fn canvas(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"canvas\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.canvas(attrs, children: [html.Text(text)])`\npub fn canvas_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"canvas\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<caption>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption)\npub fn caption(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"caption\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.caption(attrs, children: [html.Text(text)])`\npub fn caption_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"caption\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<cite>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite)\npub fn cite(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"cite\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.cite(attrs, children: [html.Text(text)])`\npub fn cite_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"cite\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<code>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code)\npub fn code(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"code\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.code(attrs, children: [html.Text(text)])`\npub fn code_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"code\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<col>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col)\npub fn col(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"col\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.col(attrs, children: [html.Text(text)])`\npub fn col_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"col\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<colgroup>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup)\npub fn colgroup(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"colgroup\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.colgroup(attrs, children: [html.Text(text)])`\npub fn colgroup_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"colgroup\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<data>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/data)\npub fn data(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"data\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.data(attrs, children: [html.Text(text)])`\npub fn data_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"data\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<datalist>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist)\npub fn datalist(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"datalist\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.datalist(attrs, children: [html.Text(text)])`\npub fn datalist_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"datalist\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<dd>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd)\npub fn dd(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"dd\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.dd(attrs, children: [html.Text(text)])`\npub fn dd_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"dd\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<del>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del)\npub fn del(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"del\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.del(attrs, children: [html.Text(text)])`\npub fn del_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"del\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<details>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details)\npub fn details(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"details\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.details(attrs, children: [html.Text(text)])`\npub fn details_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"details\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<dfn>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn)\npub fn dfn(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"dfn\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.dfn(attrs, children: [html.Text(text)])`\npub fn dfn_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"dfn\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<dialog>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog)\npub fn dialog(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"dialog\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.dialog(attrs, children: [html.Text(text)])`\npub fn dialog_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"dialog\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<div>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div)\npub fn div(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"div\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.div(attrs, children: [html.Text(text)])`\npub fn div_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"div\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<dl>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl)\npub fn dl(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"dl\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.dl(attrs, children: [html.Text(text)])`\npub fn dl_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"dl\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<dt>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt)\npub fn dt(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"dt\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.dt(attrs, children: [html.Text(text)])`\npub fn dt_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"dt\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<em>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em)\npub fn em(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"em\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.em(attrs, children: [html.Text(text)])`\npub fn em_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"em\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<embed>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed)\npub fn embed(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"embed\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.embed(attrs, children: [html.Text(text)])`\npub fn embed_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"embed\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<fieldset>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset)\npub fn fieldset(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"fieldset\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.fieldset(attrs, children: [html.Text(text)])`\npub fn fieldset_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"fieldset\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<figcaption>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption)\npub fn figcaption(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"figcaption\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.figcaption(attrs, children: [html.Text(text)])`\npub fn figcaption_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"figcaption\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<figure>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure)\npub fn figure(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"figure\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.figure(attrs, children: [html.Text(text)])`\npub fn figure_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"figure\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<footer>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer)\npub fn footer(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"footer\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.footer(attrs, children: [html.Text(text)])`\npub fn footer_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"footer\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<form>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form)\npub fn form(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"form\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.form(attrs, children: [html.Text(text)])`\npub fn form_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"form\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<h1>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1)\npub fn h1(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"h1\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.h1(attrs, children: [html.Text(text)])`\npub fn h1_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"h1\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<h2>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2)\npub fn h2(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"h2\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.h2(attrs, children: [html.Text(text)])`\npub fn h2_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"h2\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<h3>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3)\npub fn h3(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"h3\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.h3(attrs, children: [html.Text(text)])`\npub fn h3_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"h3\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<h4>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4)\npub fn h4(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"h4\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.h4(attrs, children: [html.Text(text)])`\npub fn h4_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"h4\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<h5>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5)\npub fn h5(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"h5\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.h5(attrs, children: [html.Text(text)])`\npub fn h5_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"h5\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<h6>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6)\npub fn h6(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"h6\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.h6(attrs, children: [html.Text(text)])`\npub fn h6_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"h6\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<header>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header)\npub fn header(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"header\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.header(attrs, children: [html.Text(text)])`\npub fn header_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"header\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<hr />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr)\npub fn hr(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"hr\", attrs: attrs)\n}\n\n/// The [HTML `<i>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i)\npub fn i(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"i\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.i(attrs, children: [html.Text(text)])`\npub fn i_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"i\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<iframe>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)\npub fn iframe(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"iframe\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.iframe(attrs, children: [html.Text(text)])`\npub fn iframe_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"iframe\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<img />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img)\npub fn img(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"img\", attrs: attrs)\n}\n\n/// The [HTML `<input />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input)\npub fn input(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"input\", attrs: attrs)\n}\n\n/// The [HTML `<ins>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins)\npub fn ins(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"ins\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.ins(attrs, children: [html.Text(text)])`\npub fn ins_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"ins\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<kbd>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd)\npub fn kbd(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"kbd\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.kbd(attrs, children: [html.Text(text)])`\npub fn kbd_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"kbd\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<label>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label)\npub fn label(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"label\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.label(attrs, children: [html.Text(text)])`\npub fn label_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"label\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<legend>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend)\npub fn legend(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"legend\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.legend(attrs, children: [html.Text(text)])`\npub fn legend_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"legend\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<li>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li)\npub fn li(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"li\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.li(attrs, children: [html.Text(text)])`\npub fn li_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"li\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<link />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link)\npub fn link(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"link\", attrs: attrs)\n}\n\n/// The [HTML `<main>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main)\npub fn main(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"main\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.main(attrs, children: [html.Text(text)])`\npub fn main_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"main\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<map>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map)\npub fn map(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"map\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.map(attrs, children: [html.Text(text)])`\npub fn map_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"map\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<mark>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark)\npub fn mark(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"mark\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.mark(attrs, children: [html.Text(text)])`\npub fn mark_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"mark\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<math>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/math)\npub fn math(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"math\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.math(attrs, children: [html.Text(text)])`\npub fn math_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"math\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<menu>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu)\npub fn menu(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"menu\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.menu(attrs, children: [html.Text(text)])`\npub fn menu_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"menu\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<menuitem>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menuitem)\npub fn menuitem(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"menuitem\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.menuitem(attrs, children: [html.Text(text)])`\npub fn menuitem_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"menuitem\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<meta />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta)\npub fn meta(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"meta\", attrs: attrs)\n}\n\n/// The [HTML `<meter>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter)\npub fn meter(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"meter\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.meter(attrs, children: [html.Text(text)])`\npub fn meter_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"meter\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<nav>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav)\npub fn nav(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"nav\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.nav(attrs, children: [html.Text(text)])`\npub fn nav_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"nav\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<noscript>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript)\npub fn noscript(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"noscript\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.noscript(attrs, children: [html.Text(text)])`\npub fn noscript_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"noscript\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<object>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object)\npub fn object(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"object\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.object(attrs, children: [html.Text(text)])`\npub fn object_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"object\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<ol>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol)\npub fn ol(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"ol\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.ol(attrs, children: [html.Text(text)])`\npub fn ol_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"ol\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<optgroup>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup)\npub fn optgroup(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"optgroup\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.optgroup(attrs, children: [html.Text(text)])`\npub fn optgroup_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"optgroup\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<option>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option)\npub fn option(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"option\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.option(attrs, children: [html.Text(text)])`\npub fn option_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"option\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<output>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output)\npub fn output(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"output\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.output(attrs, children: [html.Text(text)])`\npub fn output_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"output\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<p>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p)\npub fn p(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"p\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.p(attrs, children: [html.Text(text)])`\npub fn p_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"p\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<param>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/param)\npub fn param(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"param\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.param(attrs, children: [html.Text(text)])`\npub fn param_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"param\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<picture>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture)\npub fn picture(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"picture\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.picture(attrs, children: [html.Text(text)])`\npub fn picture_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"picture\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<pre>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre)\npub fn pre(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"pre\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.pre(attrs, children: [html.Text(text)])`\npub fn pre_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"pre\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<progress>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress)\npub fn progress(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"progress\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.progress(attrs, children: [html.Text(text)])`\npub fn progress_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"progress\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<q>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q)\npub fn q(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"q\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.q(attrs, children: [html.Text(text)])`\npub fn q_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"q\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<rp>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rp)\npub fn rp(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"rp\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.rp(attrs, children: [html.Text(text)])`\npub fn rp_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"rp\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<rt>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt)\npub fn rt(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"rt\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.rt(attrs, children: [html.Text(text)])`\npub fn rt_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"rt\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<ruby>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby)\npub fn ruby(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"ruby\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.ruby(attrs, children: [html.Text(text)])`\npub fn ruby_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"ruby\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<s>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s)\npub fn s(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"s\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.s(attrs, children: [html.Text(text)])`\npub fn s_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"s\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<samp>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp)\npub fn samp(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"samp\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.samp(attrs, children: [html.Text(text)])`\npub fn samp_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"samp\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<section>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section)\npub fn section(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"section\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.section(attrs, children: [html.Text(text)])`\npub fn section_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"section\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<select>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select)\npub fn select(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"select\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.select(attrs, children: [html.Text(text)])`\npub fn select_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"select\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<small>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/small)\npub fn small(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"small\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.small(attrs, children: [html.Text(text)])`\npub fn small_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"small\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<source />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source)\npub fn source(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"source\", attrs: attrs)\n}\n\n/// The [HTML `<span>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span)\npub fn span(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"span\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.span(attrs, children: [html.Text(text)])`\npub fn span_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"span\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<strong>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong)\npub fn strong(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"strong\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.strong(attrs, children: [html.Text(text)])`\npub fn strong_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"strong\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<sub>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub)\npub fn sub(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"sub\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.sub(attrs, children: [html.Text(text)])`\npub fn sub_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"sub\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<summary>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary)\npub fn summary(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"summary\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.summary(attrs, children: [html.Text(text)])`\npub fn summary_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"summary\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<sup>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup)\npub fn sup(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"sup\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.sup(attrs, children: [html.Text(text)])`\npub fn sup_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"sup\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<svg>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/svg)\npub fn svg(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"svg\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.svg(attrs, children: [html.Text(text)])`\npub fn svg_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"svg\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<table>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table)\npub fn table(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"table\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.table(attrs, children: [html.Text(text)])`\npub fn table_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"table\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<tbody>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody)\npub fn tbody(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"tbody\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.tbody(attrs, children: [html.Text(text)])`\npub fn tbody_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"tbody\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<td>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td)\npub fn td(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"td\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.td(attrs, children: [html.Text(text)])`\npub fn td_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"td\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<textarea>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea)\npub fn textarea(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"textarea\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.textarea(attrs, children: [html.Text(text)])`\npub fn textarea_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"textarea\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<tfoot>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot)\npub fn tfoot(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"tfoot\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.tfoot(attrs, children: [html.Text(text)])`\npub fn tfoot_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"tfoot\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<th>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th)\npub fn th(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"th\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.th(attrs, children: [html.Text(text)])`\npub fn th_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"th\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<thead>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead)\npub fn thead(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"thead\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.thead(attrs, children: [html.Text(text)])`\npub fn thead_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"thead\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<time>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time)\npub fn time(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"time\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.time(attrs, children: [html.Text(text)])`\npub fn time_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"time\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<tr>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr)\npub fn tr(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"tr\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.tr(attrs, children: [html.Text(text)])`\npub fn tr_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"tr\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<track />` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track)\npub fn track(attrs: List(Attr(a))) -> Node(a) {\n  LeafElement(tag: \"track\", attrs: attrs)\n}\n\n/// The [HTML `<u>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u)\npub fn u(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"u\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.u(attrs, children: [html.Text(text)])`\npub fn u_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"u\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<ul>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul)\npub fn ul(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"ul\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.ul(attrs, children: [html.Text(text)])`\npub fn ul_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"ul\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<var>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/var)\npub fn var(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"var\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.var(attrs, children: [html.Text(text)])`\npub fn var_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"var\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<video>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video)\npub fn video(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"video\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.video(attrs, children: [html.Text(text)])`\npub fn video_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"video\", attrs: attrs, children: [Text(text)])\n}\n\n/// The [HTML `<wbr>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr)\npub fn wbr(attrs: List(Attr(a)), children: List(Node(a))) -> Node(a) {\n  Element(tag: \"wbr\", attrs: attrs, children: children)\n}\n\n/// Shorthand for `html.wbr(attrs, children: [html.Text(text)])`\npub fn wbr_text(attrs: List(Attr(a)), text: String) -> Node(a) {\n  Element(tag: \"wbr\", attrs: attrs, children: [Text(text)])\n}\n" (Durability(0))    
2023-08-04T09:30:46.275104Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision()    
2023-08-04T09:30:46.275112Z DEBUG event{type_name="gleamalyzer::server::SetPackageInfoEvent"}: salsa::runtime: increment_revision: incremented to R172    
2023-08-04T09:30:46.275215Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.275249Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.275259Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R4, changed_at=R4    
2023-08-04T09:30:46.275269Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.275277Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R4, changed_at=R4    
2023-08-04T09:30:46.275287Z DEBUG salsa::derived::slot: validate_memoized_value: verified_at=R4, revision_now=R172, inputs=Tracked {
    inputs: [
        DatabaseKeyIndex {
            group_index: 1,
            query_index: 0,
            key_index: 0,
        },
    ],
}    
2023-08-04T09:30:46.275302Z DEBUG salsa::derived::slot: check_durability(last_changed=R172 <= verified_at=R4) = false    
2023-08-04T09:30:46.275312Z DEBUG salsa::input: maybe_changed_since(slot=FileContentQuery(FileId(0)), revision=R4)    
2023-08-04T09:30:46.275319Z DEBUG salsa::input: maybe_changed_since: changed_at = R101    
2023-08-04T09:30:46.275325Z DEBUG salsa::derived::slot: validate_memoized_value: `DatabaseKeyIndex { group_index: 1, query_index: 0, key_index: 0 }` may have changed    
2023-08-04T09:30:46.275353Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.275363Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): executing query    
2023-08-04T09:30:46.275370Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.275869Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(0))): value is equal, back-dating to R4    
2023-08-04T09:30:46.275881Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(0))): result.changed_at=R4, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 1, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.275904Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(0))): inputs=Tracked {
    inputs: [
        file_content(FileId(0)),
    ],
}    
2023-08-04T09:30:46.275954Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.275962Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.275968Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.275976Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.275985Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.275992Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R4, changed_at=R4    
2023-08-04T09:30:46.275998Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.276005Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R4, changed_at=R4    
2023-08-04T09:30:46.276012Z DEBUG salsa::derived::slot: validate_memoized_value: verified_at=R4, revision_now=R172, inputs=Tracked {
    inputs: [
        DatabaseKeyIndex {
            group_index: 2,
            query_index: 0,
            key_index: 0,
        },
        DatabaseKeyIndex {
            group_index: 1,
            query_index: 2,
            key_index: 0,
        },
    ],
}    
2023-08-04T09:30:46.276021Z DEBUG salsa::derived::slot: check_durability(last_changed=R172 <= verified_at=R4) = false    
2023-08-04T09:30:46.276028Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276035Z DEBUG salsa::derived::slot: maybe_changed_since(ParseQuery(FileId(0))) called with revision=R4, revision_now=R172    
2023-08-04T09:30:46.276041Z DEBUG salsa::derived::slot: maybe_changed_since(ParseQuery(FileId(0))): false since up-to-date memo that changed at R4    
2023-08-04T09:30:46.276049Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276055Z DEBUG salsa::derived::slot: maybe_changed_since(SourceRootPackageInfoQuery(SourceRootId(0))) called with revision=R4, revision_now=R172    
2023-08-04T09:30:46.276061Z DEBUG salsa::derived::slot: check_durability(last_changed=R8 <= verified_at=R4) = false    
2023-08-04T09:30:46.276068Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.276074Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R4, changed_at=R2    
2023-08-04T09:30:46.276081Z DEBUG salsa::derived::slot: validate_memoized_value: verified_at=R4, revision_now=R172, inputs=Tracked {
    inputs: [
        DatabaseKeyIndex {
            group_index: 1,
            query_index: 4,
            key_index: 0,
        },
    ],
}    
2023-08-04T09:30:46.276089Z DEBUG salsa::derived::slot: check_durability(last_changed=R8 <= verified_at=R4) = false    
2023-08-04T09:30:46.276095Z DEBUG salsa::input: maybe_changed_since(slot=PackageGraphQuery(()), revision=R4)    
2023-08-04T09:30:46.276102Z DEBUG salsa::input: maybe_changed_since: changed_at = R8    
2023-08-04T09:30:46.276134Z DEBUG salsa::derived::slot: validate_memoized_value: `DatabaseKeyIndex { group_index: 1, query_index: 4, key_index: 0 }` may have changed    
2023-08-04T09:30:46.276142Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.276148Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): executing query    
2023-08-04T09:30:46.276155Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276168Z DEBUG salsa::derived::slot: read_upgrade(SourceRootPackageInfoQuery(SourceRootId(0))): result.changed_at=R8, result.durability=Durability(1), result.dependencies = Some({DatabaseKeyIndex { group_index: 1, query_index: 4, key_index: 0 }})    
2023-08-04T09:30:46.276177Z DEBUG salsa::derived::slot: read_upgrade(SourceRootPackageInfoQuery(SourceRootId(0))): inputs=Tracked {
    inputs: [
        package_graph(()),
    ],
}    
2023-08-04T09:30:46.276190Z DEBUG salsa::derived::slot: maybe_changed_since(SourceRootPackageInfoQuery(SourceRootId(0)): true since (recomputed) value changed at R8    
2023-08-04T09:30:46.276197Z DEBUG salsa::derived::slot: validate_memoized_value: `DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }` may have changed    
2023-08-04T09:30:46.276203Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.276210Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): executing query    
2023-08-04T09:30:46.276216Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276223Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.276229Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.276236Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.276242Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.276248Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.276253Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.276267Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276274Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276281Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276287Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276294Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276299Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276327Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276334Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276340Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276346Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276353Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276359Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276373Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276380Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276386Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276404Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276411Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276417Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276430Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276437Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276443Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276450Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276456Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276461Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276478Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276486Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276492Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276498Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276504Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276509Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276535Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276542Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276548Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276555Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276561Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276567Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276579Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276586Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276592Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276598Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276604Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276610Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276624Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276631Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276638Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276644Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276650Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276656Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276665Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276681Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276688Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276694Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276700Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276706Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276721Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.276728Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.276734Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.276740Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.276747Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.276753Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276768Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(0))): result.changed_at=R8, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }, DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }})    
2023-08-04T09:30:46.276778Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(0))): inputs=Tracked {
    inputs: [
        parse(FileId(0)),
        source_root_package_info(SourceRootId(0)),
    ],
}    
2023-08-04T09:30:46.276795Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.276802Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.276844Z DEBUG gleamalyzer::server: Publish 1 diagnostics for file:///Users/maurobalbi/Documents/repos/try_gleam/src/test.gleam
2023-08-04T09:30:46.418511Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.418554Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.418565Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.418576Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.418585Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.418592Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.418598Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.418633Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.418650Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.418659Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.418668Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.418678Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): executing query    
2023-08-04T09:30:46.418684Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.418693Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.418700Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.418706Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.418713Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.418720Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.418764Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.418782Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.418790Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(5)): invoked at R172    
2023-08-04T09:30:46.418797Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(5)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.418804Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 1 }: execute_query_implementation invoked    
2023-08-04T09:30:46.418810Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(5)): executing query    
2023-08-04T09:30:46.418816Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.418828Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(5)): invoked at R172    
2023-08-04T09:30:46.418834Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(5)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.418842Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 1 }: execute_query_implementation invoked    
2023-08-04T09:30:46.418848Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(5)): executing query    
2023-08-04T09:30:46.418855Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.418863Z  INFO salsa::derived::slot: ParseQuery(FileId(5)): invoked at R172    
2023-08-04T09:30:46.418870Z DEBUG salsa::derived::slot: ParseQuery(FileId(5)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.418878Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 1 }: execute_query_implementation invoked    
2023-08-04T09:30:46.418884Z  INFO salsa::derived::slot: ParseQuery(FileId(5)): executing query    
2023-08-04T09:30:46.418891Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419208Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(5))): result.changed_at=R102, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 1, query_index: 0, key_index: 5 }})    
2023-08-04T09:30:46.419225Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(5))): inputs=Tracked {
    inputs: [
        file_content(FileId(5)),
    ],
}    
2023-08-04T09:30:46.419244Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(5)))    
2023-08-04T09:30:46.419251Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.419257Z DEBUG salsa::lru: record_use: index=18446744073709551615    
2023-08-04T09:30:46.419263Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(5)))    
2023-08-04T09:30:46.419269Z DEBUG salsa::lru: inserted node ParseQuery(FileId(5)) at 1    
2023-08-04T09:30:46.419275Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(5)))    
2023-08-04T09:30:46.419288Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419296Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419303Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419309Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419316Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419322Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419346Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419354Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419360Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419377Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419383Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419390Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419404Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419412Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419418Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419424Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419431Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419437Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419455Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419462Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419468Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419475Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419481Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419487Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419497Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419504Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419510Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419516Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419522Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419528Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419546Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419554Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419560Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419566Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419572Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419578Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419590Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419597Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419603Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419609Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419615Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419621Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419637Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419644Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419660Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419666Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419672Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419678Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419686Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419693Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.419699Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.419706Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.419712Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.419718Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419736Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(5))): result.changed_at=R102, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 1 }, DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }})    
2023-08-04T09:30:46.419747Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(5))): inputs=Tracked {
    inputs: [
        parse(FileId(5)),
        source_root_package_info(SourceRootId(0)),
    ],
}    
2023-08-04T09:30:46.419761Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(5)))    
2023-08-04T09:30:46.419767Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419775Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419784Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419803Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419815Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419824Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419838Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419851Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419866Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419875Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419885Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(5))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 1 }, DatabaseKeyIndex { group_index: 1, query_index: 5, key_index: 0 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 0 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 1 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 2 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 3 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 0 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 1 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 1 }})    
2023-08-04T09:30:46.419898Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(5))): inputs=Tracked {
    inputs: [
        module_items(FileId(5)),
        module_map(()),
        intern_function(InFile { file_id: FileId(5), value: Idx::<Function>(0) }),
        intern_function(InFile { file_id: FileId(5), value: Idx::<Function>(1) }),
        intern_function(InFile { file_id: FileId(5), value: Idx::<Function>(2) }),
        intern_function(InFile { file_id: FileId(5), value: Idx::<Function>(3) }),
        intern_adt(InFile { file_id: FileId(5), value: Idx::<Adt>(0) }),
        intern_variant(VariantLoc { parent: AdtId(0), value: InFile { file_id: FileId(5), value: Idx::<Variant>(0) } }),
        intern_adt(InFile { file_id: FileId(5), value: Idx::<Adt>(1) }),
        intern_variant(VariantLoc { parent: AdtId(1), value: InFile { file_id: FileId(5), value: Idx::<Variant>(1) } }),
    ],
}    
2023-08-04T09:30:46.419932Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(5)))    
2023-08-04T09:30:46.419939Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419949Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419958Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.419965Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(5)): invoked at R172    
2023-08-04T09:30:46.419971Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(5)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.419978Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(5)): returning memoized value changed at R172    
2023-08-04T09:30:46.419984Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(5)))    
2023-08-04T09:30:46.419990Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.419998Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.420006Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.420013Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(5)): invoked at R172    
2023-08-04T09:30:46.420019Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(5)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.420025Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(5)): returning memoized value changed at R172    
2023-08-04T09:30:46.420031Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(5)))    
2023-08-04T09:30:46.420037Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.420045Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.420052Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.420060Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(50)): invoked at R172    
2023-08-04T09:30:46.420066Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(50)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.420073Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 2 }: execute_query_implementation invoked    
2023-08-04T09:30:46.420079Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(50)): executing query    
2023-08-04T09:30:46.420086Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.420093Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(50)): invoked at R172    
2023-08-04T09:30:46.420100Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(50)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.420106Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 2 }: execute_query_implementation invoked    
2023-08-04T09:30:46.420113Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(50)): executing query    
2023-08-04T09:30:46.420119Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.420127Z  INFO salsa::derived::slot: ParseQuery(FileId(50)): invoked at R172    
2023-08-04T09:30:46.420133Z DEBUG salsa::derived::slot: ParseQuery(FileId(50)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.420140Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 2 }: execute_query_implementation invoked    
2023-08-04T09:30:46.420157Z  INFO salsa::derived::slot: ParseQuery(FileId(50)): executing query    
2023-08-04T09:30:46.420164Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.425987Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(50))): result.changed_at=R147, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 1, query_index: 0, key_index: 50 }})    
2023-08-04T09:30:46.426022Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(50))): inputs=Tracked {
    inputs: [
        file_content(FileId(50)),
    ],
}    
2023-08-04T09:30:46.426046Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(50)))    
2023-08-04T09:30:46.426053Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.426059Z DEBUG salsa::lru: record_use: index=18446744073709551615    
2023-08-04T09:30:46.426065Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(50)))    
2023-08-04T09:30:46.426072Z DEBUG salsa::lru: inserted node ParseQuery(FileId(50)) at 2    
2023-08-04T09:30:46.426078Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(50)))    
2023-08-04T09:30:46.426099Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426109Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426116Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426122Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426128Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426134Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426155Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426162Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426169Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426175Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426181Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426187Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426200Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426207Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426213Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426219Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426225Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426231Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426243Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426250Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426256Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426262Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426268Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426293Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426311Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426319Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426325Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426331Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426338Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426343Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426355Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426362Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426369Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426375Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426381Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426387Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426399Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426406Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426412Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426418Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426424Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426430Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426449Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426457Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426463Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426469Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426475Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426481Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426493Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426500Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426506Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426512Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426518Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426524Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426536Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426543Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426549Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426555Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426577Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426584Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426597Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426605Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426611Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426617Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426623Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426629Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426649Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426656Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426663Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426669Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426675Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426681Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426696Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426703Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426709Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426715Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426722Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426728Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426744Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426751Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426757Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426763Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426769Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426775Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426788Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426795Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426801Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426808Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426814Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426820Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426833Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426840Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426857Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426863Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426870Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426876Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426888Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426895Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426901Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426907Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426913Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426919Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426936Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426943Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426949Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426956Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.426962Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.426968Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.426978Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.426985Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.426991Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.426997Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427003Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427009Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427024Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427031Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427037Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427043Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427049Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427055Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427066Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427073Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427079Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427085Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427091Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427098Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427120Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427126Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427133Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427139Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427145Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427151Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427164Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427171Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427177Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427183Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427189Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427195Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427204Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427211Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427217Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427223Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427229Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427235Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427243Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427250Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427257Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427263Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427269Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427275Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427283Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427290Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427296Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427303Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427309Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427315Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427335Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427342Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427348Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427354Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427369Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427375Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427399Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427407Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427413Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427419Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427426Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427432Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427449Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427456Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427462Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427469Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427475Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427481Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427498Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427505Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427511Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427517Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427523Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427529Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427546Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427553Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427559Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427566Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427572Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427577Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427592Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427599Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427605Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427612Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427618Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427624Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427638Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427645Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427659Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427666Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427672Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427678Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427689Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427696Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427702Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427709Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427715Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427721Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427734Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427741Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427748Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427754Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427760Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427766Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427781Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427788Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427794Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427800Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427806Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427812Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427832Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427838Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427845Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427851Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427857Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427863Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427893Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427900Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427907Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427913Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427919Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427925Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427946Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.427953Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.427959Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.427965Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.427972Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.427978Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.427994Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428001Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428008Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428014Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428020Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428026Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428043Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428050Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428056Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428062Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428068Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428074Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428088Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428095Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428101Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428107Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428113Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428119Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428138Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428145Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428152Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428158Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428164Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428170Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428189Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428196Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428202Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428208Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428224Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428230Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428250Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428257Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428263Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428270Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428276Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428282Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428301Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428307Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428314Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428320Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428326Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428332Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428346Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428354Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428360Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428366Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428372Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428378Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428392Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428399Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428405Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428411Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428417Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428423Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428440Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428447Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428454Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428460Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428468Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428474Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428490Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428496Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428503Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428519Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428525Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428531Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428551Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428558Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428565Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428571Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428577Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428583Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428600Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428606Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428612Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428619Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428624Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428631Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428647Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428654Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428660Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428666Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428672Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428678Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428695Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428702Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428708Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428714Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428720Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428726Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428743Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428750Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428756Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428762Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428768Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428774Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428790Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428806Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428812Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428818Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428824Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428831Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428850Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428858Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428864Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428870Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428876Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428882Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428896Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.428903Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.428910Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.428916Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.428922Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.428928Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428945Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(50))): result.changed_at=R147, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 2 }, DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }})    
2023-08-04T09:30:46.428956Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(50))): inputs=Tracked {
    inputs: [
        parse(FileId(50)),
        source_root_package_info(SourceRootId(0)),
    ],
}    
2023-08-04T09:30:46.428971Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(50)))    
2023-08-04T09:30:46.428978Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.428989Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429000Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429008Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429015Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429023Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429030Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429037Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429045Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429052Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429060Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429074Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(60)): invoked at R172    
2023-08-04T09:30:46.429081Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(60)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.429097Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 3 }: execute_query_implementation invoked    
2023-08-04T09:30:46.429104Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(60)): executing query    
2023-08-04T09:30:46.429110Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429122Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(60)): invoked at R172    
2023-08-04T09:30:46.429129Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(60)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.429136Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 3 }: execute_query_implementation invoked    
2023-08-04T09:30:46.429143Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(60)): executing query    
2023-08-04T09:30:46.429149Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.429161Z  INFO salsa::derived::slot: ParseQuery(FileId(60)): invoked at R172    
2023-08-04T09:30:46.429169Z DEBUG salsa::derived::slot: ParseQuery(FileId(60)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.429179Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 3 }: execute_query_implementation invoked    
2023-08-04T09:30:46.429187Z  INFO salsa::derived::slot: ParseQuery(FileId(60)): executing query    
2023-08-04T09:30:46.429193Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.430989Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(60))): result.changed_at=R157, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 1, query_index: 0, key_index: 60 }})    
2023-08-04T09:30:46.431013Z DEBUG salsa::derived::slot: read_upgrade(ParseQuery(FileId(60))): inputs=Tracked {
    inputs: [
        file_content(FileId(60)),
    ],
}    
2023-08-04T09:30:46.431032Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(60)))    
2023-08-04T09:30:46.431039Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.431045Z DEBUG salsa::lru: record_use: index=18446744073709551615    
2023-08-04T09:30:46.431051Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(60)))    
2023-08-04T09:30:46.431058Z DEBUG salsa::lru: inserted node ParseQuery(FileId(60)) at 3    
2023-08-04T09:30:46.431064Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(60)))    
2023-08-04T09:30:46.431079Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431087Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431094Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431100Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431107Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431113Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431135Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431143Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431149Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431155Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431161Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431168Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431180Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431203Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431210Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431216Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431222Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431228Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431245Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431252Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431259Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431265Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431271Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431277Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431295Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431302Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431308Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431315Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431321Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431327Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431341Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431348Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431355Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431361Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431367Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431373Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431385Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431392Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431410Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431428Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431437Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431445Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431461Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431471Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431478Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431484Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431505Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431511Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431526Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431534Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431541Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431548Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431555Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431561Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431580Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431589Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431595Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431602Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431608Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431614Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431641Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431648Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431655Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431661Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431667Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431673Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431698Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431706Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431712Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431718Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431725Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431731Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431748Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431755Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431761Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431767Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431774Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431780Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431796Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431804Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431810Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431828Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431835Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431842Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431851Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431858Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431865Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431871Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431877Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431884Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431892Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431899Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431905Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431912Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431918Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431924Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.431948Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.431956Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.431962Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.431969Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.431975Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.431981Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432011Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432019Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432025Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432032Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432038Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432044Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432063Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432070Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432077Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432083Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432089Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432095Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432120Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432138Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432152Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432163Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432170Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432176Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432193Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432201Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432208Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432214Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432221Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432227Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432242Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432249Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432256Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432262Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432268Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432274Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432289Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432297Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432303Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432309Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432332Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432342Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432363Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432374Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432381Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432388Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432395Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432401Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432421Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432436Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432445Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432452Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432458Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432477Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432499Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432507Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): invoked at R172    
2023-08-04T09:30:46.432513Z DEBUG salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.432520Z  INFO salsa::derived::slot: SourceRootPackageInfoQuery(SourceRootId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.432526Z DEBUG salsa::lru: record_use(node=SourceRootPackageInfoQuery(SourceRootId(0)))    
2023-08-04T09:30:46.432533Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432552Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(60))): result.changed_at=R157, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 3 }, DatabaseKeyIndex { group_index: 1, query_index: 2, key_index: 0 }})    
2023-08-04T09:30:46.432566Z DEBUG salsa::derived::slot: read_upgrade(ModuleItemsQuery(FileId(60))): inputs=Tracked {
    inputs: [
        parse(FileId(60)),
        source_root_package_info(SourceRootId(0)),
    ],
}    
2023-08-04T09:30:46.432591Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(60)))    
2023-08-04T09:30:46.432598Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432610Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432621Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432628Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432636Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432644Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432651Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432658Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432666Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432673Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432680Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432688Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432724Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432733Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432741Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432748Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432757Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432776Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432788Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432797Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432812Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432823Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432834Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432843Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432872Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432881Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432890Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432903Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(60))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 3 }, DatabaseKeyIndex { group_index: 1, query_index: 5, key_index: 0 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 4 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 5 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 6 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 7 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 8 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 9 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 10 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 11 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 12 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 13 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 14 }})    
2023-08-04T09:30:46.432919Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(60))): inputs=Tracked {
    inputs: [
        module_items(FileId(60)),
        module_map(()),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(0) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(1) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(2) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(3) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(4) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(5) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(6) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(7) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(8) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(9) }),
        intern_function(InFile { file_id: FileId(60), value: Idx::<Function>(10) }),
    ],
}    
2023-08-04T09:30:46.432947Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(60)))    
2023-08-04T09:30:46.432954Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.432962Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432970Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432978Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432989Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.432999Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433008Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433020Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433031Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433040Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433049Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433061Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433070Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433079Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433096Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433108Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433117Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433129Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433144Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433153Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433162Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433171Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433217Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433226Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433235Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433243Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433252Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433261Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433269Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433283Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433292Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433305Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433322Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433333Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433349Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433359Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433369Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433379Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433388Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433397Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433407Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433416Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433425Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433436Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433445Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(50))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 2 }, DatabaseKeyIndex { group_index: 1, query_index: 5, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 3 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 15 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 16 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 17 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 18 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 19 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 20 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 21 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 22 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 23 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 24 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 25 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 26 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 27 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 28 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 29 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 30 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 31 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 32 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 33 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 34 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 35 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 36 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 37 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 38 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 39 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 40 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 41 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 2 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 2 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 3 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 3 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 4 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 4 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 5 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 5 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 6 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 7 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 6 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 8 }, DatabaseKeyIndex { group_index: 0, query_index: 2, key_index: 7 }, DatabaseKeyIndex { group_index: 0, query_index: 4, key_index: 9 }})    
2023-08-04T09:30:46.433481Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(50))): inputs=Tracked {
    inputs: [
        module_items(FileId(50)),
        module_map(()),
        module_scope(FileId(60)),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(0) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(1) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(2) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(3) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(4) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(5) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(6) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(7) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(8) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(9) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(10) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(11) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(12) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(13) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(14) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(15) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(16) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(17) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(18) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(19) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(20) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(21) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(22) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(23) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(24) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(25) }),
        intern_function(InFile { file_id: FileId(50), value: Idx::<Function>(26) }),
        intern_adt(InFile { file_id: FileId(50), value: Idx::<Adt>(0) }),
        intern_variant(VariantLoc { parent: AdtId(2), value: InFile { file_id: FileId(50), value: Idx::<Variant>(0) } }),
        intern_adt(InFile { file_id: FileId(50), value: Idx::<Adt>(1) }),
        intern_variant(VariantLoc { parent: AdtId(3), value: InFile { file_id: FileId(50), value: Idx::<Variant>(1) } }),
        intern_adt(InFile { file_id: FileId(50), value: Idx::<Adt>(2) }),
        intern_variant(VariantLoc { parent: AdtId(4), value: InFile { file_id: FileId(50), value: Idx::<Variant>(2) } }),
        intern_adt(InFile { file_id: FileId(50), value: Idx::<Adt>(3) }),
        intern_variant(VariantLoc { parent: AdtId(5), value: InFile { file_id: FileId(50), value: Idx::<Variant>(3) } }),
        intern_variant(VariantLoc { parent: AdtId(5), value: InFile { file_id: FileId(50), value: Idx::<Variant>(4) } }),
        intern_variant(VariantLoc { parent: AdtId(5), value: InFile { file_id: FileId(50), value: Idx::<Variant>(5) } }),
        intern_adt(InFile { file_id: FileId(50), value: Idx::<Adt>(4) }),
        intern_variant(VariantLoc { parent: AdtId(6), value: InFile { file_id: FileId(50), value: Idx::<Variant>(6) } }),
        intern_adt(InFile { file_id: FileId(50), value: Idx::<Adt>(5) }),
        intern_variant(VariantLoc { parent: AdtId(7), value: InFile { file_id: FileId(50), value: Idx::<Variant>(7) } }),
    ],
}    
2023-08-04T09:30:46.433550Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(50)))    
2023-08-04T09:30:46.433557Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.433568Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433578Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433589Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433597Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433609Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433618Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433629Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(0))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 1, query_index: 5, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 1 }, DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 2 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 42 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 43 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 44 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 45 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 46 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 47 }})    
2023-08-04T09:30:46.433641Z DEBUG salsa::derived::slot: read_upgrade(ModuleScopeQuery(FileId(0))): inputs=Tracked {
    inputs: [
        module_items(FileId(0)),
        module_map(()),
        module_scope(FileId(5)),
        module_scope(FileId(50)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(0) }),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(1) }),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(2) }),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(3) }),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(4) }),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(5) }),
    ],
}    
2023-08-04T09:30:46.433676Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.433683Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.433694Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433702Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.433709Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.433715Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.433722Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.433728Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.433736Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433743Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.433749Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.433755Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.433762Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.433768Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.433774Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433781Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.433787Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.433794Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.433800Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.433806Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.433813Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433819Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.433826Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.433832Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.433838Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.433844Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.433851Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433862Z  INFO salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.433870Z DEBUG salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.433877Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 3, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.433884Z  INFO salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): executing query    
2023-08-04T09:30:46.433912Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433923Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.433931Z DEBUG salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(45)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.433938Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.433945Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(45)): executing query    
2023-08-04T09:30:46.433953Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433960Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.433966Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.433972Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.433979Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.433984Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.433991Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.433999Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434005Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.434012Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.434019Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.434025Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.434030Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.434075Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(45))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 45 }, DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.434085Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(45))): inputs=Tracked {
    inputs: [
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(3) }),
        module_items(FileId(0)),
        parse(FileId(0)),
    ],
}    
2023-08-04T09:30:46.434099Z DEBUG salsa::lru: record_use(node=BodyWithSourceMapQuery(FunctionId(45)))    
2023-08-04T09:30:46.434105Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434114Z DEBUG salsa::derived::slot: read_upgrade(BodySourceMapQuery(FunctionId(45))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 0 }})    
2023-08-04T09:30:46.434122Z DEBUG salsa::derived::slot: read_upgrade(BodySourceMapQuery(FunctionId(45))): inputs=Tracked {
    inputs: [
        body_with_source_map(FunctionId(45)),
    ],
}    
2023-08-04T09:30:46.434133Z DEBUG salsa::lru: record_use(node=BodySourceMapQuery(FunctionId(45)))    
2023-08-04T09:30:46.434139Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434150Z  INFO ide::ide::goto_definition: Resolving pattern Variable(
    Variable(
        VARIABLE@265..270
          NAME_REF@265..270
            IDENT@265..270 "snake"
        ,
    ),
)
2023-08-04T09:30:46.434166Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434177Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.434184Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.434203Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.434209Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): executing query    
2023-08-04T09:30:46.434216Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434225Z  INFO salsa::derived::slot: BodyQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.434233Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(45)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.434240Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.434247Z  INFO salsa::derived::slot: BodyQuery(FunctionId(45)): executing query    
2023-08-04T09:30:46.434253Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434260Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.434267Z DEBUG salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.434273Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.434280Z DEBUG salsa::lru: record_use(node=BodyWithSourceMapQuery(FunctionId(45)))    
2023-08-04T09:30:46.434286Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434294Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(45))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 0 }})    
2023-08-04T09:30:46.434303Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(45))): inputs=Tracked {
    inputs: [
        body_with_source_map(FunctionId(45)),
    ],
}    
2023-08-04T09:30:46.434313Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(45)))    
2023-08-04T09:30:46.434319Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434333Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(45))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 0 }})    
2023-08-04T09:30:46.434341Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(45))): inputs=Tracked {
    inputs: [
        body(FunctionId(45)),
    ],
}    
2023-08-04T09:30:46.434352Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.434358Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434366Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434373Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434380Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.434386Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.434392Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.434398Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434404Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434411Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.434418Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.434424Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.434430Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.434436Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434467Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434477Z  INFO salsa::derived::slot: DependencyOrderQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434485Z DEBUG salsa::derived::slot: DependencyOrderQuery(FileId(0)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.434492Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 7, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.434498Z  INFO salsa::derived::slot: DependencyOrderQuery(FileId(0)): executing query    
2023-08-04T09:30:46.434505Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434511Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434517Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.434524Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.434530Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.434536Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434544Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434552Z  INFO salsa::derived::slot: BodyQuery(FunctionId(42)): invoked at R172    
2023-08-04T09:30:46.434559Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(42)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.434565Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 1 }: execute_query_implementation invoked    
2023-08-04T09:30:46.434572Z  INFO salsa::derived::slot: BodyQuery(FunctionId(42)): executing query    
2023-08-04T09:30:46.434578Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434585Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(42)): invoked at R172    
2023-08-04T09:30:46.434592Z DEBUG salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(42)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.434598Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 1 }: execute_query_implementation invoked    
2023-08-04T09:30:46.434605Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(42)): executing query    
2023-08-04T09:30:46.434613Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434619Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434626Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.434632Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.434638Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.434644Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434651Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434658Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434664Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.434670Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.434677Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.434683Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.434689Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.434711Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(42))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 42 }, DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.434732Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(42))): inputs=Tracked {
    inputs: [
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(0) }),
        module_items(FileId(0)),
        parse(FileId(0)),
    ],
}    
2023-08-04T09:30:46.434744Z DEBUG salsa::lru: record_use(node=BodyWithSourceMapQuery(FunctionId(42)))    
2023-08-04T09:30:46.434750Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434757Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(42))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 1 }})    
2023-08-04T09:30:46.434766Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(42))): inputs=Tracked {
    inputs: [
        body_with_source_map(FunctionId(42)),
    ],
}    
2023-08-04T09:30:46.434775Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(42)))    
2023-08-04T09:30:46.434781Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434789Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434797Z  INFO salsa::derived::slot: BodyQuery(FunctionId(43)): invoked at R172    
2023-08-04T09:30:46.434803Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(43)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.434810Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 2 }: execute_query_implementation invoked    
2023-08-04T09:30:46.434816Z  INFO salsa::derived::slot: BodyQuery(FunctionId(43)): executing query    
2023-08-04T09:30:46.434822Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434830Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(43)): invoked at R172    
2023-08-04T09:30:46.434836Z DEBUG salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(43)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.434843Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 2 }: execute_query_implementation invoked    
2023-08-04T09:30:46.434849Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(43)): executing query    
2023-08-04T09:30:46.434857Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434864Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434870Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.434876Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.434883Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.434889Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.434895Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.434902Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.434908Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.434915Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.434921Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.434927Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.434933Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.434963Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(43))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 43 }, DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.434983Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(43))): inputs=Tracked {
    inputs: [
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(1) }),
        module_items(FileId(0)),
        parse(FileId(0)),
    ],
}    
2023-08-04T09:30:46.434994Z DEBUG salsa::lru: record_use(node=BodyWithSourceMapQuery(FunctionId(43)))    
2023-08-04T09:30:46.435001Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435008Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(43))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 2 }})    
2023-08-04T09:30:46.435016Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(43))): inputs=Tracked {
    inputs: [
        body_with_source_map(FunctionId(43)),
    ],
}    
2023-08-04T09:30:46.435025Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(43)))    
2023-08-04T09:30:46.435032Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435038Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435046Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): invoked at R172    
2023-08-04T09:30:46.435052Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(43)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.435059Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 1 }: execute_query_implementation invoked    
2023-08-04T09:30:46.435065Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): executing query    
2023-08-04T09:30:46.435072Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435079Z  INFO salsa::derived::slot: BodyQuery(FunctionId(43)): invoked at R172    
2023-08-04T09:30:46.435085Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(43)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435092Z  INFO salsa::derived::slot: BodyQuery(FunctionId(43)): returning memoized value changed at R172    
2023-08-04T09:30:46.435098Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(43)))    
2023-08-04T09:30:46.435104Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435114Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(43))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 2 }})    
2023-08-04T09:30:46.435122Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(43))): inputs=Tracked {
    inputs: [
        body(FunctionId(43)),
    ],
}    
2023-08-04T09:30:46.435132Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(43)))    
2023-08-04T09:30:46.435138Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435147Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435154Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.435161Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435167Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.435173Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.435179Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435186Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435193Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): invoked at R172    
2023-08-04T09:30:46.435199Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(43)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435216Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): returning memoized value changed at R172    
2023-08-04T09:30:46.435222Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(43)))    
2023-08-04T09:30:46.435229Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435238Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435245Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): invoked at R172    
2023-08-04T09:30:46.435251Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(43)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435257Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): returning memoized value changed at R172    
2023-08-04T09:30:46.435263Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(43)))    
2023-08-04T09:30:46.435269Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435276Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435283Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.435289Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435296Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.435302Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.435308Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435314Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435321Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): invoked at R172    
2023-08-04T09:30:46.435327Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(43)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435333Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(43)): returning memoized value changed at R172    
2023-08-04T09:30:46.435339Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(43)))    
2023-08-04T09:30:46.435345Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435353Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435363Z  INFO salsa::derived::slot: BodyQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.435370Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(44)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.435376Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 3 }: execute_query_implementation invoked    
2023-08-04T09:30:46.435383Z  INFO salsa::derived::slot: BodyQuery(FunctionId(44)): executing query    
2023-08-04T09:30:46.435389Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435398Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.435405Z DEBUG salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(44)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.435411Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 3 }: execute_query_implementation invoked    
2023-08-04T09:30:46.435418Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(44)): executing query    
2023-08-04T09:30:46.435425Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435432Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.435438Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.435445Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.435462Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.435468Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435475Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435482Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.435488Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.435494Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.435501Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.435507Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.435512Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.435540Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(44))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 44 }, DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.435550Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(44))): inputs=Tracked {
    inputs: [
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(2) }),
        module_items(FileId(0)),
        parse(FileId(0)),
    ],
}    
2023-08-04T09:30:46.435562Z DEBUG salsa::lru: record_use(node=BodyWithSourceMapQuery(FunctionId(44)))    
2023-08-04T09:30:46.435568Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435576Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(44))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 3 }})    
2023-08-04T09:30:46.435585Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(44))): inputs=Tracked {
    inputs: [
        body_with_source_map(FunctionId(44)),
    ],
}    
2023-08-04T09:30:46.435594Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(44)))    
2023-08-04T09:30:46.435601Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435607Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435615Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.435622Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(44)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.435629Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 2 }: execute_query_implementation invoked    
2023-08-04T09:30:46.435635Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): executing query    
2023-08-04T09:30:46.435642Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435648Z  INFO salsa::derived::slot: BodyQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.435655Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(44)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435661Z  INFO salsa::derived::slot: BodyQuery(FunctionId(44)): returning memoized value changed at R172    
2023-08-04T09:30:46.435668Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(44)))    
2023-08-04T09:30:46.435674Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435683Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(44))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 3 }})    
2023-08-04T09:30:46.435692Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(44))): inputs=Tracked {
    inputs: [
        body(FunctionId(44)),
    ],
}    
2023-08-04T09:30:46.435701Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(44)))    
2023-08-04T09:30:46.435718Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435727Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435735Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.435742Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435748Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.435755Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.435761Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435767Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435774Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.435781Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(44)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435787Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): returning memoized value changed at R172    
2023-08-04T09:30:46.435793Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(44)))    
2023-08-04T09:30:46.435799Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435808Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435816Z  INFO salsa::derived::slot: BodyQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.435822Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435829Z  INFO salsa::derived::slot: BodyQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.435835Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(45)))    
2023-08-04T09:30:46.435842Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435849Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435856Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.435862Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435869Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.435875Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.435882Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435889Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435896Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.435902Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435909Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.435915Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.435921Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435928Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435934Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.435941Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.435947Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.435953Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.435960Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.435979Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.435987Z  INFO salsa::derived::slot: BodyQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.435994Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(46)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.436001Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 4 }: execute_query_implementation invoked    
2023-08-04T09:30:46.436007Z  INFO salsa::derived::slot: BodyQuery(FunctionId(46)): executing query    
2023-08-04T09:30:46.436014Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436021Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436028Z DEBUG salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(46)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.436034Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 4 }: execute_query_implementation invoked    
2023-08-04T09:30:46.436041Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(46)): executing query    
2023-08-04T09:30:46.436051Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436058Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.436065Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.436071Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.436077Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.436084Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436090Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436097Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.436104Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.436110Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.436117Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.436123Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.436129Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.436174Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(46))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 46 }, DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.436185Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(46))): inputs=Tracked {
    inputs: [
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(4) }),
        module_items(FileId(0)),
        parse(FileId(0)),
    ],
}    
2023-08-04T09:30:46.436196Z DEBUG salsa::lru: record_use(node=BodyWithSourceMapQuery(FunctionId(46)))    
2023-08-04T09:30:46.436203Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436210Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(46))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 4 }})    
2023-08-04T09:30:46.436219Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(46))): inputs=Tracked {
    inputs: [
        body_with_source_map(FunctionId(46)),
    ],
}    
2023-08-04T09:30:46.436228Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(46)))    
2023-08-04T09:30:46.436235Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436252Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436263Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436270Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(46)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.436277Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 3 }: execute_query_implementation invoked    
2023-08-04T09:30:46.436283Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): executing query    
2023-08-04T09:30:46.436290Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436297Z  INFO salsa::derived::slot: BodyQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436303Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(46)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436310Z  INFO salsa::derived::slot: BodyQuery(FunctionId(46)): returning memoized value changed at R172    
2023-08-04T09:30:46.436316Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(46)))    
2023-08-04T09:30:46.436322Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436333Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(46))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 4 }})    
2023-08-04T09:30:46.436342Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(46))): inputs=Tracked {
    inputs: [
        body(FunctionId(46)),
    ],
}    
2023-08-04T09:30:46.436351Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(46)))    
2023-08-04T09:30:46.436358Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436366Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436373Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.436379Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436385Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.436392Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.436398Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436404Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436411Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436417Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(46)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436423Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): returning memoized value changed at R172    
2023-08-04T09:30:46.436429Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(46)))    
2023-08-04T09:30:46.436436Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436444Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436451Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436457Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(46)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436464Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): returning memoized value changed at R172    
2023-08-04T09:30:46.436470Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(46)))    
2023-08-04T09:30:46.436476Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436483Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436490Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.436509Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436515Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.436521Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.436528Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436534Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436540Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436547Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(46)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436553Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): returning memoized value changed at R172    
2023-08-04T09:30:46.436559Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(46)))    
2023-08-04T09:30:46.436565Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436573Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436580Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436587Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(46)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436593Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): returning memoized value changed at R172    
2023-08-04T09:30:46.436599Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(46)))    
2023-08-04T09:30:46.436605Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436612Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436619Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.436626Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436632Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.436638Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.436645Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436651Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436658Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): invoked at R172    
2023-08-04T09:30:46.436664Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(46)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.436670Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(46)): returning memoized value changed at R172    
2023-08-04T09:30:46.436677Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(46)))    
2023-08-04T09:30:46.436683Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436691Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436700Z  INFO salsa::derived::slot: BodyQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.436706Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(47)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.436713Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 5 }: execute_query_implementation invoked    
2023-08-04T09:30:46.436720Z  INFO salsa::derived::slot: BodyQuery(FunctionId(47)): executing query    
2023-08-04T09:30:46.436727Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436735Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.436741Z DEBUG salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(47)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.436759Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 5 }: execute_query_implementation invoked    
2023-08-04T09:30:46.436765Z  INFO salsa::derived::slot: BodyWithSourceMapQuery(FunctionId(47)): executing query    
2023-08-04T09:30:46.436773Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436780Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.436787Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.436793Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.436800Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.436806Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.436813Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.436820Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.436826Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.436833Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.436839Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.436845Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.436885Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.436982Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(47))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 47 }, DatabaseKeyIndex { group_index: 2, query_index: 4, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 0, key_index: 0 }})    
2023-08-04T09:30:46.436997Z DEBUG salsa::derived::slot: read_upgrade(BodyWithSourceMapQuery(FunctionId(47))): inputs=Tracked {
    inputs: [
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(5) }),
        module_items(FileId(0)),
        parse(FileId(0)),
    ],
}    
2023-08-04T09:30:46.437015Z DEBUG salsa::lru: record_use(node=BodyWithSourceMapQuery(FunctionId(47)))    
2023-08-04T09:30:46.437023Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437033Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(47))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 1, key_index: 5 }})    
2023-08-04T09:30:46.437043Z DEBUG salsa::derived::slot: read_upgrade(BodyQuery(FunctionId(47))): inputs=Tracked {
    inputs: [
        body_with_source_map(FunctionId(47)),
    ],
}    
2023-08-04T09:30:46.437055Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(47)))    
2023-08-04T09:30:46.437062Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437073Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437082Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437089Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.437097Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 4 }: execute_query_implementation invoked    
2023-08-04T09:30:46.437104Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): executing query    
2023-08-04T09:30:46.437110Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437117Z  INFO salsa::derived::slot: BodyQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437124Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437147Z  INFO salsa::derived::slot: BodyQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437154Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(47)))    
2023-08-04T09:30:46.437160Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437175Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(47))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 5 }})    
2023-08-04T09:30:46.437184Z DEBUG salsa::derived::slot: read_upgrade(ExprScopesQuery(FunctionId(47))): inputs=Tracked {
    inputs: [
        body(FunctionId(47)),
    ],
}    
2023-08-04T09:30:46.437194Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437201Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437209Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437217Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.437223Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437230Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.437237Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.437243Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437250Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437258Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437264Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437271Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437277Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437284Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437293Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437300Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437307Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437314Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437320Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437326Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437334Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437341Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.437348Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437355Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.437361Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.437368Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437374Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437381Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437387Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437394Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437414Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437420Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437429Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437436Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437442Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437449Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437455Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437461Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437468Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437475Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.437481Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437487Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.437494Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.437500Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437507Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437513Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437519Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437525Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437532Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437538Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437547Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437555Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437561Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437568Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437574Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437580Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437587Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437594Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.437601Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437607Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.437613Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.437619Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437626Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437633Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437639Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437646Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437653Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437715Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437725Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437732Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437739Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437745Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437751Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437758Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437765Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437771Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.437778Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437784Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.437790Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.437796Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437803Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437809Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437815Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437821Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437828Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437834Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437845Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437852Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437859Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437865Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437871Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437877Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437884Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437890Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.437897Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437903Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.437909Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.437915Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.437922Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.437928Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): invoked at R172    
2023-08-04T09:30:46.437935Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(47)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.437941Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(47)): returning memoized value changed at R172    
2023-08-04T09:30:46.437947Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(47)))    
2023-08-04T09:30:46.437966Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.438008Z DEBUG salsa::derived::slot: read_upgrade(DependencyOrderQuery(FileId(0))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 1 }, DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 2 }, DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 1 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 43 }, DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 3 }, DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 2 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 44 }, DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 0 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 45 }, DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 4 }, DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 3 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 46 }, DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 5 }, DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 4 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 47 }})    
2023-08-04T09:30:46.438029Z DEBUG salsa::derived::slot: read_upgrade(DependencyOrderQuery(FileId(0))): inputs=Tracked {
    inputs: [
        module_scope(FileId(0)),
        body(FunctionId(42)),
        body(FunctionId(43)),
        expr_scopes(FunctionId(43)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(1) }),
        body(FunctionId(44)),
        expr_scopes(FunctionId(44)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(2) }),
        body(FunctionId(45)),
        expr_scopes(FunctionId(45)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(3) }),
        body(FunctionId(46)),
        expr_scopes(FunctionId(46)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(4) }),
        body(FunctionId(47)),
        expr_scopes(FunctionId(47)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(5) }),
    ],
}    
2023-08-04T09:30:46.438060Z DEBUG salsa::lru: record_use(node=DependencyOrderQuery(FileId(0)))    
2023-08-04T09:30:46.438067Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.438078Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.438086Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.438093Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.438100Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.438107Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.438113Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.438120Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.438128Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.438135Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.438142Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.438149Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.438155Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.438161Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.438318Z  INFO request{method="textDocument/definition"}: gleamalyzer::meter: respond with ~153 bytes in 19.916167ms
2023-08-04T09:30:46.577351Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577418Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577430Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.577441Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.577450Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.577458Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.577465Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.577504Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577514Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577522Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.577530Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.577537Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.577544Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577559Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577568Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577576Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.577583Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.577591Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.577598Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577607Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577614Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577621Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.577628Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.577635Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.577642Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577649Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577656Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577663Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.577670Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.577677Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.577683Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577690Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577698Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577704Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.577711Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.577718Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.577724Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577732Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577740Z  INFO salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.577762Z DEBUG salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.577769Z  INFO salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.577777Z DEBUG salsa::lru: record_use(node=BodySourceMapQuery(FunctionId(45)))    
2023-08-04T09:30:46.577784Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577795Z  INFO ide::ide::goto_definition: Resolving pattern Variable(
    Variable(
        VARIABLE@265..270
          NAME_REF@265..270
            IDENT@265..270 "snake"
        ,
    ),
)
2023-08-04T09:30:46.577818Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577826Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.577834Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.577841Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.577848Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.577854Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577863Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577870Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577877Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.577884Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.577891Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.577898Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577904Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577911Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.577918Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.577925Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.577931Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.577938Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.577950Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.577958Z  INFO salsa::derived::slot: DependencyOrderQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.577965Z DEBUG salsa::derived::slot: DependencyOrderQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.577975Z  INFO salsa::derived::slot: DependencyOrderQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.577982Z DEBUG salsa::lru: record_use(node=DependencyOrderQuery(FileId(0)))    
2023-08-04T09:30:46.577989Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.578001Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.578008Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.578016Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.578022Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.578029Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.578036Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.578058Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.578067Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.578074Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.578081Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.578088Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.578095Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.578101Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.578218Z  INFO request{method="textDocument/definition"}: gleamalyzer::meter: respond with ~153 bytes in 971.792µs
2023-08-04T09:30:46.740594Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740627Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.740638Z DEBUG salsa::derived::slot: ParseQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R4    
2023-08-04T09:30:46.740648Z  INFO salsa::derived::slot: ParseQuery(FileId(0)): returning memoized value changed at R4    
2023-08-04T09:30:46.740656Z DEBUG salsa::lru: record_use(node=ParseQuery(FileId(0)))    
2023-08-04T09:30:46.740663Z DEBUG salsa::lru: record_use: green_zone=12    
2023-08-04T09:30:46.740669Z DEBUG salsa::lru: record_use: index=0    
2023-08-04T09:30:46.740706Z  INFO ide::ide::hover: HERERE Variable(Variable(VARIABLE@265..270))
2023-08-04T09:30:46.740716Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740726Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.740733Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.740741Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.740748Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.740754Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.740767Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740775Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.740781Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.740788Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.740795Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.740801Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.740809Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740816Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.740823Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.740829Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.740835Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.740841Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.740848Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740855Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.740861Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.740868Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.740893Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.740900Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.740906Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740913Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.740920Z DEBUG salsa::derived::slot: ModuleItemsQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R8    
2023-08-04T09:30:46.740926Z  INFO salsa::derived::slot: ModuleItemsQuery(FileId(0)): returning memoized value changed at R8    
2023-08-04T09:30:46.740932Z DEBUG salsa::lru: record_use(node=ModuleItemsQuery(FileId(0)))    
2023-08-04T09:30:46.740938Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.740945Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740953Z  INFO salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.740960Z DEBUG salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.740967Z  INFO salsa::derived::slot: BodySourceMapQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.740974Z DEBUG salsa::lru: record_use(node=BodySourceMapQuery(FunctionId(45)))    
2023-08-04T09:30:46.740980Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.740989Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.740997Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.741004Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741011Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.741018Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.741024Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741031Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741038Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.741044Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741051Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.741057Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.741063Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741070Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741076Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.741083Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741089Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.741095Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.741101Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741116Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741131Z  INFO salsa::derived::slot: InferFunctionQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.741139Z DEBUG salsa::derived::slot: InferFunctionQuery(FunctionId(44)): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.741147Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 3, query_index: 0, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.741157Z  INFO salsa::derived::slot: InferFunctionQuery(FunctionId(44)): executing query    
2023-08-04T09:30:46.741180Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741188Z  INFO salsa::derived::slot: DependencyOrderQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.741195Z DEBUG salsa::derived::slot: DependencyOrderQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741204Z  INFO salsa::derived::slot: DependencyOrderQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.741211Z DEBUG salsa::lru: record_use(node=DependencyOrderQuery(FileId(0)))    
2023-08-04T09:30:46.741217Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741227Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741240Z  INFO salsa::derived::slot: InferFunctionGroupQuery([FunctionId(44), FunctionId(45)]): invoked at R172    
2023-08-04T09:30:46.741249Z DEBUG salsa::derived::slot: InferFunctionGroupQuery([FunctionId(44), FunctionId(45)]): read_upgrade(revision_now=R172)    
2023-08-04T09:30:46.741257Z DEBUG salsa::runtime: DatabaseKeyIndex { group_index: 3, query_index: 1, key_index: 0 }: execute_query_implementation invoked    
2023-08-04T09:30:46.741264Z  INFO salsa::derived::slot: InferFunctionGroupQuery([FunctionId(44), FunctionId(45)]): executing query    
2023-08-04T09:30:46.741274Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741281Z  INFO salsa::derived::slot: BodyQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.741287Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(44)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741294Z  INFO salsa::derived::slot: BodyQuery(FunctionId(44)): returning memoized value changed at R172    
2023-08-04T09:30:46.741300Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(44)))    
2023-08-04T09:30:46.741307Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741326Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741334Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.741341Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(44)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741347Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): returning memoized value changed at R172    
2023-08-04T09:30:46.741353Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(44)))    
2023-08-04T09:30:46.741360Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741368Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741375Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.741381Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741388Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.741394Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.741400Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741409Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741416Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): invoked at R172    
2023-08-04T09:30:46.741422Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(44)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741428Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(44)): returning memoized value changed at R172    
2023-08-04T09:30:46.741434Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(44)))    
2023-08-04T09:30:46.741441Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741471Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741479Z  INFO salsa::derived::slot: BodyQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.741486Z DEBUG salsa::derived::slot: BodyQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741492Z  INFO salsa::derived::slot: BodyQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.741498Z DEBUG salsa::lru: record_use(node=BodyQuery(FunctionId(45)))    
2023-08-04T09:30:46.741504Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741514Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741521Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.741527Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741534Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.741540Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.741546Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741553Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741560Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): invoked at R172    
2023-08-04T09:30:46.741566Z DEBUG salsa::derived::slot: ModuleScopeQuery(FileId(0)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741573Z  INFO salsa::derived::slot: ModuleScopeQuery(FileId(0)): returning memoized value changed at R172    
2023-08-04T09:30:46.741579Z DEBUG salsa::lru: record_use(node=ModuleScopeQuery(FileId(0)))    
2023-08-04T09:30:46.741585Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741592Z DEBUG salsa: unwind_if_cancelled: current_revision=R172, pending_revision=R172    
2023-08-04T09:30:46.741598Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): invoked at R172    
2023-08-04T09:30:46.741605Z DEBUG salsa::derived::slot: ExprScopesQuery(FunctionId(45)): found memoized value, verified_at=R172, changed_at=R172    
2023-08-04T09:30:46.741611Z  INFO salsa::derived::slot: ExprScopesQuery(FunctionId(45)): returning memoized value changed at R172    
2023-08-04T09:30:46.741617Z DEBUG salsa::lru: record_use(node=ExprScopesQuery(FunctionId(45)))    
2023-08-04T09:30:46.741624Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741661Z DEBUG salsa::derived::slot: read_upgrade(InferFunctionGroupQuery([FunctionId(44), FunctionId(45)])): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 3 }, DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 2 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 44 }, DatabaseKeyIndex { group_index: 2, query_index: 6, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 2, key_index: 0 }, DatabaseKeyIndex { group_index: 2, query_index: 5, key_index: 0 }, DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 45 }})    
2023-08-04T09:30:46.741676Z DEBUG salsa::derived::slot: read_upgrade(InferFunctionGroupQuery([FunctionId(44), FunctionId(45)])): inputs=Tracked {
    inputs: [
        body(FunctionId(44)),
        expr_scopes(FunctionId(44)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(2) }),
        module_scope(FileId(0)),
        body(FunctionId(45)),
        expr_scopes(FunctionId(45)),
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(3) }),
    ],
}    
2023-08-04T09:30:46.741702Z DEBUG salsa::lru: record_use(node=InferFunctionGroupQuery([FunctionId(44), FunctionId(45)]))    
2023-08-04T09:30:46.741709Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741720Z DEBUG salsa::derived::slot: read_upgrade(InferFunctionQuery(FunctionId(44))): result.changed_at=R172, result.durability=Durability(0), result.dependencies = Some({DatabaseKeyIndex { group_index: 0, query_index: 0, key_index: 44 }, DatabaseKeyIndex { group_index: 2, query_index: 7, key_index: 0 }, DatabaseKeyIndex { group_index: 3, query_index: 1, key_index: 0 }})    
2023-08-04T09:30:46.741743Z DEBUG salsa::derived::slot: read_upgrade(InferFunctionQuery(FunctionId(44))): inputs=Tracked {
    inputs: [
        intern_function(InFile { file_id: FileId(0), value: Idx::<Function>(2) }),
        dependency_order(FileId(0)),
        infer_function_group([FunctionId(44), FunctionId(45)]),
    ],
}    
2023-08-04T09:30:46.741757Z DEBUG salsa::lru: record_use(node=InferFunctionQuery(FunctionId(44)))    
2023-08-04T09:30:46.741764Z DEBUG salsa::lru: record_use: green_zone=0    
2023-08-04T09:30:46.741825Z  INFO request{method="textDocument/hover"}: gleamalyzer::meter: respond with ~143 bytes in 1.333042ms
2023-08-04T09:30:46.868351Z  INFO notification{method="$/setTrace"}: gleamalyzer::meter: handled notification in 8.208µs
